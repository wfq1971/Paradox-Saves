

// === Shader Info === 

// Shader file: gfx/FX/gui_war_arrow.shader
// Effect: strategic_objective_arrow
// ===ShaderInfo End===



// === Defines === 

#define PDX_DIRECTX_11
#define PIXEL_SHADER
#define PDX_HLSL
#define PDX_MAX_HEIGHTMAP_COMPRESS_LEVELS 5
#define JOMINI_REFRACTION_ENABLED
#define HIGH_QUALITY_SHADERS


// === HLSL Macros === 

#define PDX_POSITION SV_Position
#define PDX_COLOR SV_Target
#define PDX_COLOR0 SV_Target0
#define PDX_COLOR0_SRC1 SV_Target1 // Use this when doing dual source blending, currently only supports that for render target #0
#define PDX_COLOR1 SV_Target1
#define PDX_COLOR2 SV_Target2
#define PDX_COLOR3 SV_Target3
#define PDX_COLOR4 SV_Target4
#define PDX_COLOR5 SV_Target5
#define PDX_COLOR6 SV_Target6
#define PDX_COLOR7 SV_Target7
#define PDX_VertexID SV_VertexID
#define PDX_InstanceID SV_InstanceID
#define PDX_DispatchThreadID SV_DispatchThreadID
#define PDX_GroupThreadID SV_GroupThreadID
#define PDX_GroupID SV_GroupID
#define PDX_GroupIndex SV_GroupIndex
#define PDX_TessFactor SV_TessFactor
#define PDX_InsideTessFactor SV_InsideTessFactor
#define PDX_OutputControlPointID SV_OutputControlPointID
#define PDX_DomainLocation SV_DomainLocation
#define PDX_RenderTargetArrayIndex SV_RenderTargetArrayIndex
#define PDX_ViewportArrayIndex SV_ViewportArrayIndex

#define PdxDomainTypeTriangle "tri"
#define PdxDomainTypeQuad "quad"
#define PdxDomainTypeIsoline "isoline"

#define PdxPartitioningModeInteger "integer"
#define PdxPartitioningModeFractionalEven "fractional_even"
#define PdxPartitioningModeFractionalOdd "fractional_odd"

#define PdxPrimitiveTypePoint point
#define PdxPrimitiveTypeLine line
#define PdxPrimitiveTypeTriangle triangle
#define PdxPrimitiveTypeLineAdjacency lineadj
#define PdxPrimitiveTypeTriangleAdjacency triangleadj

#define PdxTessellatorOutputTopologyPoint "point"
#define PdxTessellatorOutputTopologyLine "line"
#define PdxTessellatorOutputTopologyTriangleCw "triangle_cw"
#define PdxTessellatorOutputTopologyTriangleCcw "triangle_ccw"

#define PdxMeshShaderOutputTopologyLine "line"
#define PdxMeshShaderOutputTopologyTriangle "triangle"

#define mod( X, Y ) ( (X) % (Y) )

float2x2 Create2x2( in float2 x, in float2 y )
{
	return transpose( float2x2( x, y ) );
}
// TODO, Create3x3 should be transposed in hlsl, and not in glsl, and then the mul() arguments should be reversed
#define Create3x3 float3x3
float4x4 Create4x4( in float4 x, in float4 y, in float4 z, in float4 w )
{
	return transpose( float4x4( x, y, z, w ) );
}

#define GetMatrixData( Matrix, row, col ) ( Matrix [ row ] [ col ] )

float3x3 CastTo3x3( in float4x4 M )
{
	return (float3x3)M;
}

#define lessThan( a, b ) ( (a) < (b) )

float2 vec2(float vValue) { return float2(vValue, vValue); }
float3 vec3(float vValue) { return float3(vValue, vValue, vValue); }
float4 vec4(float vValue) { return float4(vValue, vValue, vValue, vValue); }


struct PdxTextureSampler2D
{
    Texture2D 		_Texture;
    SamplerState 	_Sampler;
};
struct PdxTextureSampler2DMS
{
    Texture2DMS<float4>		_Texture;
};

struct PdxTextureSampler2DArray
{
    Texture2DArray	_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSampler3D
{
    Texture3D 		_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSamplerCube
{
    TextureCube 	_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSampler2DCmp
{
    Texture2D 				_Texture;
    SamplerComparisonState 	_Sampler;
};

// These are for separate Texture/Sampler objects
#define PdxSampleTex2D(tex,samp,uv) (tex).Sample( (samp), (uv) )
#define PdxSampleTex2DLod(tex,samp,uv,lod) (tex).SampleLevel( (samp), (uv), (lod) )
#define PdxSampleTex2DGrad(tex,samp,uv,ddx,ddy) (tex).SampleGrad( (samp), (uv), (ddx), (ddy) )
#define PdxSampleTex2DGather(tex,samp,uv) (tex).Gather( (samp), (uv) )

#define PdxSampleTex3D(tex,samp,uv) (tex).Sample( (samp), (uv) )
#define PdxSampleTex3DLod(tex,samp,uv,lod) (tex).SampleLevel( (samp), (uv), (lod) )

#define PdxTexture2DSize(tex,size) (tex).GetDimensions( (size).x, (size).y )
#define PdxTexture2DLoad(tex,uv,lod) (tex).Load( int3((uv), (lod)) )

#define PdxTexture2DArraySize(tex,size,elements) (tex).GetDimensions( (size).x, (size).y, elements )
#define PdxTexture2DArrayLoad(tex,uv,arrayindex,lod) (tex).Load( int4((uv), (arrayindex), (lod)) )

#define PdxTexture3DSize(tex,size) (tex).GetDimensions( (size).x, (size).y, (size).z )
#define PdxTexture3DLoad(tex,uv,lod) (tex).Load( int4((uv), (lod)) )

// These are for the combined TextureSampler objects
#define PdxTex2DSize(samp,size) PdxTexture2DSize( (samp)._Texture, (size) )
#define PdxTex2D(samp,uv) PdxSampleTex2D( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex2DLod(samp,uv,lod) PdxSampleTex2DLod( (samp)._Texture, (samp)._Sampler, (uv), (lod) )
#define PdxTex2DLodOffset(samp,uv,lod,offset) (samp)._Texture.SampleLevel( (samp)._Sampler, (uv), (lod), (offset) )
#define PdxTex2DBias(samp,uv,bias) (samp)._Texture.SampleBias( (samp)._Sampler, (uv), (bias) )
#define PdxTex2DGrad(samp,uv,ddx,ddy) PdxSampleTex2DGrad( (samp)._Texture, (samp)._Sampler, (uv), (ddx), (ddy) )
#define PdxTex2DGather(samp,uv) PdxSampleTex2DGather( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex2DLoad(samp,uv,lod) PdxTexture2DLoad( (samp)._Texture, (uv), (lod) )
#define PdxTex2DMultiSampled(samp,texelcoord,sampleidx) (samp)._Texture.Load( (texelcoord), (sampleidx) )
#define PdxTex2DMSSize(samp,size,samples) (samp)._Texture.GetDimensions( (size).x, (size).y, (samples) )

#define PdxTex3D(samp,uv) PdxSampleTex3D( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex3DLod(samp,uv,lod) PdxSampleTex3DLod( (samp)._Texture, (samp)._Sampler, (uv), (lod) )
#define PdxTex3DLoad(samp,uv,lod) PdxTexture3DLoad( (samp)._Texture, (uv), (lod) )

#define PdxTexCube(samp,uv) (samp)._Texture.Sample( (samp)._Sampler, (uv) )
#define PdxTexCubeLod(samp,uv,lod) (samp)._Texture.SampleLevel( (samp)._Sampler, (uv), (lod) )
#define PdxTexCubeBias(samp,uv,bias) (samp)._Texture.SampleBias( (samp)._Sampler, (uv), (bias) )

#define PdxTex2DCmpLod0(samp,uv,value) (samp)._Texture.SampleCmpLevelZero( (samp)._Sampler, (uv), (value) )

// Vulkan fails to compile shaders with this function call properly
// Commenting it out until we can fix this issue
//#define PdxCalculateLod(samp,uv) (samp)._Texture.CalculateLevelOfDetail( (samp)._Sampler, (uv) )

float4x4 FixProjection( float4x4 ProjectionMatrix )
{
	// Enable for "debug" drawing to see if some objects is missing fix
	#if 0
	for ( int i = 0; i < 4; ++i )
	{
		GetMatrixData( ProjectionMatrix, 0, i ) *= 0.5;
		GetMatrixData( ProjectionMatrix, 1, i ) *= 0.5;
	}
	#endif
	
	return ProjectionMatrix;
}

#define PdxBufferFloat  Buffer<float>
#define PdxBufferFloat2	Buffer<float2>
#define PdxBufferFloat3	Buffer<float3>
#define PdxBufferFloat4	Buffer<float4>
#define PdxBufferInt  	Buffer<int>
#define PdxBufferInt2	Buffer<int2>
#define PdxBufferInt3	Buffer<int3>
#define PdxBufferInt4	Buffer<int4>
#define PdxBufferUint   Buffer<uint>
#define PdxBufferUint2	Buffer<uint2>
#define PdxBufferUint3	Buffer<uint3>
#define PdxBufferUint4	Buffer<uint4>

#define PdxStructuredBuffer StructuredBuffer
#define PdxRWStructuredBuffer RWStructuredBuffer
#define PdxRasterizerOrderedBuffer RasterizerOrderedBuffer
#define PdxRasterizerOrderedStructuredBuffer RasterizerOrderedStructuredBuffer

float 	PdxReadBuffer( in PdxBufferFloat Buf, int Index )  		{ return Buf.Load( Index ); }
float2	PdxReadBuffer2( in PdxBufferFloat2 Buf, int Index )		{ return Buf.Load( Index ); }
float3	PdxReadBuffer3( in PdxBufferFloat3 Buf, int Index )		{ return Buf.Load( Index ); }
float4	PdxReadBuffer4( in PdxBufferFloat4 Buf, int Index )		{ return Buf.Load( Index ); }

int  	PdxReadBuffer( in PdxBufferInt Buf, int Index ) 		{ return Buf.Load( Index ); }
int2 	PdxReadBuffer2( in PdxBufferInt2 Buf, int Index )		{ return Buf.Load( Index ); }
int3 	PdxReadBuffer3( in PdxBufferInt3 Buf, int Index )    	{ return Buf.Load( Index ); }
int4 	PdxReadBuffer4( in PdxBufferInt4 Buf, int Index )    	{ return Buf.Load( Index ); }

uint  	PdxReadBuffer( in PdxBufferUint Buf, int Index )    	{ return Buf.Load( Index ); }
uint2 	PdxReadBuffer2( in PdxBufferUint2 Buf, int Index )  	{ return Buf.Load( Index ); }
uint3 	PdxReadBuffer3( in PdxBufferUint3 Buf, int Index )  	{ return Buf.Load( Index ); }
uint4 	PdxReadBuffer4( in PdxBufferUint4 Buf, int Index )  	{ return Buf.Load( Index ); }

#define PdxReadRWBuffer(buffer,index) (buffer)[(index)]
#define PdxWriteRWBuffer(buffer,index,value) (buffer)[(index)] = (value)

#define Quaternion float4

#define UINT16_MAX 0xffff
#define UINT32_MAX 0xffffffff
#define PI 3.14159265359

float2x2 Create2x2( float a, float b, float c, float d ) { return Create2x2( float2( a, b ), float2( c, d ) ); }

#define PdxSampleTex2DLod0(tex,samp,uv) PdxSampleTex2DLod( (tex), (samp), (uv), 0 )

#define PdxTexture2DLoad0(tex,uv) PdxTexture2DLoad( (tex), (uv), 0 )

#define PdxTexture2DArrayLoad0(tex,uv,arrayindex) PdxTexture2DArrayLoad( (tex), (uv), (arrayindex), 0)

#define PdxTex2DProj(samp,uv_proj) PdxTex2DLod0( (samp), (uv_proj).xy / (uv_proj).w )
#define PdxTex2DLod0(samp,uv) PdxTex2DLod( (samp), (uv), 0 )
#define PdxTex2DLod0Offset(samp,uv,offset) PdxTex2DLodOffset( (samp), (uv), 0, (offset) )
#define PdxTex2DLoad0(samp,uv) PdxTex2DLoad( (samp), (uv), 0 )

#define PdxTex3DLod0(samp,uv) PdxTex3DLod( (samp), (uv), 0 )
#define PdxTex3DLoad0(samp,uv) PdxTex3DLoad( (samp), (uv), 0 )

float4 FixProjectionAndMul( float4x4 ProjectionMatrix, float4 Vector )
{
	return mul( FixProjection( ProjectionMatrix ), Vector );
}



// === Vertex Structs === 

struct VS_INPUT3D
{
	float3 Position : POSITION;
	float3 Normal : NORMAL;
	float3 Tangent : TEXCOORD0;
	float2 UV : TEXCOORD1;
	uint VertexID : PDX_VertexID;
};
struct VS_OUTPUT_PDXLINES
{
	float4 Position : PDX_POSITION;
	float3 Normal : NORMAL;
	float3 Tangent : TEXCOORD0;
	float3 Bitangent : TEXCOORD1;
	float3 WorldSpacePos : TEXCOORD2;
	float2 UV : TEXCOORD3;
	float2 MaskUV : TEXCOORD4;
	float2 UV0To1 : TEXCOORD5;
};


// === Constant Buffers === 

cbuffer pdx_hlsl_cbPdxConstantBuffer0
{
	float4 TintColor;
	float2 UVScale;
	float2 UVOffsetScale;
	float2 MaskUVScale;
	float Width;
	float LineLength;
	float Progress;
	float AnimationTime;
}
cbuffer pdx_hlsl_cbPdxCamera
{
	float4x4 ViewProjectionMatrix;
	float4x4 InvViewProjectionMatrix;
	float4x4 ViewMatrix;
	float4x4 InvViewMatrix;
	float4x4 ProjectionMatrix;
	float4x4 InvProjectionMatrix;
	float4x4 ShadowMapTextureMatrix;
	float3 CameraPosition;
	float ZNear;
	float3 CameraLookAtDir;
	float ZFar;
	float3 CameraUpDir;
	float CameraFoV;
	float3 CameraRightDir;
	float _UpscaleLodBias;
	float _UpscaleLodBiasNative;
	float _UpscaleLodBiasMultiplier;
	float _UpscaleLodBiasMultiplierNative;
	float _UpscaleLodBiasEnabled;
}
cbuffer pdx_hlsl_cbPdxShadowmap
{
	float ShadowFadeFactor;
	float Bias;
	float KernelScale;
	float ShadowScreenSpaceScale;
	int NumSamples;
	float4 DiscSamples[8];
}
cbuffer pdx_hlsl_cbJominiEnvironment
{
	float3 AmbientPosX;
	float CubemapIntensity;
	float3 AmbientNegX;
	float3 AmbientPosY;
	float3 AmbientNegY;
	float3 AmbientPosZ;
	float3 AmbientNegZ;
	float3 ShadowAmbientPosX;
	float3 ShadowAmbientNegX;
	float3 ShadowAmbientPosY;
	float3 ShadowAmbientNegY;
	float3 ShadowAmbientPosZ;
	float3 ShadowAmbientNegZ;
	float FogMax;
	float3 SunDiffuse;
	float SunIntensity;
	float3 ToSunDir;
	float FogBegin2;
	float3 FogColor;
	float FogEnd2;
	float4x4 CubemapYRotation;
	float TreeSwayLoopSpeed;
	float TreeSwayWindStrengthSpatialModifier;
	float TreeSwaySpeed;
	float TreeSwayWindClusterSizeModifier;
	float3 TreeSwayWorldDirection;
	float TreeHeightImpactOnSway;
	float TreeSwayScale;
}


// === Samplers === 

SamplerState _sampler_0_ : register(s0);
SamplerState _sampler_1_ : register(s1);


// === Textures === 

Texture2D DiffuseTexture_Texture;
static PdxTextureSampler2D DiffuseTexture = { DiffuseTexture_Texture, _sampler_0_ };
Texture2D NormalTexture_Texture;
static PdxTextureSampler2D NormalTexture = { NormalTexture_Texture, _sampler_1_ };
Texture2D PropertiesTexture_Texture;
static PdxTextureSampler2D PropertiesTexture = { PropertiesTexture_Texture, _sampler_1_ };
Texture2D MaskTexture_Texture;
static PdxTextureSampler2D MaskTexture = { MaskTexture_Texture, _sampler_1_ };


// === RW Textures === 



// === Buffer Textures === 



// === RW Buffer Textures === 



// === Shader Code === 

// Gamma correction utility
float ToGamma(float aLinear)
{
	return pow(aLinear, 1.0/2.2);
}
float3 ToGamma(float3 aLinear)
{
	return pow(aLinear, vec3(1.0/2.2));
}
float ToLinear(float aGamma)
{
	return pow(aGamma, 2.2);
}
float3 ToLinear(float3 aGamma)
{
	return pow(aGamma, vec3(2.2));
}
float4 ToLinear(float4 aGamma)
{
	return float4(pow(aGamma.rgb, vec3(2.2)), aGamma.a);
}

// Color value conversions
float3 RGBtoHSV( float3 RGB )
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = RGB.g < RGB.b ? float4(RGB.bg, K.wz) : float4(RGB.gb, K.xy);
	float4 q = RGB.r < p.x ? float4(p.xyw, RGB.r) : float4(RGB.r, p.yzx);

	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3( abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x );
}
float3 HSVtoRGB( float3 HSV )
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs( frac(HSV.xxx + K.xyz) * 6.0 - K.www );
	return HSV.z * lerp( K.xxx, clamp(p - K.xxx, 0.0, 1.0), HSV.y );
}
float3 HSVtoRGB( float H, float S, float V )
{
	return HSVtoRGB( float3( H, S, V ) );
}
float4 RGBtoHSV( float4 RGBa )
{
	return float4( RGBtoHSV( RGBa.rgb ), RGBa.a );
}
float4 HSVtoRGB( float4 HSVa )
{
	return float4( HSVtoRGB( HSVa.xyz ), HSVa.a );
}
float4 HSVtoRGB( float H, float S, float V, float a )
{
	return HSVtoRGB( float4( H, S, V, a ) );
}

// Below are multiple blend mode utilities (See: https://en.wikipedia.org/wiki/Blend_modes)
// Most of these uses a typical implementation unless stated otherwise

// Multiply blend mode
float3 Multiply( float3 Base, float3 Blend, float Opacity )
{
	return Base * Blend * Opacity + Base * ( 1.0 - Opacity );
}

// Screen blend mode
float3 Screen( float3 Base, float3 Blend )
{
	return 1.0 - ( ( 1.0 - Base ) * ( 1.0 - Blend ) );
}

// Overlay blend mode
float Overlay( float Base, float Blend )
{
	return (Base < 0.5) ? (2.0 * Base * Blend) : (1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend));
}
float3 Overlay( float3 Base, float3 Blend )
{
	return float3( Overlay(Base.r, Blend.r), Overlay(Base.g, Blend.g), Overlay(Base.b, Blend.b) );
}
float Overlay( float Base, float Blend, float Opacity )
{
	return Overlay( Base, Blend ) * Opacity + Base * (1.0 - Opacity );
}
float3 Overlay( float3 Base, float3 Blend, float Opacity )
{
	return Overlay( Base, Blend ) * Opacity + Base * (1.0 - Opacity );
}
float3 GetOverlay( float3 Color, float3 OverlayColor, float OverlayPercent )
{
	// Flip OverlayColor/BaseColor since that was how it was before
	return lerp( Color, Overlay( OverlayColor, Color ), OverlayPercent );
}
float GetOverlay( float Color, float OverlayColor, float OverlayPercent )
{
	// Flip OverlayColor/BaseColor since that was how it was before
	return lerp( Color, Overlay( OverlayColor, Color ), OverlayPercent );
}

// Color dodge blend mode (Dodge and burn)
float ColorDodge( float Base, float Blend )
{
	return (Blend == 1.0) ? Blend : min( Base / (1.0 - Blend), 1.0 );
}
float3 ColorDodge( float3 Base, float3 Blend )
{
	return float3( ColorDodge(Base.r, Blend.r), ColorDodge(Base.g, Blend.g), ColorDodge(Base.b, Blend.b) );
}
float3 ColorDodge( float3 Base, float3 Blend, float Opacity )
{
	return ColorDodge( Base, Blend ) * Opacity + Base * ( 1.0 - Opacity );
}

// Pegtop's SoftLight blend formula
float SoftLight( float Base, float Blend )
{
	return ( 1 - 2 * Blend ) * Base * Base + 2 * Base * Blend;
}
float3 SoftLight( float3 Base, float3 Blend )
{
	return float3( SoftLight( Base.r, Blend.r ), SoftLight( Base.g, Blend.g ), SoftLight( Base.b, Blend.b ) );
}
float SoftLight( float Base, float Blend, float Opacity )
{
	return lerp( Base, SoftLight( Base, Blend ), Opacity );
}
float3 SoftLight( float3 Base, float3 Blend, float Opacity )
{
	return lerp( Base, SoftLight( Base, Blend ), Opacity );
}

// Hardlight blend mode
float HardLight(float Base, float Blend)
{
	return Blend >= 0.5 ? 1.0 - 2 * ( 1.0 - Blend ) * ( 1.0 - Base ) : 2.0 * Base * Blend;
}
float3 HardLight( float3 Base, float3 Blend )
{
	return float3( HardLight( Base.r, Blend.r ), HardLight( Base.g, Blend.g ), HardLight( Base.b, Blend.b ) );
}
float HardLight( float Base, float Blend, float Opacity )
{
	return lerp( Base, HardLight( Base, Blend ), Opacity );
}
float3 HardLight( float3 Base, float3 Blend, float Opacity )
{
	return lerp( Base, HardLight( Base, Blend ), Opacity );
}

// Simple arithmetic blend modes (See: https://en.wikipedia.org/wiki/Blend_modes#Simple_arithmetic_blend_modes)
// Lighten only blend mode
float3 Add( float3 Base, float3 Blend, float Opacity )
{
	return ( Base + Blend ) * Opacity + Base * ( 1.0 - Opacity );
}
float Lighten( float Base, float Blend )
{
	return max( Base, Blend );
}
float3 Lighten( float3 Base, float3 Blend )
{
	return float3( Lighten(Base.r, Blend.r), Lighten(Base.g, Blend.g), Lighten(Base.b, Blend.b) );
}
float3 Lighten( float3 Base, float3 Blend, float Opacity )
{
	return Lighten( Base, Blend ) * Opacity + Base * ( 1.0 - Opacity );
}

// Darken only blend mode
float Darken( float Base, float Blend )
{
	return min( Base, Blend );
}
float3 Darken( float3 Base, float3 Blend )
{
	return float3( Darken(Base.r, Blend.r), Darken(Base.g, Blend.g), Darken(Base.b, Blend.b) );
}
float3 Darken( float3 Base, float3 Blend, float Opacity )
{
	return Darken( Base, Blend ) * Opacity + Base * ( 1.0 - Opacity );
}

float3 Levels( float3 vInColor, float3 vMinInput, float3 vMaxInput )
{
	float3 vRet = saturate( vInColor - vMinInput );
	vRet /= vMaxInput - vMinInput;
	return saturate( vRet );
}
float Levels( float vInValue, float vMinValue, float vMaxValue )
{
	return saturate( ( vInValue - vMinValue ) / ( vMaxValue - vMinValue ) );
}

// Intuitive way to dynamically grow and shrink masks, similar to Histogram Scan in Substance Designer.
// vInValue is typically a mask texture, vPosition is the value to be remapped to 0.5, vRange is the softness of that remap.
float LevelsScan( float vInValue, float vPosition, float vRange )
{
	return Levels( vInValue, vPosition - ( vRange / 2 ), vPosition + ( vRange / 2 ) );
}

float3 UnpackNormal( float4 NormalMapSample )
{
	float3 vNormalSample = NormalMapSample.rgb - 0.5;
	vNormalSample.g = -vNormalSample.g;
	return vNormalSample;
}

float3 UnpackNormal( in PdxTextureSampler2D NormalTex, float2 uv )
{
	return UnpackNormal( PdxTex2D( NormalTex, uv ) );
}

float3 UnpackRRxGNormal( float4 NormalMapSample )
{
	float x = NormalMapSample.g * 2.0 - 1.0;
	float y = NormalMapSample.a * 2.0 - 1.0;
	y = -y;
	float z = sqrt( saturate( 1.0 - x * x - y * y ) );
	return float3( x, y, z );
}

float3 UnpackRRxGNormal( in PdxTextureSampler2D NormalTex, float2 uv )
{
	return UnpackRRxGNormal( PdxTex2D( NormalTex, uv ) );
}

float3 ReorientNormal( float3 BaseNormal, float3 DetailNormal )
{
	float3 t = BaseNormal + float3( 0.0, 0.0, 1.0 );
	float3 u = DetailNormal * float3( -1.0, -1.0, 1.0 );
	float3 Normal = normalize( t * dot( t, u ) - u * t.z );
	return Normal;
}

float Fresnel( float NdotL, float FresnelBias, float FresnelPow )
{
	return saturate( FresnelBias + (1.0 - FresnelBias) * pow( 1.0 - NdotL, FresnelPow ) );
}

#define REMAP_IMPL NewMin + ( NewMax - NewMin ) * ( (Value - OldMin) / (OldMax - OldMin) )
float Remap( float Value, float OldMin, float OldMax, float NewMin, float NewMax ) { return REMAP_IMPL; }
float2 Remap( float2 Value, float2 OldMin, float2 OldMax, float2 NewMin, float2 NewMax ) { return REMAP_IMPL; }
float3 Remap( float3 Value, float3 OldMin, float3 OldMax, float3 NewMin, float3 NewMax ) { return REMAP_IMPL; }
#undef REMAP_IMPL
#define REMAP_IMPL NewMin + ( NewMax - NewMin ) * saturate( (Value - OldMin) / (OldMax - OldMin) )
float RemapClamped( float Value, float OldMin, float OldMax, float NewMin, float NewMax ) { return REMAP_IMPL; }
float2 RemapClamped( float2 Value, float2 OldMin, float2 OldMax, float2 NewMin, float2 NewMax ) { return REMAP_IMPL; }
float3 RemapClamped( float3 Value, float3 OldMin, float3 OldMax, float3 NewMin, float3 NewMax ) { return REMAP_IMPL; }
#undef REMAP_IMPL
float CalcViewSpaceDepth( float Depth )
{
	Depth = 2.0 * Depth - 1.0;
	float ZLinear = 2.0 * ZNear * ZFar / (ZFar + ZNear - Depth * (ZFar - ZNear));
	return ZLinear;
}

float3 ViewSpacePosFromDepth( float Depth, float2 UV )
{
	float x = UV.x * 2.0 - 1.0;
	float y = (1.0 - UV.y) * 2.0 - 1.0;
	
	float4 ProjectedPos = float4( x, y, Depth, 1.0 );
	
	float4 ViewSpacePos = mul( InvProjectionMatrix, ProjectedPos );
	
	return ViewSpacePos.xyz / ViewSpacePos.w;
}

float3 WorldSpacePositionFromDepth( float Depth, float2 UV )
{
	float3 WorldSpacePos = mul( InvViewMatrix, float4( ViewSpacePosFromDepth( Depth, UV ), 1.0 ) ).xyz;		
	return WorldSpacePos;  
}
float CalcRandom( float Seed )
{
	float DotProduct = float( Seed ) * 12.9898;
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcRandom( float2 Seed )
{
	float DotProduct = dot( Seed, float2( 12.9898, 78.233 ) );
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcRandom( float3 Seed )
{
	float DotProduct = dot( Seed, float3( 12.9898,78.233,144.7272 ) );
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcNoise( float2 Pos ) 
{
	int2 i = int2( floor( Pos ) );
	float2 f = frac( Pos );

	float a = CalcRandom( i );
	float b = CalcRandom( i + int2( 1, 0 ) );
	float c = CalcRandom( i + int2( 0, 1 ) );
	float d = CalcRandom( i + int2( 1, 1 ) );
	
	float2 u = f*f*(3.0-2.0*f);
	return lerp(a, b, u.x) + 
			(c - a)* u.y * (1.0 - u.x) + 
			(d - b) * u.x * u.y;
}
static const float TWO_PI = 6.28318530718f;

static const float SHADOW_AMBIENT_MIN_FACTOR = 0.0;
static const float SHADOW_AMBIENT_MAX_FACTOR = 0.3;

float4 SampleMask( float2 MaskUV, in PdxTextureSampler2D Texture )
{
	float2 DDX = ddx( MaskUV );
	float2 DDY = ddy( MaskUV );
	
	// This part tiles the texture from U 0.25 -> 0.75
	float MaxU = MaskUVScale.x * LineLength * Progress;
	if ( MaxU < 1.0 ) // If we are smaller than 1 tile, sample from the tip of the texture
	{
		MaskUV.x += 1.0 - MaxU;
	}
	else if ( MaskUV.x > (MaxU - 0.25) ) // Should we sample the "tip" of the texture
	{
		MaskUV.x -= MaxU - 1.0;
	}
	else if ( MaskUV.x > 0.25 ) // In the middle we repeat the texture
	{
		MaskUV.x = mod( MaskUV.x - 0.25, 0.5 ) + 0.25;
	}

	return PdxTex2DGrad( Texture, MaskUV, DDX, DDY );
}

float CalcLightFalloff( float LightRadius, float Distance, float Falloff )
{
	// TODO other, square, falloff?
	return saturate( (LightRadius - Distance) / Falloff );
}

float CalcLightFalloff( float LightRadius, float Distance )
{
	// This is basically the unreal method, square distance falloff but capped at "LightRadius" distance and capped at intensity 1 at distance 0.
	return pow( saturate( 1.0 - pow( Distance / LightRadius, 4.0 ) ), 2.0 ) / ( Distance * Distance + 1.0 );
}


float3 MetalnessToDiffuse( float Metalness, float3 Diffuse )
{
	return lerp( Diffuse, vec3(0.0), Metalness );
}

float3 MetalnessToSpec( float Metalness, float3 Diffuse, float Spec )
{
	return lerp( vec3(Spec), Diffuse, Metalness );
}


#ifndef PDX_NumMips
	#define PDX_NumMips 10.0
#endif

#ifndef PDX_MipOffset
	#define PDX_MipOffset 2.0
#endif

#define PDX_SimpleLighting


struct SMaterialProperties
{
	float 	_PerceptualRoughness;
	float 	_Roughness;
	float	_Metalness;
	
	float3	_DiffuseColor;
	float3	_SpecularColor;
	float3	_Normal;
};

struct SLightingProperties
{
	float3		_ToCameraDir;
	float3		_ToLightDir;
	float3		_LightIntensity;
	float		_ShadowTerm;
	float		_CubemapIntensity;
	// this rotation matrix is used to rotate cubemap sampling vectors, thus "faking" a rotation of the cubemap
	float4x4	_CubemapYRotation;
};

float RemapSpec( float SampledSpec )
{
	return 0.25 * SampledSpec;
}
	
float RoughnessFromPerceptualRoughness( float PerceptualRoughness )
{
	return PerceptualRoughness * PerceptualRoughness;
}

float BurleyToMipSimple( float PerceptualRoughness )
{
   float Scale = PerceptualRoughness * (1.7 - 0.7 * PerceptualRoughness);
   return Scale * ( PDX_NumMips - 1 - PDX_MipOffset );
}

float3 GetSpecularDominantDir( float3 Normal, float3 Reflection, float Roughness )
{
	float Smoothness = saturate( 1.0 - Roughness );
	float LerpFactor = Smoothness * ( sqrt( Smoothness ) + Roughness );
	return normalize( lerp( Normal, Reflection, LerpFactor ) );
}

float GetReductionInMicrofacets( float Roughness )
{
	return 1.0 / (Roughness*Roughness + 1.0);
}

float F_Schlick( float f0, float f90, float CosAngle )
{
	return f0 + ( f90 - f0 ) * pow( 1.0 - CosAngle, 5.0 );
}

float3 F_Schlick( float3 f0, float3 f90, float CosAngle )
{
	return f0 + ( f90 - f0 ) * pow( 1.0 - CosAngle, 5.0 );
}
        

float DisneyDiffuse( float NdotV, float NdotL, float LdotH, float LinearRoughness )
{
	float EnergyBias = lerp( 0.0, 0.5, LinearRoughness );
	float EnergyFactor = lerp( 1.0, 1.0 / 1.51, LinearRoughness );
	float f90 = EnergyBias + 2.0 * LdotH * LdotH * LinearRoughness;
	float LightScatter = F_Schlick( 1.0, f90, NdotL );
	float ViewScatter = F_Schlick( 1.0, f90, NdotV );
	
	return LightScatter * ViewScatter * EnergyFactor;
}

float CalcDiffuseBRDF( float NdotV, float NdotL, float LdotH, float PerceptualRoughness )
{
#ifdef PDX_SimpleLighting
	return 1.0 / PI;
#else
	return DisneyDiffuse( NdotV, NdotL, LdotH, PerceptualRoughness ) / PI;
#endif
}


float D_GGX( float NdotH, float Alpha )
{
	float Alpha2 = Alpha * Alpha;
	float f = ( NdotH * Alpha2 - NdotH ) * NdotH + 1.0;
	return Alpha2 / (PI * f * f);
}

float G1( float CosAngle, float k )
{
	return 1.0 / ( CosAngle * ( 1.0 - k ) + k );
}

float V_Schlick( float NdotL, float NdotV, float Alpha )
{
	float k = Alpha * 0.5;
	return G1( NdotL, k ) * G1( NdotV, k ) * 0.25;
}

float V_Optimized( float LdotH, float Alpha )
{
	float k = Alpha * 0.5;
	float k2 = k*k;
	float invk2 = 1.0 - k2;
	return 0.25 / ( LdotH * LdotH * invk2 + k2 );
}
        
float3 CalcSpecularBRDF( float3 SpecularColor, float LdotH, float NdotH, float NdotL, float NdotV, float Roughness )
{
	float3 F = F_Schlick( SpecularColor, vec3(1.0), LdotH );
	float D = D_GGX( NdotH, lerp( 0.03, 1.0, Roughness ) ); // Remap to avoid super small and super bright highlights
#ifdef PDX_SimpleLighting
	float Vis = V_Optimized( LdotH, Roughness );
#else
	float Vis = V_Schlick( NdotL, NdotV, Roughness );
#endif
	return D * F * Vis;
}

void CalculateLightingFromLight( SMaterialProperties MaterialProps, float3 ToCameraDir, float3 ToLightDir, float3 LightIntensity, out float3 DiffuseOut, out float3 SpecularOut )
{
	float3 H = normalize( ToCameraDir + ToLightDir );
	float NdotV = saturate( dot( MaterialProps._Normal, ToCameraDir ) ) + 1e-5;
	float NdotL = saturate( dot( MaterialProps._Normal, ToLightDir ) ) + 1e-5;
	float NdotH = saturate( dot( MaterialProps._Normal, H ) );
	float LdotH = saturate( dot( ToLightDir, H ) );
	
	float DiffuseBRDF = CalcDiffuseBRDF( NdotV, NdotL, LdotH, MaterialProps._PerceptualRoughness );
	DiffuseOut = DiffuseBRDF * MaterialProps._DiffuseColor * LightIntensity * NdotL;
	
#ifdef PDX_HACK_ToSpecularLightDir
	float3 H_Spec = normalize( ToCameraDir + PDX_HACK_ToSpecularLightDir );
	float NdotL_Spec = saturate( dot( MaterialProps._Normal, PDX_HACK_ToSpecularLightDir ) ) + 1e-5;
	float NdotH_Spec = saturate( dot( MaterialProps._Normal, H_Spec ) );
	float LdotH_Spec = saturate( dot( PDX_HACK_ToSpecularLightDir, H_Spec ) );
	float3 SpecularBRDF = CalcSpecularBRDF( MaterialProps._SpecularColor, LdotH_Spec, NdotH_Spec, NdotL_Spec, NdotV, MaterialProps._Roughness );
	SpecularOut = SpecularBRDF * LightIntensity * NdotL;
#else
	float3 SpecularBRDF = CalcSpecularBRDF( MaterialProps._SpecularColor, LdotH, NdotH, NdotL, NdotV, MaterialProps._Roughness );
	SpecularOut = SpecularBRDF * LightIntensity * NdotL;
#endif
}

void CalculateLightingFromLight( SMaterialProperties MaterialProps, SLightingProperties LightingProps, out float3 DiffuseOut, out float3 SpecularOut )
{
	CalculateLightingFromLight( MaterialProps, LightingProps._ToCameraDir, LightingProps._ToLightDir, LightingProps._LightIntensity * LightingProps._ShadowTerm, DiffuseOut, SpecularOut );
}

void CalculateLightingFromIBL( SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap, out float3 DiffuseIBLOut, out float3 SpecularIBLOut )
{
	float3 RotatedDiffuseCubemapUV = mul( CastTo3x3( LightingProps._CubemapYRotation ), MaterialProps._Normal );
	float3 DiffuseRad = PdxTexCubeLod( EnvironmentMap, RotatedDiffuseCubemapUV, ( PDX_NumMips - 1 - PDX_MipOffset ) ).rgb * LightingProps._CubemapIntensity; // TODO, maybe we should split diffuse and spec intensity?
	DiffuseIBLOut = DiffuseRad * MaterialProps._DiffuseColor;
	
	float3 ReflectionVector = reflect( -LightingProps._ToCameraDir, MaterialProps._Normal );
	float3 DominantReflectionVector = GetSpecularDominantDir( MaterialProps._Normal, ReflectionVector, MaterialProps._Roughness );

	float NdotR = saturate( dot( MaterialProps._Normal, DominantReflectionVector ) );
	float3 SpecularReflection = F_Schlick( MaterialProps._SpecularColor, vec3(1.0), NdotR );
	float SpecularFade = GetReductionInMicrofacets( MaterialProps._Roughness );

	float MipLevel = BurleyToMipSimple( MaterialProps._PerceptualRoughness );
	float3 RotatedSpecularCubemapUV = mul( CastTo3x3( LightingProps._CubemapYRotation ), DominantReflectionVector );
	float3 SpecularRad = PdxTexCubeLod( EnvironmentMap, RotatedSpecularCubemapUV, MipLevel ).rgb * LightingProps._CubemapIntensity; // TODO, maybe we should split diffuse and spec intensity?
	SpecularIBLOut = SpecularRad * SpecularFade * SpecularReflection;
}

float4x4 Float4x4Identity()
{
	return float4x4( 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );
}

SMaterialProperties GetMaterialProperties( float3 SampledDiffuse, float3 Normal, float SampledRoughness, float SampledSpec, float SampledMetalness )
{
	SMaterialProperties MaterialProps;
	
	MaterialProps._PerceptualRoughness = SampledRoughness;
	MaterialProps._Roughness = RoughnessFromPerceptualRoughness( MaterialProps._PerceptualRoughness );

	float SpecRemapped = RemapSpec( SampledSpec );
	MaterialProps._Metalness = SampledMetalness;

	MaterialProps._DiffuseColor = MetalnessToDiffuse( MaterialProps._Metalness, SampledDiffuse );
	MaterialProps._SpecularColor = MetalnessToSpec( MaterialProps._Metalness, SampledDiffuse, SpecRemapped );
	
	MaterialProps._Normal = Normal;
	
	return MaterialProps;
}

// Generate the texture co-ordinates for a PCF kernel
void CalculateCoordinates( float2 ShadowCoord, inout float2 TexCoords[5] )
{
	// Generate the texture co-ordinates for the specified depth-map size
	TexCoords[0] = ShadowCoord + float2( -KernelScale, 0.0f );
	TexCoords[1] = ShadowCoord + float2( 0.0f, KernelScale );
	TexCoords[2] = ShadowCoord + float2( KernelScale, 0.0f );
	TexCoords[3] = ShadowCoord + float2( 0.0f, -KernelScale );
	TexCoords[4] = ShadowCoord;
}

float CalculateShadow( float4 ShadowProj, PdxTextureSampler2D ShadowMap )
{
	ShadowProj.xyz = ShadowProj.xyz / ShadowProj.w;
	
	float2 TexCoords[5];
	CalculateCoordinates( ShadowProj.xy, TexCoords );
	
	// Sample each of them checking whether the pixel under test is shadowed or not
	float fShadowTerm = 0.0f;
	for( int i = 0; i < 5; i++ )
	{				
		float A = PdxTex2DLod0( ShadowMap, TexCoords[i] ).r;
		float B = ShadowProj.z - Bias;
		
		// Texel is shadowed
		fShadowTerm += ( A < 0.99f && A < B ) ? 0.0 : 1.0;
	}
	
	// Get the average
	fShadowTerm = fShadowTerm / 5.0f;
	return lerp( 1.0, fShadowTerm, ShadowFadeFactor );
}

float2 RotateDisc( float2 Disc, float2 Rotate )
{
	return float2( Disc.x * Rotate.x - Disc.y * Rotate.y, Disc.x * Rotate.y + Disc.y * Rotate.x );
}

float CalculateShadow( float4 ShadowProj, PdxTextureSampler2DCmp ShadowMap )
{
	ShadowProj.xyz = ShadowProj.xyz / ShadowProj.w;
	
	float RandomAngle = CalcRandom( round( ShadowScreenSpaceScale * ShadowProj.xy ) ) * 3.14159 * 2.0;
	float2 Rotate = float2( cos( RandomAngle ), sin( RandomAngle ) );

	// Sample each of them checking whether the pixel under test is shadowed or not
	float ShadowTerm = 0.0;
	for( int i = 0; i < NumSamples; i++ )
	{
		float4 Samples = DiscSamples[i] * KernelScale;
		ShadowTerm += PdxTex2DCmpLod0( ShadowMap, ShadowProj.xy + RotateDisc( Samples.xy, Rotate ), ShadowProj.z - Bias );
		ShadowTerm += PdxTex2DCmpLod0( ShadowMap, ShadowProj.xy + RotateDisc( Samples.zw, Rotate ), ShadowProj.z - Bias );
	}
	
	// Get the average
	ShadowTerm *= 0.5; // We have 2 samples per "sample"
	ShadowTerm = ShadowTerm / float(NumSamples);
	
	float3 FadeFactor = saturate( float3( 1.0 - abs( 0.5 - ShadowProj.xy ) * 2.0, 1.0 - ShadowProj.z ) * 32.0 ); // 32 is just a random strength on the fade
	ShadowTerm = lerp( 1.0, ShadowTerm, min( min( FadeFactor.x, FadeFactor.y ), FadeFactor.z ) );
	
	return lerp( 1.0, ShadowTerm, ShadowFadeFactor );
}

//-------------------------------
// Common lighting functions ----
//-------------------------------
SLightingProperties GetSunLightingProperties( float3 WorldSpacePos, float ShadowTerm )
{
	SLightingProperties LightingProps;
	LightingProps._ToCameraDir = normalize( CameraPosition - WorldSpacePos );
	LightingProps._ToLightDir = ToSunDir;
	LightingProps._LightIntensity = SunDiffuse * SunIntensity;
	LightingProps._ShadowTerm = ShadowTerm;
	LightingProps._CubemapIntensity = CubemapIntensity;
	LightingProps._CubemapYRotation = CubemapYRotation;
	
	return LightingProps;
}

SLightingProperties GetSunLightingProperties( float3 WorldSpacePos, PdxTextureSampler2DCmp ShadowMap )
{
	float4 ShadowProj = mul( ShadowMapTextureMatrix, float4( WorldSpacePos, 1.0 ) );
	float ShadowTerm = CalculateShadow( ShadowProj, ShadowMap );
	
	return GetSunLightingProperties( WorldSpacePos, ShadowTerm );
}

float3 CalculateSunLighting( SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap )
{
	float3 DiffuseLight;
	float3 SpecularLight;
	CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, SpecularLight );
	
	float3 DiffuseIBL;
	float3 SpecularIBL;
	CalculateLightingFromIBL( MaterialProps, LightingProps, EnvironmentMap, DiffuseIBL, SpecularIBL );
	
	return DiffuseLight + SpecularLight + DiffuseIBL + SpecularIBL;
}


//-------------------------------
// Debugging --------------------
//-------------------------------
//#define PDX_DEBUG_NORMAL
//#define PDX_DEBUG_DIFFUSE
//#define PDX_DEBUG_SPEC
//#define PDX_DEBUG_SPEC_RANGES
//#define PDX_DEBUG_ROUGHNESS
//#define PDX_DEBUG_METALNESS
//#define PDX_DEBUG_SHADOW
//#define PDX_DEBUG_SUN_LIGHT_SIMPLE_DIFFUSE // AKA Daniel mode
//#define PDX_DEBUG_SUN_LIGHT_ONLY_SPECULAR
//#define PDX_DEBUG_SUN_LIGHT
//#define PDX_DEBUG_SUN_LIGHT_WITH_SHADOW
//#define PDX_DEBUG_IBL_SIMPLE_DIFFUSE
//#define PDX_DEBUG_IBL_DIFFUSE
//#define PDX_DEBUG_IBL_SPECULAR
//#define PDX_DEBUG_IBL

void DebugReturn( inout float3 Out, SMaterialProperties MaterialProps, SLightingProperties LightingProps )
{
#ifdef PDX_DEBUG_NORMAL
	Out = saturate( MaterialProps._Normal );
#endif

#ifdef PDX_DEBUG_DIFFUSE
	Out = MaterialProps._DiffuseColor;
#endif

#ifdef PDX_DEBUG_SPEC
	Out = MaterialProps._SpecularColor;
#endif

#ifdef PDX_DEBUG_ROUGHNESS
	Out = vec3( MaterialProps._PerceptualRoughness );
#endif

#ifdef PDX_DEBUG_METALNESS
	Out = vec3( MaterialProps._Metalness );
#endif

#ifdef PDX_DEBUG_SPEC_RANGES
	// Shows extremely low specular values in red
	// Shows common material values in green (2-6%)
	// Shows gemstone material values in yellow (8-17%)
	// Shows metalness in blue
	// Shows everything else in gray scale	
	// Values based on page 14-15 in http://renderwonk.com/publications/s2010-shading-course/hoffman/s2010_physically_based_shading_hoffman_a_notes.pdf
	float Spec = MaterialProps._SpecularColor.r;
	
	float e = 0.002f;
	float ErrorThreshold = 0.01f;
	float DielectricLow = 0.02f;
	float DielectricHigh = 0.06f;
	float GemstoneLow = 0.08f;
	float GemstoneHigh = 0.17f;
	
	float Error = smoothstep( ErrorThreshold, 0.0, Spec );
	float CommonMask = smoothstep( DielectricLow-e, DielectricLow, Spec ) * smoothstep( DielectricHigh+e, DielectricHigh, Spec);
	float GemstoneMask = smoothstep( GemstoneLow-e, GemstoneLow, Spec ) * smoothstep( GemstoneHigh+e, GemstoneHigh, Spec);
	float ScaledSpec = ( Spec / RemapSpec(1.0f) );
	float3 DebugSpecColor = float3( GemstoneMask, CommonMask + GemstoneMask, 0.0 ) * ScaledSpec;
	Out = lerp( vec3(ScaledSpec), DebugSpecColor, CommonMask + GemstoneMask );
	Out = lerp( Out, float3(1.0,0.0,0.0), Error );
	Out = lerp( Out, float3(0.0,0.0,1.0), MaterialProps._Metalness );
#endif

#ifdef PDX_DEBUG_SHADOW
	Out = vec3( LightingProps._ShadowTerm );
#endif

#ifdef PDX_DEBUG_SUN_LIGHT_SIMPLE_DIFFUSE
	SMaterialProperties MaterialPropsCopy = MaterialProps;
	MaterialPropsCopy._DiffuseColor = vec3( 1.0 );
	MaterialPropsCopy._SpecularColor = vec3( 0.0 );
	
	float3 SpecularLight;
	CalculateLightingFromLight( MaterialPropsCopy, LightingProps, Out, SpecularLight );
#endif

#ifdef PDX_DEBUG_SUN_LIGHT_ONLY_SPECULAR			
	float3 DiffuseLight;			
	CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, Out );
#endif

#if defined( PDX_DEBUG_SUN_LIGHT ) || defined( PDX_DEBUG_SUN_LIGHT_WITH_SHADOW )
	float3 DiffuseLight;
	float3 SpecularLight;

	#ifdef PDX_DEBUG_SUN_LIGHT_WITH_SHADOW
		CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, SpecularLight );
	#else
		SLightingProperties LightingPropsNoShadow = LightingProps;
		LightingPropsNoShadow._ShadowTerm = 1.0;
		CalculateLightingFromLight( MaterialProps, LightingPropsNoShadow, DiffuseLight, SpecularLight );
	#endif
	
	Out = DiffuseLight + SpecularLight;
#endif
}

void DebugReturn( inout float3 Out, SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap )
{
	DebugReturn( Out, MaterialProps, LightingProps );

#if defined( PDX_DEBUG_IBL ) || defined( PDX_DEBUG_IBL_DIFFUSE ) || defined( PDX_DEBUG_IBL_SPECULAR ) || defined( PDX_DEBUG_IBL_SIMPLE_DIFFUSE )
	float3 DiffuseIBL;
	float3 SpecularIBL;
	
	SMaterialProperties MaterialPropsCopy = MaterialProps;
	#ifdef PDX_DEBUG_IBL_SIMPLE_DIFFUSE
		MaterialPropsCopy._DiffuseColor = vec3( 1.0 );
	#endif
	
	CalculateLightingFromIBL( MaterialPropsCopy, LightingProps, EnvironmentMap, DiffuseIBL, SpecularIBL );
	
	#if defined( PDX_DEBUG_IBL_DIFFUSE ) || defined( PDX_DEBUG_IBL_SIMPLE_DIFFUSE )
		Out = DiffuseIBL;
	#endif
	#ifdef PDX_DEBUG_IBL_SPECULAR
		Out = SpecularIBL;
	#endif
	#ifdef PDX_DEBUG_IBL
		Out = DiffuseIBL + SpecularIBL;
	#endif
#endif
}



// === Main Code === 

float2 GetRandomizedUv( float2 FlooredUv, float2 Uv, float2 OffsetDir, float OffsetScale )
{
	FlooredUv += OffsetDir;
	float RandomX = CalcRandom( FlooredUv ) * OffsetScale;
	float2 NudgedSeed = float2( FlooredUv.x + 12.0, FlooredUv.y + 65.0 );
	float RandomY = CalcRandom( NudgedSeed ) * OffsetScale;
	float2 Random = float2( RandomX, RandomY );
	return Uv - OffsetDir - Random;
}

// Inner arrow settings
#define InnerUvTiling 4.5	// Tiling of arrows
#define InnerUvScale 0.75	// Scale of arrows
#define RandomScale 0.5		// Distance modifier of random offset

float4 main( VS_OUTPUT_PDXLINES Input, bool PDX_IsFrontFace : SV_IsFrontFace ) : PDX_COLOR
{
	float ProgressFactor = Progress - Input.UV0To1.x;
	clip( ProgressFactor );

	// Main texture
	float4 Diffuse = PdxTex2D( DiffuseTexture, Input.UV );

	// Smaller arrows uv
	float2 InnerUv = ( Input.UV - 0.5 ) * InnerUvTiling;
	InnerUv = InnerUv + 0.5;
	InnerUv.x = InnerUv.x - AnimationTime * UVOffsetScale * InnerUvTiling;

	// Store dxdy
	float2 dx = ddx( InnerUv );
	float2 dy = ddy( InnerUv );

	// Store floored uv
	float2 InnerUvFloored = floor( InnerUv );
	InnerUv = InnerUv - InnerUvFloored;

	float2 InnerUvOffset0 =  GetRandomizedUv( InnerUvFloored, InnerUv, float2( 0.0, 0.0 ), RandomScale ) * InnerUvScale;
	float2 InnerUvOffset1 =  GetRandomizedUv( InnerUvFloored, InnerUv, float2( 0.0, -1.0 ), RandomScale ) * InnerUvScale;
	float2 InnerUvOffset2 =  GetRandomizedUv( InnerUvFloored, InnerUv, float2( -1.0, 0.0 ), RandomScale ) * InnerUvScale;
	float2 InnerUvOffset3 =  GetRandomizedUv( InnerUvFloored, InnerUv, float2( -1.0, -1.0 ), RandomScale ) * InnerUvScale;

	float4 InnerDiffuse = PdxTex2DGrad( NormalTexture, InnerUvOffset0, dx, dy );
	float4 InnerDiffuse1 = PdxTex2DGrad( NormalTexture, InnerUvOffset1, dx, dy );
	float4 InnerDiffuse2 = PdxTex2DGrad( NormalTexture, InnerUvOffset2, dx, dy );
	float4 InnerDiffuse3 = PdxTex2DGrad( NormalTexture, InnerUvOffset3, dx, dy );

	InnerDiffuse = lerp( InnerDiffuse, InnerDiffuse1, InnerDiffuse1.r );
	InnerDiffuse = lerp( InnerDiffuse, InnerDiffuse2, InnerDiffuse2.r );
	InnerDiffuse = lerp( InnerDiffuse, InnerDiffuse3, InnerDiffuse3.r );

	Diffuse *= TintColor;
	InnerDiffuse *= TintColor * 7.0;

	InnerDiffuse.a = saturate( lerp( 0.0, InnerDiffuse.a * InnerDiffuse.r, Diffuse.r * 1.0 ) );
	Diffuse = lerp( Diffuse, InnerDiffuse, InnerDiffuse.a );

	float4 Mask = SampleMask( Input.MaskUV, MaskTexture );

	return float4( Diffuse * Mask );
}

