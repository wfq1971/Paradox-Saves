

// === Shader Info === 

// Shader file: gfx/FX/pdxmesh.shader
// Effect: standard_flag_revolution_mapobject
// ===ShaderInfo End===



// === Defines === 

#define PDX_DIRECTX_11
#define PIXEL_SHADER
#define PDX_HLSL
#define JOMINI_MAP_OBJECT
#define PDX_MESH_UV1
#define IG_DEVOUT
#define IG_DEVOUT
#define REVOLUTIONFLAG
#define IG_USERDATA
#define PDX_MAX_HEIGHTMAP_COMPRESS_LEVELS 5
#define JOMINI_REFRACTION_ENABLED
#define LOW_QUALITY_SHADERS


// === HLSL Macros === 

#define PDX_POSITION SV_Position
#define PDX_COLOR SV_Target
#define PDX_COLOR0 SV_Target0
#define PDX_COLOR0_SRC1 SV_Target1 // Use this when doing dual source blending, currently only supports that for render target #0
#define PDX_COLOR1 SV_Target1
#define PDX_COLOR2 SV_Target2
#define PDX_COLOR3 SV_Target3
#define PDX_COLOR4 SV_Target4
#define PDX_COLOR5 SV_Target5
#define PDX_COLOR6 SV_Target6
#define PDX_COLOR7 SV_Target7
#define PDX_VertexID SV_VertexID
#define PDX_InstanceID SV_InstanceID
#define PDX_DispatchThreadID SV_DispatchThreadID
#define PDX_GroupThreadID SV_GroupThreadID
#define PDX_GroupID SV_GroupID
#define PDX_GroupIndex SV_GroupIndex
#define PDX_TessFactor SV_TessFactor
#define PDX_InsideTessFactor SV_InsideTessFactor
#define PDX_OutputControlPointID SV_OutputControlPointID
#define PDX_DomainLocation SV_DomainLocation
#define PDX_RenderTargetArrayIndex SV_RenderTargetArrayIndex
#define PDX_ViewportArrayIndex SV_ViewportArrayIndex
#define PDX_Depth SV_Depth

#define PdxDomainTypeTriangle "tri"
#define PdxDomainTypeQuad "quad"
#define PdxDomainTypeIsoline "isoline"

#define PdxPartitioningModeInteger "integer"
#define PdxPartitioningModeFractionalEven "fractional_even"
#define PdxPartitioningModeFractionalOdd "fractional_odd"

#define PdxPrimitiveTypePoint point
#define PdxPrimitiveTypeLine line
#define PdxPrimitiveTypeTriangle triangle
#define PdxPrimitiveTypeLineAdjacency lineadj
#define PdxPrimitiveTypeTriangleAdjacency triangleadj

#define PdxTessellatorOutputTopologyPoint "point"
#define PdxTessellatorOutputTopologyLine "line"
#define PdxTessellatorOutputTopologyTriangleCw "triangle_cw"
#define PdxTessellatorOutputTopologyTriangleCcw "triangle_ccw"

#define PdxMeshShaderOutputTopologyLine "line"
#define PdxMeshShaderOutputTopologyTriangle "triangle"

#define mod( X, Y ) ( (X) % (Y) )

float2x2 Create2x2( in float2 x, in float2 y )
{
	return transpose( float2x2( x, y ) );
}
// TODO, Create3x3 should be transposed in hlsl, and not in glsl, and then the mul() arguments should be reversed
#define Create3x3 float3x3
float4x4 Create4x4( in float4 x, in float4 y, in float4 z, in float4 w )
{
	return transpose( float4x4( x, y, z, w ) );
}

#define GetMatrixData( Matrix, row, col ) ( Matrix [ row ] [ col ] )

float3x3 CastTo3x3( in float4x4 M )
{
	return (float3x3)M;
}

#define lessThan( a, b ) ( (a) < (b) )

float2 vec2(float vValue) { return float2(vValue, vValue); }
float3 vec3(float vValue) { return float3(vValue, vValue, vValue); }
float4 vec4(float vValue) { return float4(vValue, vValue, vValue, vValue); }


struct PdxTextureSampler2D
{
    Texture2D 		_Texture;
    SamplerState 	_Sampler;
};
struct PdxTextureSampler2DMS
{
    Texture2DMS<float4>		_Texture;
};

struct PdxTextureSampler2DArray
{
    Texture2DArray	_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSampler3D
{
    Texture3D 		_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSamplerCube
{
    TextureCube 	_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSampler2DCmp
{
    Texture2D 				_Texture;
    SamplerComparisonState 	_Sampler;
};

// These are for separate Texture/Sampler objects
#define PdxSampleTex2D(tex,samp,uv) (tex).Sample( (samp), (uv) )
#define PdxSampleTex2DLod(tex,samp,uv,lod) (tex).SampleLevel( (samp), (uv), (lod) )
#define PdxSampleTex2DGrad(tex,samp,uv,ddx,ddy) (tex).SampleGrad( (samp), (uv), (ddx), (ddy) )
#define PdxSampleTex2DGather(tex,samp,uv) (tex).Gather( (samp), (uv) )

#define PdxSampleTex3D(tex,samp,uv) (tex).Sample( (samp), (uv) )
#define PdxSampleTex3DLod(tex,samp,uv,lod) (tex).SampleLevel( (samp), (uv), (lod) )

#define PdxTexture2DSize(tex,size) (tex).GetDimensions( (size).x, (size).y )
#define PdxTexture2DLoad(tex,uv,lod) (tex).Load( int3((uv), (lod)) )

#define PdxTexture2DArraySize(tex,size,elements) (tex).GetDimensions( (size).x, (size).y, elements )
#define PdxTexture2DArrayLoad(tex,uv,arrayindex,lod) (tex).Load( int4((uv), (arrayindex), (lod)) )

#define PdxTexture3DSize(tex,size) (tex).GetDimensions( (size).x, (size).y, (size).z )
#define PdxTexture3DLoad(tex,uv,lod) (tex).Load( int4((uv), (lod)) )

// These are for the combined TextureSampler objects
#define PdxTex2DSize(samp,size) PdxTexture2DSize( (samp)._Texture, (size) )
#define PdxTex2D(samp,uv) PdxSampleTex2D( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex2DLod(samp,uv,lod) PdxSampleTex2DLod( (samp)._Texture, (samp)._Sampler, (uv), (lod) )
#define PdxTex2DLodOffset(samp,uv,lod,offset) (samp)._Texture.SampleLevel( (samp)._Sampler, (uv), (lod), (offset) )
#define PdxTex2DBias(samp,uv,bias) (samp)._Texture.SampleBias( (samp)._Sampler, (uv), (bias) )
#define PdxTex2DGrad(samp,uv,ddx,ddy) PdxSampleTex2DGrad( (samp)._Texture, (samp)._Sampler, (uv), (ddx), (ddy) )
#define PdxTex2DGather(samp,uv) PdxSampleTex2DGather( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex2DLoad(samp,uv,lod) PdxTexture2DLoad( (samp)._Texture, (uv), (lod) )
#define PdxTex2DMultiSampled(samp,texelcoord,sampleidx) (samp)._Texture.Load( (texelcoord), (sampleidx) )
#define PdxTex2DMSSize(samp,size,samples) (samp)._Texture.GetDimensions( (size).x, (size).y, (samples) )

#define PdxTex3D(samp,uv) PdxSampleTex3D( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex3DLod(samp,uv,lod) PdxSampleTex3DLod( (samp)._Texture, (samp)._Sampler, (uv), (lod) )
#define PdxTex3DLoad(samp,uv,lod) PdxTexture3DLoad( (samp)._Texture, (uv), (lod) )

#define PdxTexCube(samp,uv) (samp)._Texture.Sample( (samp)._Sampler, (uv) )
#define PdxTexCubeLod(samp,uv,lod) (samp)._Texture.SampleLevel( (samp)._Sampler, (uv), (lod) )
#define PdxTexCubeBias(samp,uv,bias) (samp)._Texture.SampleBias( (samp)._Sampler, (uv), (bias) )

#define PdxTex2DCmpLod0(samp,uv,value) (samp)._Texture.SampleCmpLevelZero( (samp)._Sampler, (uv), (value) )

// Vulkan fails to compile shaders with this function call properly
// Commenting it out until we can fix this issue
//#define PdxCalculateLod(samp,uv) (samp)._Texture.CalculateLevelOfDetail( (samp)._Sampler, (uv) )

float4x4 FixProjection( float4x4 ProjectionMatrix )
{
	// Enable for "debug" drawing to see if some objects is missing fix
	#if 0
	for ( int i = 0; i < 4; ++i )
	{
		GetMatrixData( ProjectionMatrix, 0, i ) *= 0.5;
		GetMatrixData( ProjectionMatrix, 1, i ) *= 0.5;
	}
	#endif
	
	return ProjectionMatrix;
}

#define PdxBufferFloat  Buffer<float>
#define PdxBufferFloat2	Buffer<float2>
#define PdxBufferFloat3	Buffer<float3>
#define PdxBufferFloat4	Buffer<float4>
#define PdxBufferInt  	Buffer<int>
#define PdxBufferInt2	Buffer<int2>
#define PdxBufferInt3	Buffer<int3>
#define PdxBufferInt4	Buffer<int4>
#define PdxBufferUint   Buffer<uint>
#define PdxBufferUint2	Buffer<uint2>
#define PdxBufferUint3	Buffer<uint3>
#define PdxBufferUint4	Buffer<uint4>

#define PdxStructuredBuffer StructuredBuffer
#define PdxRWStructuredBuffer RWStructuredBuffer
#define PdxRasterizerOrderedBuffer RasterizerOrderedBuffer
#define PdxRasterizerOrderedStructuredBuffer RasterizerOrderedStructuredBuffer

float 	PdxReadBuffer( in PdxBufferFloat Buf, int Index )  		{ return Buf.Load( Index ); }
float2	PdxReadBuffer2( in PdxBufferFloat2 Buf, int Index )		{ return Buf.Load( Index ); }
float3	PdxReadBuffer3( in PdxBufferFloat3 Buf, int Index )		{ return Buf.Load( Index ); }
float4	PdxReadBuffer4( in PdxBufferFloat4 Buf, int Index )		{ return Buf.Load( Index ); }

int  	PdxReadBuffer( in PdxBufferInt Buf, int Index ) 		{ return Buf.Load( Index ); }
int2 	PdxReadBuffer2( in PdxBufferInt2 Buf, int Index )		{ return Buf.Load( Index ); }
int3 	PdxReadBuffer3( in PdxBufferInt3 Buf, int Index )    	{ return Buf.Load( Index ); }
int4 	PdxReadBuffer4( in PdxBufferInt4 Buf, int Index )    	{ return Buf.Load( Index ); }

uint  	PdxReadBuffer( in PdxBufferUint Buf, int Index )    	{ return Buf.Load( Index ); }
uint2 	PdxReadBuffer2( in PdxBufferUint2 Buf, int Index )  	{ return Buf.Load( Index ); }
uint3 	PdxReadBuffer3( in PdxBufferUint3 Buf, int Index )  	{ return Buf.Load( Index ); }
uint4 	PdxReadBuffer4( in PdxBufferUint4 Buf, int Index )  	{ return Buf.Load( Index ); }

#define PdxReadRWBuffer(buffer,index) (buffer)[(index)]
#define PdxWriteRWBuffer(buffer,index,value) (buffer)[(index)] = (value)

#define Quaternion float4

#define UINT16_MAX 0xffff
#define UINT32_MAX 0xffffffff
#define PI 3.14159265359

float2x2 Create2x2( float a, float b, float c, float d ) { return Create2x2( float2( a, b ), float2( c, d ) ); }

#define PdxSampleTex2DLod0(tex,samp,uv) PdxSampleTex2DLod( (tex), (samp), (uv), 0 )

#define PdxTexture2DLoad0(tex,uv) PdxTexture2DLoad( (tex), (uv), 0 )

#define PdxTexture2DArrayLoad0(tex,uv,arrayindex) PdxTexture2DArrayLoad( (tex), (uv), (arrayindex), 0)

#define PdxTex2DProj(samp,uv_proj) PdxTex2DLod0( (samp), (uv_proj).xy / (uv_proj).w )
#define PdxTex2DLod0(samp,uv) PdxTex2DLod( (samp), (uv), 0 )
#define PdxTex2DLod0Offset(samp,uv,offset) PdxTex2DLodOffset( (samp), (uv), 0, (offset) )
#define PdxTex2DLoad0(samp,uv) PdxTex2DLoad( (samp), (uv), 0 )

#define PdxTex3DLod0(samp,uv) PdxTex3DLod( (samp), (uv), 0 )
#define PdxTex3DLoad0(samp,uv) PdxTex3DLoad( (samp), (uv), 0 )

float4 FixProjectionAndMul( float4x4 ProjectionMatrix, float4 Vector )
{
	return mul( FixProjection( ProjectionMatrix ), Vector );
}



// === Vertex Structs === 

struct VS_INPUT_PDXMESHSTANDARD
{
	float3 Position : POSITION;
	float3 Normal : TEXCOORD0;
	float4 Tangent : TEXCOORD1;
	float2 UV0 : TEXCOORD2;
#ifdef PDX_MESH_UV1
	float2 UV1 : TEXCOORD3;
#endif
#ifdef PDX_MESH_UV2
	float2 UV2 : TEXCOORD4;
#endif
	uint4 InstanceIndices : TEXCOORD5;
#ifdef PDX_MESH_SKINNED
	uint4 BoneIndex : TEXCOORD6;
	float3 BoneWeight : TEXCOORD7;
#endif
	uint VertexID : PDX_VertexID;
};
struct VS_OUTPUT_PDXMESHSHADOW
{
	float4 Position : PDX_POSITION;
	float2 UV : TEXCOORD0;
};
struct VS_OUTPUT_PDXMESHSHADOWSTANDARD
{
	float4 Position : PDX_POSITION;
	float3 UV_InstanceIndex : TEXCOORD0;
};
struct VS_INPUT_DEBUGNORMAL
{
	float3 Position : POSITION;
	float3 Normal : TEXCOORD0;
#ifdef PDX_MESH_SKINNED
	uint4 BoneIndex : TEXCOORD1;
	float3 BoneWeight : TEXCOORD2;
#endif
	uint2 InstanceIndices : TEXCOORD4;
	uint VertexID : PDX_VertexID;
};
struct VS_OUTPUT_DEBUGNORMAL
{
	float4 Position : PDX_POSITION;
};
struct VS_INPUT_PDX_TERRAIN
{
	float2 UV : TEXCOORD0;
	float2 LodDirection : TEXCOORD1;
	uint4 NodeOffset_Scale_Lerp : TEXCOORD2;
};
struct VS_INPUT_PDX_TERRAIN_SKIRT
{
	float2 UV : TEXCOORD0;
	float2 LodDirection : TEXCOORD1;
	uint4 NodeOffset_Scale_Lerp : TEXCOORD2;
	uint VertexID : PDX_VertexID;
};
struct VS_INPUT_WATER
{
	int2 Position : POSITION;
};
struct VS_OUTPUT_WATER
{
	float4 Position : PDX_POSITION;
	float3 WorldSpacePos : TEXCOORD0;
	float2 UV01 : TEXCOORD1;
};
struct VS_INPUT_PDXMESH_MAPOBJECT
{
	float3 Position : POSITION;
	float3 Normal : TEXCOORD0;
	float4 Tangent : TEXCOORD1;
	float2 UV0 : TEXCOORD2;
#ifdef PDX_MESH_UV1
	float2 UV1 : TEXCOORD3;
#endif
#ifdef PDX_MESH_UV2
	float2 UV2 : TEXCOORD4;
#endif
	uint InstanceIndex24_Opacity8 : TEXCOORD5;
};
struct VS_INPUT_DEBUGNORMAL_BATCHED
{
	float3 Position : POSITION;
	float3 Normal : TEXCOORD0;
	uint InstanceIndex : TEXCOORD4;
	uint VertexID : PDX_VertexID;
};
struct VS_OUTPUT_DEBUGNORMAL_BATCHED
{
	float4 Position : PDX_POSITION;
};
struct VS_OUTPUT_MAPOBJECT_SHADOW
{
	float4 Position : PDX_POSITION;
	float2 UV : TEXCOORD0;
	uint InstanceIndex24_Opacity8 : TEXCOORD1;
};
struct PS_COLOR_SSAO
{
	float4 Color : PDX_COLOR0;
	float4 SSAOColor : PDX_COLOR1;
};
struct VS_OUTPUT
{
	float4 Position : PDX_POSITION;
	float3 Normal : TEXCOORD0;
	float3 Tangent : TEXCOORD1;
	float3 Bitangent : TEXCOORD2;
	float2 UV0 : TEXCOORD3;
	float2 UV1 : TEXCOORD4;
	float3 WorldSpacePos : TEXCOORD5;
	uint InstanceIndex : TEXCOORD6;
};


// === Constant Buffers === 

cbuffer pdx_hlsl_cbPdxCamera
{
	float4x4 ViewProjectionMatrix;
	float4x4 InvViewProjectionMatrix;
	float4x4 ViewMatrix;
	float4x4 InvViewMatrix;
	float4x4 ProjectionMatrix;
	float4x4 InvProjectionMatrix;
	float4x4 ShadowMapTextureMatrix;
	float3 CameraPosition;
	float ZNear;
	float3 CameraLookAtDir;
	float ZFar;
	float3 CameraUpDir;
	float CameraFoV;
	float3 CameraRightDir;
	float _UpscaleLodBias;
	float _UpscaleLodBiasNative;
	float _UpscaleLodBiasMultiplier;
	float _UpscaleLodBiasMultiplierNative;
	float _UpscaleLodBiasEnabled;
}
cbuffer pdx_hlsl_cbPdxMeshInstanceData
{
	float4 Data[2];
}
cbuffer pdx_hlsl_cbPdxMeshJointVertexInstanceData
{
	float4 JointVertexMatrices[3];
}
cbuffer pdx_hlsl_cbPdxHeightmapConstants
{
	float4 TileToHeightMapScaleAndOffset[5];
	float2 WorldSpaceToLookup;
	float2 OriginalHeightmapToWorldSpace;
	float2 IndirectionSize;
	float2 PackedHeightMapSize;
	float BaseTileSize;
	float HeightScale;
}
cbuffer pdx_hlsl_cbPdxTerrainConstants
{
	float3 _NormalScale;
	float _QuadtreeLeafNodeScale;
	float2 _NormalStepSize;
	float2 _DetailTileFactor;
	float _DetailBlendRange;
	float _SkirtSize;
	float2 _NormQuadtreeToWorld;
	float2 _WorldSpaceToTerrain0To1;
	float2 _WorldSpaceToDetail;
	float2 _DetailTexelSize;
	float2 _DetailTextureSize;
	float2 _WorldExtents;
}
cbuffer pdx_hlsl_cbPdxShadowmap
{
	float ShadowFadeFactor;
	float Bias;
	float KernelScale;
	float ShadowScreenSpaceScale;
	int NumSamples;
	float4 DiscSamples[8];
}
cbuffer pdx_hlsl_cbJominiEnvironment
{
	float3 AmbientPosX;
	float CubemapIntensity;
	float3 AmbientNegX;
	float3 AmbientPosY;
	float3 AmbientNegY;
	float3 AmbientPosZ;
	float3 AmbientNegZ;
	float3 ShadowAmbientPosX;
	float3 ShadowAmbientNegX;
	float3 ShadowAmbientPosY;
	float3 ShadowAmbientNegY;
	float3 ShadowAmbientPosZ;
	float3 ShadowAmbientNegZ;
	float FogMax;
	float3 SunDiffuse;
	float SunIntensity;
	float3 ToSunDir;
	float FogBegin2;
	float3 FogColor;
	float FogEnd2;
	float4x4 CubemapYRotation;
	float TreeSwayLoopSpeed;
	float TreeSwayWindStrengthSpatialModifier;
	float TreeSwaySpeed;
	float TreeSwayWindClusterSizeModifier;
	float3 TreeSwayWorldDirection;
	float TreeHeightImpactOnSway;
	float TreeSwayScale;
}
cbuffer pdx_hlsl_cbJominiWater
{
	float2 _ScreenResolution;
	float _WaterReflectionNormalFlatten;
	float _WaterZoomedInZoomedOutFactor;
	float3 _WaterToSunDir;
	float _WaterDiffuseMultiplier;
	float3 _WaterColorShallow;
	float _WaterSpecular;
	float3 _WaterColorDeep;
	float _WaterSpecularFactor;
	float3 _WaterColorMapTint;
	float _WaterColorMapTintFactor;
	float _WaterGlossScale;
	float _WaterGlossBase;
	float _WaterFresnelBias;
	float _WaterFresnelPow;
	float _WaterCubemapIntensity;
	float _WaterFoamScale;
	float _WaterFoamDistortFactor;
	float _WaterFoamShoreMaskDepth;
	float _WaterFoamShoreMaskSharpness;
	float _WaterFoamNoiseScale;
	float _WaterFoamNoiseSpeed;
	float _WaterFoamStrength;
	float _WaterRefractionScale;
	float _WaterRefractionShoreMaskDepth;
	float _WaterRefractionShoreMaskSharpness;
	float _WaterRefractionFade;
	float2 _WaterWave1Scale;
	float _WaterWave1Rotation;
	float _WaterWave1Speed;
	float2 _WaterWave2Scale;
	float _WaterWave2Rotation;
	float _WaterWave2Speed;
	float2 _WaterWave3Scale;
	float _WaterWave3Rotation;
	float _WaterWave3Speed;
	float _WaterWave1NormalFlatten;
	float _WaterWave2NormalFlatten;
	float _WaterWave3NormalFlatten;
	float _WaterFlowTime;
	float2 _WaterFlowMapSize;
	float _WaterFlowNormalScale;
	float _WaterFlowNormalFlatten;
	float _WaterHeight;
	float _WaterFadeShoreMaskDepth;
	float _WaterFadeShoreMaskSharpness;
	float _WaterSeeThroughDensity;
	float _WaterSeeThroughShoreMaskDepth;
	float _WaterSeeThroughShoreMaskSharpness;
}
cbuffer pdx_hlsl_cbJominiColorMapConstants
{
	float2 IndirectionMapSize;
	float2 InvIndirectionMapSize;
	float2 GradientTextureSize;
	float2 InvGradientTextureSize;
	float2 SecondaryProvinceColorsOffset;
	float2 HighlightProvinceColorsOffset;
	float2 AlternateProvinceColorsOffset;
	float IndirectionMapDepth;
}
cbuffer pdx_hlsl_cbGradientBorders
{
	float GB_GradientAlphaInside;
	float GB_GradientAlphaOutside;
	float GB_GradientWidth;
	float GB_GradientColorMul;
	float GB_EdgeWidth;
	float GB_EdgeSmoothness;
	float GB_EdgeAlpha;
	float GB_EdgeColorMul;
	float GB_PreLightingBlend;
	float GB_PostLightingBlend;
}
cbuffer pdx_hlsl_cbGameSharedConstants
{
	float2 MapSize;
	float2 _ProvinceMapSize;
	float4 _SSAOColorMesh;
	float4 _MeshTintColor;
	float4 _DecentralizedCountryColor;
	float4 _ImpassableTerrainColor;
	float4 _NightLightColor;
	float4 _FlatmapFoldsColor;
	float4 _FlatmapLinesColor;
	float4 _FlatmapDetailsColor;
	float3 _SecondSunDiffuse;
	float _SecondSunIntensity;
	float3 _SecondSunDir;
	float GlobalTime;
	float _FlatmapHeight;
	float _FlatmapLerp;
	float _ShorelineMaskBlur;
	float _ShorelineExtentStr;
	float _ShorelineAlpha;
	int _ShoreLinesUVScale;
	float _FlatmapOverlayLandOpacity;
	float _FlatmapEquatorPosition;
	int _FlatmapEquatorTiling;
	int _ImpassableTerrainTiling;
	float _ImpassableTerrainHeight;
	float _DistanceFadeStart;
	float _DistanceFadeEnd;
	float _WaterShadowMultiplier;
	float _MeshTintHeightMin;
	float _MeshTintHeightMax;
	float _SSAOAlphaTrees;
	float _SSAOAlphaTerrain;
	float _FogCloseOffset;
	float _FogFarOffset;
	float _FogWidthScale;
	float _DistanceRoughnessPosition;
	float _DistanceRoughnessBlend;
	float _DistanceRoughnessScale;
	float _OverlayOpacity;
	int _MapPaintingTextureTiling;
	int _MapPaintingFlatmapTextureTiling;
	bool _UseMapmodeTextures;
	bool _UsePrimaryRedAsGradient;
	bool _UseStripeOccupation;
	float _NightWaterAdjustment;
	float _DayNightBrightness;
	float _DayNightValue;
	float _DayValue;
	float _NightValue;
	float _LightsFadeTime;
	float _LightsActivateBegin;
	float _LightsActivateEnd;
}
cbuffer pdx_hlsl_cbJominiFogOfWar
{
	float2 FogOfWarAlphaMapSize;
	float2 InverseWorldSize;
	float2 FogOfWarPatternSpeed;
	float FogOfWarPatternStrength;
	float FogOfWarPatternTiling;
	float FogOfWarTime;
	float FogOfWarAlphaMin;
}
cbuffer pdx_hlsl_cbDevastationConstants
{
	float2 DevastationBezierPoint1;
	float2 DevastationBezierPoint2;
	int DevastationTexIndex;
	int DevastationTexIndexOffset;
	int DevastationNoiseTiling;
	int DevastationTextureTiling;
	float DevastationHue;
	float DevastationSaturation;
	float DevastationValue;
	float DevastationTreeHue;
	float DevastationTreeSaturation;
	float DevastationTreeValue;
	float DevastationAreaPosition;
	float DevastationAreaContrast;
	float DevastationAreaMax;
	float DevastationHeightWeight;
	float DevastationHeightContrast;
	float DevastationExclusionMaskMin;
	float DevastationExclusionMaskMax;
	float DevastationTreeAlphaReduce;
	float DevastationForceAdd;
}
cbuffer pdx_hlsl_cbPollutionConstants
{
	float3 IridescenseRimlightDirection;
	float _Padding1;
	float2 PollutionBezierPoint1;
	float2 PollutionBezierPoint2;
	int PollutionTexIndex;
	int PollutionTexIndexOffset;
	int PollutionNoiseTiling;
	int PollutionTextureTiling;
	float PollutionHue;
	float PollutionSaturation;
	float PollutionValue;
	float PollutionAlpha;
	float PollutionTreeHue;
	float PollutionTreeSaturation;
	float PollutionTreeValue;
	float PollutionAreaPosition;
	float PollutionAreaContrast;
	float PollutionAreaMax;
	float PollutionHeightWeight;
	float PollutionHeightContrast;
	float PollutionExclusionMaskMin;
	float PollutionExclusionMaskMax;
	float PollutionTreeAlphaReduce;
	float PollutionForceAdd;
	float IridescenseOpacity;
	float IridescenseNoiseTiling;
	float IridescensePosition;
	float IridescenseContrast;
	float IridescenseRoughness;
	float IridescenseRed;
	float IridescenseGreen;
	float IridescenseBlue;
	float IridescenseRimlightStrength;
	float IridescenseThicknessMin;
	float IridescenseThicknessmax;
	float IridescenseMediumn;
	float IridescenseFilmn;
	float Iridescenseinternaln;
}
cbuffer pdx_hlsl_cbGameFogOfWar
{
	float4 _FoWShadowColor;
	float4 _FoWCloudsColor;
	float4 _FoWCloudsColorGradient;
	float4 _FoWCloudsColorSunset;
	float4 _FoWCloudsColorSunsetGradient;
	float4 _FoWCloudsColorNight;
	float4 _FoWCloudsColorNightGradient;
	float2 _FoWMasterUVScale;
	float2 _FoWMasterUVSpeed;
	float2 _FoWLayer1Speed;
	float2 _FoWLayer2Speed;
	float2 _FoWLayer3Speed;
	float _FoWCloudsColorDayGradientMin;
	float _FoWCloudsColorDayGradientMax;
	float _FoWCloudsColorSunsetGradientMin;
	float _FoWCloudsColorSunsetGradientMax;
	float _FoWCloudsColorNightGradientMin;
	float _FoWCloudsColorNightGradientMax;
	float _FoWCloudHeight;
	float _CloudNormalStrength;
	float _CloudAmbientValue;
	float _CloudLightMultiplier;
	float _CloudLightMin;
	float _CloudLightMax;
	float _CloudSunsetColorValueMin;
	float _CloudSunsetColorValueMax;
	float _FoWShadowMult;
	float _FoWShadowTexStart;
	float _FoWShadowTexStop;
	float _FoWShadowAlphaStart;
	float _FoWShadowAlphaStop;
	float _FowShadowLayer1Min;
	float _FowShadowLayer1Max;
	float _FowShadowLayer2Min;
	float _FowShadowLayer2Max;
	float _FowShadowLayer3Min;
	float _FowShadowLayer3Max;
	float _FoWCloudsAlphaStart;
	float _FoWCloudsAlphaStop;
	float _FoWMasterStart;
	float _FoWMasterStop;
	int _FoWMasterUVTiling;
	float _FoWMasterUVRotation;
	float _FoWLayer1Min;
	float _FoWLayer1Max;
	int _FoWLayer1Tiling;
	float _FoWLayer2Min;
	float _FoWLayer2Max;
	float _FoWLayer2Balance;
	int _FoWLayer2Tiling;
	float _FoWLayer3Min;
	float _FoWLayer3Max;
	float _FoWLayer3Balance;
	int _FoWLayer3Tiling;
	float _FoWShowAlphaMask;
}
cbuffer pdx_hlsl_cbMapCoaConstants0
{
	float _MapCoaAngle;
	float _MapCoaAspectRatio;
	float _MapCoaSize;
	float _MapCoaSizeFlatmap;
	float _MapCoaBlend;
	float _MapCoaBlendFlatmap;
	float _MapCoaBlendOccupation;
	float _MapCoaBlendOccupationFlatmap;
	float _MapCoaBlendFadeStart;
	float _MapCoaBlendFadeEnd;
	float _MapCoaRowOffset;
	float _MapCoaRowCount;
	float _MapCoaStripeScale;
	float _MapCoaStripeScaleFlatmap;
	bool _MapCoaEnabled;
}


// === Samplers === 

SamplerState _sampler_0_ : register(s0);
SamplerState _sampler_1_ : register(s1);
SamplerState _sampler_2_ : register(s2);
SamplerState _sampler_3_ : register(s3);
SamplerState _sampler_4_ : register(s4);
SamplerComparisonState _sampler_5_ : register(s5);


// === Textures === 

Texture2D HeightLookupTexture_Texture;
static PdxTextureSampler2D HeightLookupTexture = { HeightLookupTexture_Texture, _sampler_0_ };
Texture2D PackedHeightTexture_Texture;
static PdxTextureSampler2D PackedHeightTexture = { PackedHeightTexture_Texture, _sampler_1_ };
Texture2DArray DetailTextures_Texture;
static PdxTextureSampler2DArray DetailTextures = { DetailTextures_Texture, _sampler_2_ };
Texture2DArray NormalTextures_Texture;
static PdxTextureSampler2DArray NormalTextures = { NormalTextures_Texture, _sampler_2_ };
Texture2DArray MaterialTextures_Texture;
static PdxTextureSampler2DArray MaterialTextures = { MaterialTextures_Texture, _sampler_2_ };
Texture2D DetailIndexTexture_Texture;
static PdxTextureSampler2D DetailIndexTexture = { DetailIndexTexture_Texture, _sampler_0_ };
Texture2D DetailMaskTexture_Texture;
static PdxTextureSampler2D DetailMaskTexture = { DetailMaskTexture_Texture, _sampler_0_ };
Texture2D ColorTexture_Texture;
static PdxTextureSampler2D ColorTexture = { ColorTexture_Texture, _sampler_3_ };
Texture2D ProvinceColorIndirectionTexture_Texture;
static PdxTextureSampler2D ProvinceColorIndirectionTexture = { ProvinceColorIndirectionTexture_Texture, _sampler_4_ };
Texture2D ProvinceColorTexture_Texture;
static PdxTextureSampler2D ProvinceColorTexture = { ProvinceColorTexture_Texture, _sampler_0_ };
Texture2D BorderDistanceFieldTexture_Texture;
static PdxTextureSampler2D BorderDistanceFieldTexture = { BorderDistanceFieldTexture_Texture, _sampler_3_ };
Texture2D DevastationPollution_Texture;
static PdxTextureSampler2D DevastationPollution = { DevastationPollution_Texture, _sampler_2_ };
Texture2D DevastationVFXLUT_Texture;
static PdxTextureSampler2D DevastationVFXLUT = { DevastationVFXLUT_Texture, _sampler_1_ };
Texture2D FogOfWarAlpha_Texture;
static PdxTextureSampler2D FogOfWarAlpha = { FogOfWarAlpha_Texture, _sampler_2_ };
Texture2D FogOfWarNoise_Texture;
static PdxTextureSampler2D FogOfWarNoise = { FogOfWarNoise_Texture, _sampler_2_ };
Texture2D FogOfWarNormal_Texture;
static PdxTextureSampler2D FogOfWarNormal = { FogOfWarNormal_Texture, _sampler_2_ };
Texture2D FlatmapNoiseMap_Texture;
static PdxTextureSampler2D FlatmapNoiseMap = { FlatmapNoiseMap_Texture, _sampler_2_ };
Texture2D LandMaskMap_Texture;
static PdxTextureSampler2D LandMaskMap = { LandMaskMap_Texture, _sampler_2_ };
Texture2D HighlightGradient_Texture;
static PdxTextureSampler2D HighlightGradient = { HighlightGradient_Texture, _sampler_2_ };
Texture2D ImpassableTerrainTexture_Texture;
static PdxTextureSampler2D ImpassableTerrainTexture = { ImpassableTerrainTexture_Texture, _sampler_2_ };
Texture2DArray MapPaintingTextures_Texture;
static PdxTextureSampler2DArray MapPaintingTextures = { MapPaintingTextures_Texture, _sampler_2_ };
Texture2D FlatmapOverlayTexture_Texture;
static PdxTextureSampler2D FlatmapOverlayTexture = { FlatmapOverlayTexture_Texture, _sampler_3_ };
Texture2D CountryColors_Texture;
static PdxTextureSampler2D CountryColors = { CountryColors_Texture, _sampler_0_ };
Texture2D CoaAtlas_Texture;
static PdxTextureSampler2D CoaAtlas = { CoaAtlas_Texture, _sampler_2_ };
Texture2D DiffuseMap_Texture;
static PdxTextureSampler2D DiffuseMap = { DiffuseMap_Texture, _sampler_2_ };
Texture2D PropertiesMap_Texture;
static PdxTextureSampler2D PropertiesMap = { PropertiesMap_Texture, _sampler_2_ };
Texture2D NormalMap_Texture;
static PdxTextureSampler2D NormalMap = { NormalMap_Texture, _sampler_2_ };
TextureCube EnvironmentMap_Texture;
static PdxTextureSamplerCube EnvironmentMap = { EnvironmentMap_Texture, _sampler_1_ };
Texture2D TintMap_Texture;
static PdxTextureSampler2D TintMap = { TintMap_Texture, _sampler_2_ };
Texture2D ShadowMap_Texture;
static PdxTextureSampler2DCmp ShadowMap = { ShadowMap_Texture, _sampler_5_ };


// === RW Textures === 



// === Buffer Textures === 

PdxBufferFloat4 MapObjectBuffer;
PdxBufferInt ProvinceCountryIdBuffer;
PdxBufferFloat4 CountryCoaUvBuffer;


// === RW Buffer Textures === 



// === Shader Code === 

float CalcViewSpaceDepth( float Depth )
{
	Depth = 2.0 * Depth - 1.0;
	float ZLinear = 2.0 * ZNear * ZFar / (ZFar + ZNear - Depth * (ZFar - ZNear));
	return ZLinear;
}

float3 ViewSpacePosFromDepth( float Depth, float2 UV )
{
	float x = UV.x * 2.0 - 1.0;
	float y = (1.0 - UV.y) * 2.0 - 1.0;
	
	float4 ProjectedPos = float4( x, y, Depth, 1.0 );
	
	float4 ViewSpacePos = mul( InvProjectionMatrix, ProjectedPos );
	
	return ViewSpacePos.xyz / ViewSpacePos.w;
}

float3 WorldSpacePositionFromDepth( float Depth, float2 UV )
{
	float3 WorldSpacePos = mul( InvViewMatrix, float4( ViewSpacePosFromDepth( Depth, UV ), 1.0 ) ).xyz;		
	return WorldSpacePos;  
}
float CalcRandom( float Seed )
{
	float DotProduct = float( Seed ) * 12.9898;
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcRandom( float2 Seed )
{
	float DotProduct = dot( Seed, float2( 12.9898, 78.233 ) );
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcRandom( float3 Seed )
{
	float DotProduct = dot( Seed, float3( 12.9898,78.233,144.7272 ) );
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcNoise( float2 Pos ) 
{
	int2 i = int2( floor( Pos ) );
	float2 f = frac( Pos );

	float a = CalcRandom( i );
	float b = CalcRandom( i + int2( 1, 0 ) );
	float c = CalcRandom( i + int2( 0, 1 ) );
	float d = CalcRandom( i + int2( 1, 1 ) );
	
	float2 u = f*f*(3.0-2.0*f);
	return lerp(a, b, u.x) + 
			(c - a)* u.y * (1.0 - u.x) + 
			(d - b) * u.x * u.y;
}
static const int PDXMESH_MAX_INFLUENCE = 4;
static const int PDXMESH_WORLD_MATRIX_OFFSET = 0;
static const int PDXMESH_CONSTANTS_OFFSET = 4;
static const int PDXMESH_USER_DATA_OFFSET = 5;

float4x4 PdxMeshGetWorldMatrix( uint nIndex )
{
	return Create4x4( 
		Data[nIndex + PDXMESH_WORLD_MATRIX_OFFSET + 0], 
		Data[nIndex + PDXMESH_WORLD_MATRIX_OFFSET + 1], 
		Data[nIndex + PDXMESH_WORLD_MATRIX_OFFSET + 2], 
		Data[nIndex + PDXMESH_WORLD_MATRIX_OFFSET + 3] );
}

// OffsetJointIndex -> JointsInstanceIndex + JointIndex
float4x4 PdxMeshGetJointVertexMatrix( uint OffsetJointIndex )
{
	uint BeginIndex = OffsetJointIndex * 3;

	float4 XAxis = float4( JointVertexMatrices[ BeginIndex ].x, JointVertexMatrices[ BeginIndex ].y, JointVertexMatrices[ BeginIndex ].z, 0.0f );
	float4 YAxis = float4( JointVertexMatrices[ BeginIndex ].w, JointVertexMatrices[ BeginIndex + 1 ].x, JointVertexMatrices[ BeginIndex + 1 ].y, 0.0f );
	float4 ZAxis = float4( JointVertexMatrices[ BeginIndex + 1 ].z, JointVertexMatrices[ BeginIndex + 1 ].w, JointVertexMatrices[ BeginIndex + 2 ].x, 0.0f );
	float4 Translation = float4( JointVertexMatrices[ BeginIndex + 2 ].y, JointVertexMatrices[ BeginIndex + 2 ].z, JointVertexMatrices[ BeginIndex + 2 ].w, 1.0f );

	return Create4x4( XAxis, YAxis, ZAxis, Translation );
}

float PdxMeshGetOpacity( uint ObjectInstanceIndex )
{
	return Data[ ObjectInstanceIndex + PDXMESH_CONSTANTS_OFFSET ].x;
} 

uint GetActiveBlendShapes( uint ObjectInstanceIndex )
{
	return uint( Data[ ObjectInstanceIndex + PDXMESH_CONSTANTS_OFFSET ].y );
}

uint GetActiveDecals( uint ObjectInstanceIndex ) 
{
	return uint( Data[ ObjectInstanceIndex + PDXMESH_CONSTANTS_OFFSET ].z );
}

float PdxMeshGetMeshDummyValue( uint ObjectInstanceIndex ) 
{
	return Data[ ObjectInstanceIndex + PDXMESH_CONSTANTS_OFFSET ].w;
}
float2 GetLookupCoordinates( float2 WorldSpacePosXZ )
{
	return clamp( WorldSpacePosXZ * WorldSpaceToLookup, vec2( 0.0 ), vec2( 0.999999 ) );
}

float4 SampleLookupTexture( float2 LookupCoordinates )
{
	float4 IndirectionSample = PdxTex2DLod0( HeightLookupTexture, ( floor( LookupCoordinates * IndirectionSize ) + vec2( 0.5 ) ) / IndirectionSize ) * 255.0;
	return IndirectionSample;
}

float2 GetTileUV( float2 LookupCoordinates, float4 IndirectionSample, out float CurrentTileScale )
{
	float CurrentTileSize = (BaseTileSize - 1.0) / IndirectionSample.z + 1;
	float CurrentTileOffset = 0.5 / CurrentTileSize;
	CurrentTileScale = (CurrentTileSize - 1.0) / CurrentTileSize;

	float2 WithinTileZeroToOne = frac( LookupCoordinates * IndirectionSize );
	float2 WithinTileUV = vec2( CurrentTileOffset ) + WithinTileZeroToOne * CurrentTileScale;
	float2 TileUV = IndirectionSample.rg + WithinTileUV;

	return TileUV;
}

float2 GetHeightMapCoordinates( float2 WorldSpacePosXZ )
{
	float2 LookupCoordinates = GetLookupCoordinates( WorldSpacePosXZ );
	float4 IndirectionSample = SampleLookupTexture( LookupCoordinates );

	float4 CurrentTileToHeightMapScaleAndOffset = TileToHeightMapScaleAndOffset[int(IndirectionSample.w)];
	float CurrentTileScale;
	float2 TileUV = GetTileUV( LookupCoordinates, IndirectionSample, CurrentTileScale );

	float2 HeightMapCoord = TileUV * CurrentTileToHeightMapScaleAndOffset.xy + CurrentTileToHeightMapScaleAndOffset.zw; // 0 -> 1 in packed heightmap
	return HeightMapCoord;
}

float GetHeight01( float2 WorldSpacePosXZ )
{
	float2 HeightMapCoord = GetHeightMapCoordinates( WorldSpacePosXZ );
	return PdxTex2DLod0( PackedHeightTexture, HeightMapCoord ).r;
}

float GetHeight( float2 WorldSpacePosXZ )
{
	return GetHeight01( WorldSpacePosXZ ) * HeightScale;
}

float GetHeightMultisample01( float2 WorldSpacePosXZ, float FilterSize )
{
	float2 LookupCoordinates = GetLookupCoordinates( WorldSpacePosXZ );
	float2 FilterSizeInWorldSpace = FilterSize * OriginalHeightmapToWorldSpace;
	float2 FilterSizeInLookup = FilterSizeInWorldSpace * WorldSpaceToLookup * IndirectionSize;

	float2 FracCoordinates = frac( LookupCoordinates * IndirectionSize );
	float2 MinFracCoordinatesScaled = min( FracCoordinates, vec2(1.0) - FracCoordinates );
	bool2 InBorder = lessThan( MinFracCoordinatesScaled, FilterSizeInLookup );

	float Height = 0.0;
	if ( any( InBorder ) )
	{
		Height = GetHeight01( WorldSpacePosXZ );
		Height += GetHeight01( WorldSpacePosXZ + float2( -FilterSizeInWorldSpace.x, 0 ) );
		Height += GetHeight01( WorldSpacePosXZ + float2( 0, -FilterSizeInWorldSpace.y ) );
		Height += GetHeight01( WorldSpacePosXZ + float2( FilterSizeInWorldSpace.x, 0 ) );
		Height += GetHeight01( WorldSpacePosXZ + float2( 0, FilterSizeInWorldSpace.y ) );
		Height += GetHeight01( WorldSpacePosXZ + float2( -FilterSizeInWorldSpace.x, -FilterSizeInWorldSpace.y ) );
		Height += GetHeight01( WorldSpacePosXZ + float2(  FilterSizeInWorldSpace.x, -FilterSizeInWorldSpace.y ) );
		Height += GetHeight01( WorldSpacePosXZ + float2(  FilterSizeInWorldSpace.x,  FilterSizeInWorldSpace.y ) );
		Height += GetHeight01( WorldSpacePosXZ + float2( -FilterSizeInWorldSpace.x,  FilterSizeInWorldSpace.y ) );
	}
	else
	{
		float4 IndirectionSample = SampleLookupTexture( LookupCoordinates );

		float4 CurrentTileToHeightMapScaleAndOffset = TileToHeightMapScaleAndOffset[int(IndirectionSample.w)];
		float CurrentTileScale;
		float2 TileUV = GetTileUV( LookupCoordinates, IndirectionSample, CurrentTileScale );

		float2 HeightMapCoord = TileUV * CurrentTileToHeightMapScaleAndOffset.xy + CurrentTileToHeightMapScaleAndOffset.zw; // 0 -> 1 in packed heightmap
		float2 FilterSizeInTile = FilterSizeInLookup * CurrentTileToHeightMapScaleAndOffset.xy * CurrentTileScale;

		Height = PdxTex2DLod0( PackedHeightTexture, HeightMapCoord ).r;
		Height += PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2( -FilterSizeInTile.x, 0 ) ).r;
		Height += PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2( 0, -FilterSizeInTile.y ) ).r;
		Height += PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2( FilterSizeInTile.x, 0 ) ).r;
		Height += PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2( 0, FilterSizeInTile.y ) ).r;
		Height += PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2( -FilterSizeInTile.x, -FilterSizeInTile.y ) ).r;
		Height += PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2(  FilterSizeInTile.x, -FilterSizeInTile.y ) ).r;
		Height += PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2(  FilterSizeInTile.x,  FilterSizeInTile.y ) ).r;
		Height += PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2( -FilterSizeInTile.x,  FilterSizeInTile.y ) ).r;
	}

	Height /= 9.0;
	return Height;
}

float GetHeightMultisample( float2 WorldSpacePosXZ, float FilterSize )
{
	return GetHeightMultisample01( WorldSpacePosXZ, FilterSize ) * HeightScale;
}

static const float c_x0 = -1.0;
static const float c_x1 =  0.0;
static const float c_x2 =  1.0;
static const float c_x3 =  2.0;

float CubicLagrange(float A, float B, float C, float D, float t)
{
	return
		A *
		(
			(t - c_x1) / (c_x0 - c_x1) *
			(t - c_x2) / (c_x0 - c_x2) *
			(t - c_x3) / (c_x0 - c_x3)
		) +
		B *
		(
			(t - c_x0) / (c_x1 - c_x0) *
			(t - c_x2) / (c_x1 - c_x2) *
			(t - c_x3) / (c_x1 - c_x3)
		) +
		C *
		(
			(t - c_x0) / (c_x2 - c_x0) *
			(t - c_x1) / (c_x2 - c_x1) *
			(t - c_x3) / (c_x2 - c_x3)
		) +
		D *
		(
			(t - c_x0) / (c_x3 - c_x0) *
			(t - c_x1) / (c_x3 - c_x1) *
			(t - c_x2) / (c_x3 - c_x2)
		);
}

float BicubicLagrangeBilinearGetHeight01( float2 WorldSpacePosXZ )
{
	float2 Pixel = WorldSpacePosXZ - 0.5;

	float2 FracCoord = frac(Pixel);
	Pixel = floor(Pixel) + 0.5;

	float C00 = GetHeight01( float2( Pixel.x - 1, Pixel.y - 1 ) );
	float C10 = GetHeight01( float2( Pixel.x - 0, Pixel.y - 1 ) );
	float C20 = GetHeight01( float2( Pixel.x + 1, Pixel.y - 1 ) );
	float C30 = GetHeight01( float2( Pixel.x + 2, Pixel.y - 1 ) );

	float C01 = GetHeight01( float2( Pixel.x - 1, Pixel.y - 0 ) );
	float C11 = GetHeight01( float2( Pixel.x - 0, Pixel.y - 0 ) );
	float C21 = GetHeight01( float2( Pixel.x + 1, Pixel.y - 0 ) );
	float C31 = GetHeight01( float2( Pixel.x + 2, Pixel.y - 0 ) );

	float C02 = GetHeight01( float2( Pixel.x - 1, Pixel.y + 1 ) );
	float C12 = GetHeight01( float2( Pixel.x - 0, Pixel.y + 1 ) );
	float C22 = GetHeight01( float2( Pixel.x + 1, Pixel.y + 1 ) );
	float C32 = GetHeight01( float2( Pixel.x + 2, Pixel.y + 1 ) );

	float C03 = GetHeight01( float2( Pixel.x - 1, Pixel.y + 2 ) );
	float C13 = GetHeight01( float2( Pixel.x - 0, Pixel.y + 2 ) );
	float C23 = GetHeight01( float2( Pixel.x + 1, Pixel.y + 2 ) );
	float C33 = GetHeight01( float2( Pixel.x + 2, Pixel.y + 2 ) );

	float CP0X = CubicLagrange(C00, C10, C20, C30, FracCoord.x);
	float CP1X = CubicLagrange(C01, C11, C21, C31, FracCoord.x);
	float CP2X = CubicLagrange(C02, C12, C22, C32, FracCoord.x);
	float CP3X = CubicLagrange(C03, C13, C23, C33, FracCoord.x);

	return CubicLagrange(CP0X, CP1X, CP2X, CP3X, FracCoord.y);
}

// /SAMPLING API
// Gamma correction utility
float ToGamma(float aLinear)
{
	return pow(aLinear, 1.0/2.2);
}
float3 ToGamma(float3 aLinear)
{
	return pow(aLinear, vec3(1.0/2.2));
}
float ToLinear(float aGamma)
{
	return pow(aGamma, 2.2);
}
float3 ToLinear(float3 aGamma)
{
	return pow(aGamma, vec3(2.2));
}
float4 ToLinear(float4 aGamma)
{
	return float4(pow(aGamma.rgb, vec3(2.2)), aGamma.a);
}

// Color value conversions
float3 RGBtoHSV( float3 RGB )
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = RGB.g < RGB.b ? float4(RGB.bg, K.wz) : float4(RGB.gb, K.xy);
	float4 q = RGB.r < p.x ? float4(p.xyw, RGB.r) : float4(RGB.r, p.yzx);

	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3( abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x );
}
float3 HSVtoRGB( float3 HSV )
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs( frac(HSV.xxx + K.xyz) * 6.0 - K.www );
	return HSV.z * lerp( K.xxx, clamp(p - K.xxx, 0.0, 1.0), HSV.y );
}
float3 HSVtoRGB( float H, float S, float V )
{
	return HSVtoRGB( float3( H, S, V ) );
}
float4 RGBtoHSV( float4 RGBa )
{
	return float4( RGBtoHSV( RGBa.rgb ), RGBa.a );
}
float4 HSVtoRGB( float4 HSVa )
{
	return float4( HSVtoRGB( HSVa.xyz ), HSVa.a );
}
float4 HSVtoRGB( float H, float S, float V, float a )
{
	return HSVtoRGB( float4( H, S, V, a ) );
}

// Below are multiple blend mode utilities (See: https://en.wikipedia.org/wiki/Blend_modes)
// Most of these uses a typical implementation unless stated otherwise

// Multiply blend mode
float3 Multiply( float3 Base, float3 Blend, float Opacity )
{
	return Base * Blend * Opacity + Base * ( 1.0 - Opacity );
}

// Screen blend mode
float3 Screen( float3 Base, float3 Blend )
{
	return 1.0 - ( ( 1.0 - Base ) * ( 1.0 - Blend ) );
}

// Overlay blend mode
float Overlay( float Base, float Blend )
{
	return (Base < 0.5) ? (2.0 * Base * Blend) : (1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend));
}
float3 Overlay( float3 Base, float3 Blend )
{
	return float3( Overlay(Base.r, Blend.r), Overlay(Base.g, Blend.g), Overlay(Base.b, Blend.b) );
}
float Overlay( float Base, float Blend, float Opacity )
{
	return Overlay( Base, Blend ) * Opacity + Base * (1.0 - Opacity );
}
float3 Overlay( float3 Base, float3 Blend, float Opacity )
{
	return Overlay( Base, Blend ) * Opacity + Base * (1.0 - Opacity );
}
float3 GetOverlay( float3 Color, float3 OverlayColor, float OverlayPercent )
{
	// Flip OverlayColor/BaseColor since that was how it was before
	return lerp( Color, Overlay( OverlayColor, Color ), OverlayPercent );
}
float GetOverlay( float Color, float OverlayColor, float OverlayPercent )
{
	// Flip OverlayColor/BaseColor since that was how it was before
	return lerp( Color, Overlay( OverlayColor, Color ), OverlayPercent );
}

// Color dodge blend mode (Dodge and burn)
float ColorDodge( float Base, float Blend )
{
	return (Blend == 1.0) ? Blend : min( Base / (1.0 - Blend), 1.0 );
}
float3 ColorDodge( float3 Base, float3 Blend )
{
	return float3( ColorDodge(Base.r, Blend.r), ColorDodge(Base.g, Blend.g), ColorDodge(Base.b, Blend.b) );
}
float3 ColorDodge( float3 Base, float3 Blend, float Opacity )
{
	return ColorDodge( Base, Blend ) * Opacity + Base * ( 1.0 - Opacity );
}

// Pegtop's SoftLight blend formula
float SoftLight( float Base, float Blend )
{
	return ( 1 - 2 * Blend ) * Base * Base + 2 * Base * Blend;
}
float3 SoftLight( float3 Base, float3 Blend )
{
	return float3( SoftLight( Base.r, Blend.r ), SoftLight( Base.g, Blend.g ), SoftLight( Base.b, Blend.b ) );
}
float SoftLight( float Base, float Blend, float Opacity )
{
	return lerp( Base, SoftLight( Base, Blend ), Opacity );
}
float3 SoftLight( float3 Base, float3 Blend, float Opacity )
{
	return lerp( Base, SoftLight( Base, Blend ), Opacity );
}

// Hardlight blend mode
float HardLight(float Base, float Blend)
{
	return Blend >= 0.5 ? 1.0 - 2 * ( 1.0 - Blend ) * ( 1.0 - Base ) : 2.0 * Base * Blend;
}
float3 HardLight( float3 Base, float3 Blend )
{
	return float3( HardLight( Base.r, Blend.r ), HardLight( Base.g, Blend.g ), HardLight( Base.b, Blend.b ) );
}
float HardLight( float Base, float Blend, float Opacity )
{
	return lerp( Base, HardLight( Base, Blend ), Opacity );
}
float3 HardLight( float3 Base, float3 Blend, float Opacity )
{
	return lerp( Base, HardLight( Base, Blend ), Opacity );
}

// Simple arithmetic blend modes (See: https://en.wikipedia.org/wiki/Blend_modes#Simple_arithmetic_blend_modes)
// Lighten only blend mode
float3 Add( float3 Base, float3 Blend, float Opacity )
{
	return ( Base + Blend ) * Opacity + Base * ( 1.0 - Opacity );
}
float Lighten( float Base, float Blend )
{
	return max( Base, Blend );
}
float3 Lighten( float3 Base, float3 Blend )
{
	return float3( Lighten(Base.r, Blend.r), Lighten(Base.g, Blend.g), Lighten(Base.b, Blend.b) );
}
float3 Lighten( float3 Base, float3 Blend, float Opacity )
{
	return Lighten( Base, Blend ) * Opacity + Base * ( 1.0 - Opacity );
}

// Darken only blend mode
float Darken( float Base, float Blend )
{
	return min( Base, Blend );
}
float3 Darken( float3 Base, float3 Blend )
{
	return float3( Darken(Base.r, Blend.r), Darken(Base.g, Blend.g), Darken(Base.b, Blend.b) );
}
float3 Darken( float3 Base, float3 Blend, float Opacity )
{
	return Darken( Base, Blend ) * Opacity + Base * ( 1.0 - Opacity );
}

float3 Levels( float3 vInColor, float3 vMinInput, float3 vMaxInput )
{
	float3 vRet = saturate( vInColor - vMinInput );
	vRet /= vMaxInput - vMinInput;
	return saturate( vRet );
}
float Levels( float vInValue, float vMinValue, float vMaxValue )
{
	return saturate( ( vInValue - vMinValue ) / ( vMaxValue - vMinValue ) );
}

// Intuitive way to dynamically grow and shrink masks, similar to Histogram Scan in Substance Designer.
// vInValue is typically a mask texture, vPosition is the value to be remapped to 0.5, vRange is the softness of that remap.
float LevelsScan( float vInValue, float vPosition, float vRange )
{
	return Levels( vInValue, vPosition - ( vRange / 2 ), vPosition + ( vRange / 2 ) );
}

float3 UnpackNormal( float4 NormalMapSample )
{
	float3 vNormalSample = NormalMapSample.rgb - 0.5;
	vNormalSample.g = -vNormalSample.g;
	return vNormalSample;
}

float3 UnpackNormal( in PdxTextureSampler2D NormalTex, float2 uv )
{
	return UnpackNormal( PdxTex2D( NormalTex, uv ) );
}

float3 UnpackRRxGNormal( float4 NormalMapSample )
{
	float x = NormalMapSample.g * 2.0 - 1.0;
	float y = NormalMapSample.a * 2.0 - 1.0;
	y = -y;
	float z = sqrt( saturate( 1.0 - x * x - y * y ) );
	return float3( x, y, z );
}

float3 UnpackRRxGNormal( in PdxTextureSampler2D NormalTex, float2 uv )
{
	return UnpackRRxGNormal( PdxTex2D( NormalTex, uv ) );
}

float3 ReorientNormal( float3 BaseNormal, float3 DetailNormal )
{
	float3 t = BaseNormal + float3( 0.0, 0.0, 1.0 );
	float3 u = DetailNormal * float3( -1.0, -1.0, 1.0 );
	float3 Normal = normalize( t * dot( t, u ) - u * t.z );
	return Normal;
}

float Fresnel( float NdotL, float FresnelBias, float FresnelPow )
{
	return saturate( FresnelBias + (1.0 - FresnelBias) * pow( 1.0 - NdotL, FresnelPow ) );
}

#define REMAP_IMPL NewMin + ( NewMax - NewMin ) * ( (Value - OldMin) / (OldMax - OldMin) )
float Remap( float Value, float OldMin, float OldMax, float NewMin, float NewMax ) { return REMAP_IMPL; }
float2 Remap( float2 Value, float2 OldMin, float2 OldMax, float2 NewMin, float2 NewMax ) { return REMAP_IMPL; }
float3 Remap( float3 Value, float3 OldMin, float3 OldMax, float3 NewMin, float3 NewMax ) { return REMAP_IMPL; }
#undef REMAP_IMPL
#define REMAP_IMPL NewMin + ( NewMax - NewMin ) * saturate( (Value - OldMin) / (OldMax - OldMin) )
float RemapClamped( float Value, float OldMin, float OldMax, float NewMin, float NewMax ) { return REMAP_IMPL; }
float2 RemapClamped( float2 Value, float2 OldMin, float2 OldMax, float2 NewMin, float2 NewMax ) { return REMAP_IMPL; }
float3 RemapClamped( float3 Value, float3 OldMin, float3 OldMax, float3 NewMin, float3 NewMax ) { return REMAP_IMPL; }
#undef REMAP_IMPL
// These macros can be used as drop in replacements for their counterparts without the "Upscale" postfix.
// They will take care of using the correct lod bias when sampling the textures to account for rendering happening in lower resolution. (See https://gsg.pages.build.paradox-interactive.com/tech/cw/develop/clausewitz/pdx_gfx/upscaling/ for more information)
// Note that by default when using upscaling it will add an extra -1 lod bias, this is to try and boost the quality a bit, it works because the temporal anti aliasing component can take care of some of the aliasing artifacts that is introduced by the lod bias.
// This might not always be preferrable, in those cases the "UpscaleBias" postfix versions can be used to undo the extra lod bias, the provided bias should most likely be in the range (0.0, 1.0), for example doing PdxTex2DUpscaleBias( Tex, Uv, 1.0 ) will net you the same texture quality you would get rendering in native resolution.
// There is also a "UpscaleNative" that is basically the same as UpscaleBias with bias 1.0, but slightly more optimized.

#ifdef PDX_UPSCALING_ENABLED
	float2 ApplyUpscaleLodBiasMultiplier( float2 Derivative ) { return Derivative * _UpscaleLodBiasMultiplier; }
	float2 ApplyUpscaleNativeLodBiasMultiplier( float2 Derivative ) { return Derivative * _UpscaleLodBiasMultiplierNative; }
	
	#define PdxTex2DUpscale( TextureSampler, Uv ) PdxTex2DBias( (TextureSampler), (Uv), _UpscaleLodBias )
	#define PdxTex2DUpscaleNative( TextureSampler, Uv ) PdxTex2DBias( (TextureSampler), (Uv), _UpscaleLodBiasNative )
	#define PdxTex2DUpscaleBias( TextureSampler, Uv, Bias ) PdxTex2DBias( (TextureSampler), (Uv), (_UpscaleLodBias + (Bias) * _UpscaleLodBiasEnabled) )
	
	#define PdxTex2DGradUpscale( TextureSampler, Uv, Ddx, Ddy ) PdxTex2DGrad( (TextureSampler), (Uv), ApplyUpscaleLodBiasMultiplier( Ddx ), ApplyUpscaleLodBiasMultiplier( Ddy ) )
	#define PdxTex2DGradUpscaleNative( TextureSampler, Uv, Ddx, Ddy ) PdxTex2DGrad( (TextureSampler), (Uv), ApplyUpscaleNativeLodBiasMultiplier( Ddx ), ApplyUpscaleNativeLodBiasMultiplier( Ddy ) )
	#define PdxTex2DGradUpscaleBias( TextureSampler, Uv, Ddx, Ddy, Bias ) PdxTex2DGrad( (TextureSampler), (Uv), ApplyUpscaleLodBiasMultiplier( Ddx ) * exp2( (Bias) * _UpscaleLodBiasEnabled ), ApplyUpscaleLodBiasMultiplier( Ddy ) * exp2( (Bias) * _UpscaleLodBiasEnabled ) )
#else
	float2 ApplyUpscaleLodBiasMultiplier( float2 Derivative ) { return Derivative; }
	float2 ApplyUpscaleNativeLodBiasMultiplier( float2 Derivative ) { return Derivative; }
	
	#define PdxTex2DUpscale( TextureSampler, Uv ) PdxTex2D( (TextureSampler), (Uv) )
	#define PdxTex2DUpscaleNative( TextureSampler, Uv ) PdxTex2D( (TextureSampler), (Uv) )
	// We intentionally discard the Bias argument here since that is used to tweak the upscale added lodbias
	#define PdxTex2DUpscaleBias( TextureSampler, Uv, Bias ) PdxTex2D( (TextureSampler), (Uv) )
	
	#define PdxTex2DGradUpscale( TextureSampler, Uv, Ddx, Ddy ) PdxTex2DGrad( (TextureSampler), (Uv), Ddx, Ddy )
	#define PdxTex2DGradUpscaleNative( TextureSampler, Uv, Ddx, Ddy ) PdxTex2DGrad( (TextureSampler), (Uv), Ddx, Ddy )
	// We intentionally discard the Bias argument here since that is used to tweak the upscale added lodbias
	#define PdxTex2DGradUpscaleBias( TextureSampler, Uv, Ddx, Ddy, Bias ) PdxTex2DGrad( (TextureSampler), (Uv), Ddx, Ddy )
#endif
float GetLerpedHeight( float2 WorldSpacePosXZ, float2 LodDirection )
{
	float h1 = GetHeight( WorldSpacePosXZ - LodDirection );
	float h2 = GetHeight( WorldSpacePosXZ + LodDirection );

	//h1 = GetHeightMultisample( WorldSpacePosXZ - LodDirection, 0.25 );
	//h2 = GetHeightMultisample( WorldSpacePosXZ + LodDirection, 0.25 );

	return (h1 + h2) * 0.5;
}

float3 CalculateNormal( float2 WorldSpacePosXZ )
{
#ifdef TERRAIN_WRAP_X
	float TerrainSizeX = 1.0 / _WorldSpaceToTerrain0To1.x;

	float HeightMinX = GetHeight01( float2( mod( WorldSpacePosXZ.x + TerrainSizeX - _NormalStepSize.x, TerrainSizeX ), WorldSpacePosXZ.y ) );
	float HeightMaxX = GetHeight01( float2( mod( WorldSpacePosXZ.x + TerrainSizeX + _NormalStepSize.x, TerrainSizeX ), WorldSpacePosXZ.y ) );
#else
	float HeightMinX = GetHeight01( WorldSpacePosXZ + float2(-_NormalStepSize.x, 0) );
	float HeightMaxX = GetHeight01( WorldSpacePosXZ + float2(_NormalStepSize.x, 0) );
#endif
	float HeightMinZ = GetHeight01( WorldSpacePosXZ + float2(0, -_NormalStepSize.y) );
	float HeightMaxZ = GetHeight01( WorldSpacePosXZ + float2(0, _NormalStepSize.y) );

	//float2 LookupCoordinates = GetLookupCoordinates( WorldSpacePosXZ );
	//float2 NormalStepSizeInLookup = NormalStepSize * WorldSpaceToLookup * IndirectionSize;
	//
	//float2 FracCoordinates = frac( LookupCoordinates * IndirectionSize );
	//float2 MinFracCoordinatesScaled = min( FracCoordinates, vec2(1.0) - FracCoordinates );
	//bool2 InBorder = lessThan( MinFracCoordinatesScaled, NormalStepSizeInLookup );
    //
	//float HeightMinX = 0.0;
	//float HeightMaxX = 0.0;
	//float HeightMinZ = 0.0;
	//float HeightMaxZ = 0.0;
	//if ( any( InBorder ) )
	//{
	//	HeightMinX = GetHeight01( WorldSpacePosXZ + float2(-NormalStepSize.x, 0) );
	//	HeightMaxX = GetHeight01( WorldSpacePosXZ + float2(NormalStepSize.x, 0) );
	//	HeightMinZ = GetHeight01( WorldSpacePosXZ + float2(0, -NormalStepSize.y) );
	//	HeightMaxZ = GetHeight01( WorldSpacePosXZ + float2(0, NormalStepSize.y) );
	//}
	//else
	//{
	//	float4 IndirectionSample = SampleLookupTexture( LookupCoordinates );
	//
	//	float4 CurrentTileToHeightMapScaleAndOffset = TileToHeightMapScaleAndOffset[int(IndirectionSample.w)];
	//	float CurrentTileScale;
	//	float2 TileUV = GetTileUV( LookupCoordinates, IndirectionSample, CurrentTileScale );
	//
	//	float2 HeightMapCoord = TileUV * CurrentTileToHeightMapScaleAndOffset.xy + CurrentTileToHeightMapScaleAndOffset.zw; // 0 -> 1 in packed heightmap
	//	float2 NormalStepSizeInTile = NormalStepSizeInLookup * CurrentTileToHeightMapScaleAndOffset.xy * CurrentTileScale;
	//
	//	HeightMinX = PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2(-NormalStepSizeInTile.x, 0) );
	//	HeightMaxX = PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2(NormalStepSizeInTile.x, 0) );
	//	HeightMinZ = PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2(0, -NormalStepSizeInTile.y) );
	//	HeightMaxZ = PdxTex2DLod0( PackedHeightTexture, HeightMapCoord + float2(0, NormalStepSizeInTile.y) );
	//}

	float3 Normal = float3( HeightMinX - HeightMaxX, 2.0, HeightMinZ - HeightMaxZ ) * _NormalScale;
	return normalize(Normal);
}

// Rotates normals to the heightmap terrain normal
float3 SimpleRotateNormalToTerrain( float3 Normal, float2 WorldSpacePosXZ )
{
	float3 TerrainNormal = CalculateNormal( WorldSpacePosXZ );
	float3 Up = float3( 0.0, 1.0, 0.0 );

	float3 Axis = cross( Up, TerrainNormal );
	float Angle = acos( dot( Up, TerrainNormal ) ) * abs( Normal.y );

	return lerp( dot( Axis, Normal ) * Axis, Normal, cos( Angle ) ) + cross( Axis, Normal ) * sin( Angle );
}

// For debugging
float GetTextureBorder( float2 UV, float2 TextureSize, float BorderSize )
{
	float2 FracScaledUV = frac( UV * TextureSize );
	if ( FracScaledUV.x < BorderSize || FracScaledUV.x > (1.0 - BorderSize) || FracScaledUV.y < BorderSize || FracScaledUV.y > (1.0 - BorderSize) )
	{
		return 1.0;
	}
	else
	{
		return 0.0;
	}
}

float GetModValue( float value, float vMod )
{
	return mod(round(value), vMod) * (1.0 / (vMod - 1.0));
}

float GetModValueFloor( float value, float vMod )
{
	return mod(floor(value), vMod) * (1.0 / (vMod - 1.0));
}

float GetMod2Value( float value )
{
	if ( abs( mod( round(value), 2.0 ) - 1.0 ) < 0.01 )
	{
		return 1.0;
	}
	else
	{
		return 0.0;
	}
}
// Sine wave, remapped to 0-1
float Sin01( float Angle )
{
	return ( sin( Angle ) * 0.5 ) + 0.5;
}

// Cubic bezier 	// Reference: https://www.tinaja.com/text/bezmath.html
float SlopeFromT (float T, float A, float B, float C)
{
	return 1.0 / ( 3.0 * A * T * T + 2.0 * B * T + C ); 
}
float XFromT ( float T, float A, float B, float C, float D )
{
	return A * ( T * T * T ) + B * ( T * T ) + C * T + D;
}
float YFromT ( float T, float E, float F, float G, float H )
{
	return E * ( T * T * T ) + F * ( T * T ) + G * T + H;
}
float CubicBezier( float Value, float2 Point1, float2 Point2 )
{
	float y0 = 0.0;
	float x0 = 0.0;
	float y1 = Point1.y;
	float x1 = Point1.x;
	float y2 = Point2.y;
	float x2 = Point2.x;
	float y3 = 1.0;
	float x3 = 1.0;

	float A = x3 - 3.0 * x2 + 3.0 * x1 - x0;
	float B = 3.0 * x2 - 6.0 * x1 + 3.0 * x0;
	float C = 3.0 * x1 - 3.0 * x0;
	float D = x0;

	float E = y3 - 3.0 * y2 + 3.0 * y1 - y0;
	float F = 3.0 * y2 - 6.0 * y1 + 3.0 * y0;
	float G = 3.0 * y1 - 3.0 * y0;
	float H = y0;

	float CurrentT = Value;
	for (int i = 0; i < 5; i++ )
	{
		float CurrentX = XFromT( CurrentT, A, B, C , D ); 
		float CurrentSlope = SlopeFromT ( CurrentT, A, B, C );
		CurrentT -= ( CurrentX - Value ) * ( CurrentSlope );
		CurrentT = clamp( CurrentT, 0.0, 1.0 ); 
	} 

	float y = YFromT ( CurrentT, E, F, G, H );
	return y;
}
float2 RotateDisc( float2 Disc, float2 Rotate )
{
	return float2( Disc.x * Rotate.x - Disc.y * Rotate.y, Disc.x * Rotate.y + Disc.y * Rotate.x );
}

float CalculateShadow( float4 ShadowProj, PdxTextureSampler2DCmp ShadowMap )
{
	ShadowProj.xyz = ShadowProj.xyz / ShadowProj.w;
	
	float RandomAngle = CalcRandom( round( ShadowScreenSpaceScale * ShadowProj.xy ) ) * 3.14159 * 2.0;
	float2 Rotate = float2( cos( RandomAngle ), sin( RandomAngle ) );

	// Sample each of them checking whether the pixel under test is shadowed or not
	float ShadowTerm = 0.0;
	for( int i = 0; i < NumSamples; i++ )
	{
		float4 Samples = DiscSamples[i] * KernelScale;
		ShadowTerm += PdxTex2DCmpLod0( ShadowMap, ShadowProj.xy + RotateDisc( Samples.xy, Rotate ), ShadowProj.z - Bias );
		ShadowTerm += PdxTex2DCmpLod0( ShadowMap, ShadowProj.xy + RotateDisc( Samples.zw, Rotate ), ShadowProj.z - Bias );
	}
	
	// Get the average
	ShadowTerm *= 0.5; // We have 2 samples per "sample"
	ShadowTerm = ShadowTerm / float(NumSamples);
	
	float3 FadeFactor = saturate( float3( 1.0 - abs( 0.5 - ShadowProj.xy ) * 2.0, 1.0 - ShadowProj.z ) * 32.0 ); // 32 is just a random strength on the fade
	ShadowTerm = lerp( 1.0, ShadowTerm, min( min( FadeFactor.x, FadeFactor.y ), FadeFactor.z ) );
	
	return lerp( 1.0, ShadowTerm, ShadowFadeFactor );
}
static const float TWO_PI = 6.28318530718f;

static const float SHADOW_AMBIENT_MIN_FACTOR = 0.0;
static const float SHADOW_AMBIENT_MAX_FACTOR = 0.3;
float4x4 GetWorldMatrixMapObject( in uint InstanceIndex )
{
	int i = int(InstanceIndex) * 4;
	return Create4x4( PdxReadBuffer4( MapObjectBuffer, i+0 ), PdxReadBuffer4( MapObjectBuffer, i+1 ), PdxReadBuffer4( MapObjectBuffer, i+2 ), PdxReadBuffer4( MapObjectBuffer, i+3 ) );
}
uint UnpackAndGetMapObjectInstanceIndex( in uint InstanceIndex24_Opacity8 )
{
	return ( InstanceIndex24_Opacity8 >> 8 ) & uint(0x00ffffff);
}
float UnpackAndGetMapObjectOpacity( in uint InstanceIndex24_Opacity8 )
{
	const float OpacityScale = 1.0f / float(0x0000007f);
	float Opacity = float(uint(InstanceIndex24_Opacity8 & uint(0x0000007f))) * OpacityScale;
	if( (InstanceIndex24_Opacity8 & uint(0x00000080) ) != 0 )
	{
		Opacity *= -1.0f;
	}
	return Opacity;
}
float4x4 UnpackAndGetMapObjectWorldMatrix( in uint InstanceIndex24_Opacity8 )
{
	uint InstanceIndex = UnpackAndGetMapObjectInstanceIndex( InstanceIndex24_Opacity8 );
	return GetWorldMatrixMapObject( InstanceIndex );
}
void UnpackMapObjectInstanceData( in uint InstanceIndex24_Opacity8, out uint InstanceIndex, out float Opacity )
{
	InstanceIndex = UnpackAndGetMapObjectInstanceIndex( InstanceIndex24_Opacity8 );
	Opacity = UnpackAndGetMapObjectOpacity( InstanceIndex24_Opacity8 );
}
float4 ColorSample( float2 Coord, PdxTextureSampler2D IndirectionMap, PdxTextureSampler2D ColorMap )
{
	float2 ColorIndex = PdxTex2D( IndirectionMap, Coord ).rg;
	return PdxTex2DLoad0( ColorMap, int2( ColorIndex * IndirectionMapDepth + vec2(0.5f) ) );
}

float4 ColorSampleAtOffset( float2 Coord, PdxTextureSampler2D IndirectionMap, PdxTextureSampler2D ColorMap, float2 Offset )
{
	float2 ColorIndex = PdxTex2D( IndirectionMap, Coord ).rg;
	return PdxTex2DLoad0( ColorMap, int2( ColorIndex * IndirectionMapDepth + vec2(0.5) + ( Offset ) ) );
}
    
float4 BilinearColorSample( float2 Coord, float2 TextureSize, float2 InvTextureSize, PdxTextureSampler2D IndirectionMap, PdxTextureSampler2D ColorMap )
{
	float2 Pixel = Coord * TextureSize + 0.5;
	
	float2 FracCoord = frac(Pixel);
	Pixel = floor(Pixel) / TextureSize - InvTextureSize / 2.0;

	float4 C11 = ColorSample( Pixel, IndirectionMap, ColorMap );
	float4 C21 = ColorSample( Pixel + float2( InvTextureSize.x, 0.0), IndirectionMap, ColorMap );
	float4 C12 = ColorSample( Pixel + float2( 0.0, InvTextureSize.y), IndirectionMap, ColorMap );
	float4 C22 = ColorSample( Pixel + InvTextureSize, IndirectionMap, ColorMap );

	float4 x1 = lerp(C11, C21, FracCoord.x);
	float4 x2 = lerp(C12, C22, FracCoord.x);
	return lerp(x1, x2, FracCoord.y);
}

float4 BilinearColorSampleAtOffset( float2 Coord, float2 TextureSize, float2 InvTextureSize, PdxTextureSampler2D IndirectionMap, PdxTextureSampler2D ColorMap, float2 TextureOffset )
{
	float2 Pixel = ( Coord * TextureSize + 0.5 );
	
	float2 FracCoord = frac(Pixel);
	Pixel = floor(Pixel) / TextureSize - InvTextureSize / 2.0;

	float4 C11 = ColorSampleAtOffset( Pixel, IndirectionMap, ColorMap, TextureOffset );
	float4 C21 = ColorSampleAtOffset( Pixel + float2( InvTextureSize.x, 0.0), IndirectionMap, ColorMap, TextureOffset );
	float4 C12 = ColorSampleAtOffset( Pixel + float2( 0.0, InvTextureSize.y), IndirectionMap, ColorMap, TextureOffset );
	float4 C22 = ColorSampleAtOffset( Pixel + InvTextureSize, IndirectionMap, ColorMap, TextureOffset );

	float4 x1 = lerp(C11, C21, FracCoord.x);
	float4 x2 = lerp(C12, C22, FracCoord.x);
	return lerp(x1, x2, FracCoord.y);
}


float CalculateStripeMask( in float2 UV, float Offset )
{
	// diagonal
	float t = 3.14159 / 8.0;
	float w = 12000;			  // larger value gives smaller width
	
	float StripeMask = cos( ( UV.x * cos( t ) * w ) + ( UV.y * sin( t ) * w ) + Offset ); 
	StripeMask = smoothstep(0.0, 1.0, StripeMask * 2.2f );
	return StripeMask;
}	

void ApplyDiagonalStripes( inout float3 BaseColor, float3 StripeColor, float StripeAlpha, float2 WorldSpacePosXZ )
{
	float Mask = CalculateStripeMask( WorldSpacePosXZ, 0.f );
	float OffsetMask = CalculateStripeMask( WorldSpacePosXZ, -0.5f );
	float Shadow = 1 - saturate( Mask - OffsetMask ) ;
	Mask *= StripeAlpha;
	BaseColor = lerp( BaseColor, BaseColor * Shadow, StripeAlpha );
	BaseColor = lerp( BaseColor, StripeColor.rgb, Mask );
}

void ApplyDiagonalStripes( inout float4 BaseColor, float4 StripeColor, float ShadowAmount, float2 WorldSpacePosXZ )
{
	float Mask = CalculateStripeMask( WorldSpacePosXZ, 0.0f );
	float OffsetMask = CalculateStripeMask( WorldSpacePosXZ, -0.5f );
	float Shadow = 1.0f - saturate( Mask - OffsetMask );
	Mask *= StripeColor.a;
	BaseColor.rgb = lerp( BaseColor.rgb, BaseColor.rgb * Shadow, Mask * ShadowAmount );
	BaseColor = lerp( BaseColor, StripeColor, Mask );
}
float4 AlphaBlendAOverB( float4 A, float4 B )
{
	float Alpha = A.a + B.a * ( 1.0f - A.a );
	float3 Color = A.rgb * A.a + B.rgb * B.a * ( 1.0f - A.a );
	Color /= clamp( Alpha, 0.01f, 1.0f );
	return float4( Color, Alpha );
}

// Vertical Rays
float RayValue( in float2 coord, in float frequency, in float travelRate, in float maxStrength )
{
	float ny = 2.0f * ( coord.y - 0.5f );
	float ny2 = min( 1.0f, 2.5f - 2.5f * ny * ny );

	float xModifier = 1.0f * ( cos( GlobalTime * travelRate + coord.x * frequency ) - 0.5f );
	float yModifier = sin( coord.y );
	return maxStrength * xModifier * yModifier * ny2;
}

float Hash1_2( in float2 x )
{
	return frac( sin( dot( x, float2( 52.127f, 61.2871f) ) ) * 521.582f );
}

float2 Hash2_2( in float2 x )
{
	return frac( sin( mul( Create2x2( 20.52f, 24.1994f, 70.291f, 80.171f ),  x ) * 492.194 ) );
}

float2 Noise2_2( float2 uv )
{
	float2 f = smoothstep( 0.0f, 1.0f, frac( uv ) );

	float2 uv00 = floor( uv );
	float2 uv01 = uv00 + float2( 0, 1 );
	float2 uv10 = uv00 + float2( 1, 0 );
	float2 uv11 = uv00 + 1.0f;
	float2 v00 = Hash2_2( uv00 );
	float2 v01 = Hash2_2( uv01 );
	float2 v10 = Hash2_2( uv10 );
	float2 v11 = Hash2_2( uv11 );

	float2 v0 = lerp( v00, v01, f.y );
	float2 v1 = lerp ( v10, v11, f.y );
	float2 v = lerp( v0, v1, f.x );

	return v;
}

// Rotates point around 0,0
float2 Rotate( in float2 p, in float deg )
{
	float s = sin( deg );
	float c = cos( deg );
	p = mul( Create2x2( s, c, -c, s ), p );
	return p;
}

float CalculateStripeMask( float2 UV, float Offset, float Width )
{
	// Diagonal
	float t = 3.14159 / ( 8.0 );
	float w = 3000 * Width;			  // larger value gives smaller width

	float StripeMask = cos( ( UV.x * cos( t ) * w ) + ( UV.y * sin( t ) * w ) + Offset );
	StripeMask = smoothstep( 0.0, 1.0, StripeMask * 2.2f );
	return StripeMask;
}

// WATER CANAL //
#define WATER_CANAL_DEPTH_MAX 0.35
#define WATER_CANAL_DEPTH_AMP 70.0

// DEVASTATION //
// Water
#define WATER_DEVASTATION_COLOR float3( 0.18, 0.125, 0.09 )
#define WATER_DEVASTATION_MULT 1.5
#define SHORE_DEVASTATION_COLOR float3( 0.172, 0.13, 0.11 )
#define SHORE_DEVASTATION_MULT 1.25

// Road
#define ROAD_DEVASTATION_COLOR float3( 0.172, 0.13, 0.11 )
#define ROAD_DEVASTATION_MULT 1.6
#define ROAD_DEVASTATION_MAX 0.66

// Building
#define BUILDING_DEVASTATION_MULT 2.0
#define BUILDING_DEVASTATION_UV_SCALE 30
#define BUILDING_DEVASTATION_HEIGHT_MIN 0.0
#define BUILDING_DEVASTATION_HEIGHT_MAX 1.2

// Decal
#define DECAL_DEVASTATION_COLOR float3( 0.172, 0.13, 0.11 )
#define DECAL_DEVASTATION_MULT 2.0

// OCCUPATION HIGHLIGHT
#define OCCUPATION_HIGHLIGHT_STRENGTH 3.0
#define OCCUPATION_HIGHLIGHT_ALPHA 0.9
#define OCCUPATION_HIGHLIGHT_COLOR_MULT 1.0
#define OCCUPATION_HIGHLIGHT_POSITION 0.0
#define OCCUPATION_HIGHLIGHT_CONTRAST 0.1

// MAPMODE TEXTURE
#define MAPMODE_UV_ROW_OFFSET 0
#define MAPMODE_UV_ROW_COUNT 0

// TREE SWAY MULTIPLIERS
// Bush Tree
#define BUSH_TREE_HEIGHT_IMPACT 2.0
#define BUSH_TREE_SWAY_SCALE 1.5

// Medium Tree
#define MEDIUM_TREE_SWAY_SPEED 1.3
#define MEDIUM_TREE_HEIGHT_IMPACT 3.0
#define MEDIUM_TREE_SWAY_SCALE 0.75

// Large Tree
#define TALL_TREE_SWAY_SPEED 2.0
#define TALL_TREE_HEIGHT_IMPACT 1.0
#define TALL_TREE_SWAY_SCALE 1.0
float GameCalculateDistanceFogFactor( float3 WorldSpacePos )
{
	// Offset towards camera look direction
	float Scalar = CameraPosition.y / -CameraLookAtDir.y;
	float3 IntersectionPoint = CameraPosition + Scalar * CameraLookAtDir;
	float3 FogOffset = CameraLookAtDir * ( _FogCloseOffset + _FogFarOffset * saturate( smoothstep(0.0f, 600.0f, CameraPosition.y ) ) );
	FogOffset.y = 0.0f;	// Don't offset height

	// Rotate and scale with view
	float ScalingX = _FogWidthScale;
	float ScalingY = 1.0f + 1.0f * ( 1.0f + CameraLookAtDir.y );
	float2 secondaryPrincipal = float2( CameraRightDir.z, -CameraRightDir.x );
	float3 Diff = ( IntersectionPoint + FogOffset ) - WorldSpacePos;
	Diff.xz = float2( dot( Diff.xz, CameraRightDir.xz ) * ( 1.0 / ScalingX ), dot( Diff.xz, secondaryPrincipal ) * ( 1.0 / ScalingY ) );

	// Fog factor (amount)
	float vFogFactor = 1.0 - abs( normalize( Diff ).y ); // abs b/c of reflections
	float vSqDistance = dot( Diff, Diff );
	float vMin = ( vSqDistance - FogBegin2 ) / ( FogEnd2 - FogBegin2 );
	return saturate( vMin * vFogFactor * FogMax );
}

float3 GameApplyDistanceFog( float3 Color, float3 WorldSpacePos )
{
	float factor = GameCalculateDistanceFogFactor( WorldSpacePos ) ;
	return lerp( Color, HardLight( Color, FogColor ), factor );
}
float GameApplyDistanceFog( float Value, float3 WorldSpacePos )
{
	float factor = GameCalculateDistanceFogFactor( WorldSpacePos ) ;

	float FogValue_ = ( FogColor.x + FogColor.y + FogColor.z ) / 3;
	FogValue_ = HardLight( Value, FogValue_ );

	return lerp( Value, FogValue_, factor );
}
// Reference List of IGs
// IG_ARMED_FORCES
// IG_DEVOUT
// IG_INDUSTRIALISTS
// IG_INTELLIGENTSIA
// IG_LANDOWNERS
// IG_PETTY_BOURGEOISIE
// IG_RURAL_FOLK
// IG_TRADE_UNIONS

// Scripted IG colors in HSV //
#define COLOR_IG_DEFAULT			float4( 0.00, 0.00, 0.50, 1.0 )

#define INDEX_IG_ARMED_FORCES 0
#define COLOR_IG_ARMED_FORCES		float4( 0.09, 0.29, 0.39, 1.0 )

#define INDEX_IG_DEVOUT 1
#define COLOR_IG_DEVOUT 			float4( 0.50, 0.30, 0.67, 1.0 )

#define INDEX_IG_INDUSTRIALISTS 2
#define COLOR_IG_INDUSTRIALISTS 	float4( 0.06, 0.60, 0.89, 1.0 )

#define INDEX_IG_INTELLIGENTSIA 3
#define COLOR_IG_INTELLIGENTSIA 	float4( 0.13, 0.64, 0.99, 1.0 )

#define INDEX_IG_LANDOWNERS 4
#define COLOR_IG_LANDOWNERS 		float4( 0.63, 0.40, 0.69, 1.0 )

#define INDEX_IG_PETTY_BOURGEOISIE 5
#define COLOR_IG_PETTY_BOURGEOISIE 	float4( 0.65, 0.54, 0.52, 1.0 )

#define INDEX_IG_RURAL_FOLK 6
#define COLOR_IG_RURAL_FOLK 		float4( 0.32, 0.45, 0.47, 1.0 )

#define INDEX_IG_TRADE_UNIONS 7
#define COLOR_IG_TRADE_UNIONS 		float4( 0.00, 0.56, 0.58, 1.0 )

float4 GetInterestGroupColorDefine( )
{
	#if defined( IG_ARMED_FORCES )
		return COLOR_IG_ARMED_FORCES;
	#elif defined( IG_DEVOUT )
		return COLOR_IG_DEVOUT;
	#elif defined( IG_INDUSTRIALISTS )
		return COLOR_IG_INDUSTRIALISTS;
	#elif defined( IG_INTELLIGENTSIA )
		return COLOR_IG_INTELLIGENTSIA;
	#elif defined( IG_LANDOWNERS )
		return COLOR_IG_LANDOWNERS;
	#elif defined( IG_PETTY_BOURGEOISIE )
		return COLOR_IG_PETTY_BOURGEOISIE;
	#elif defined( IG_RURAL_FOLK )
		return COLOR_IG_RURAL_FOLK;
	#elif defined( IG_TRADE_UNIONS )
		return COLOR_IG_TRADE_UNIONS;
	#endif

	return COLOR_IG_DEFAULT;
}

float4 GetInterestGroupColorUserdata( uint InstanceIndex )
{
	if( InstanceIndex == INDEX_IG_ARMED_FORCES )
	{
		return COLOR_IG_ARMED_FORCES;
	}
	else if ( InstanceIndex == INDEX_IG_DEVOUT )
	{
		return COLOR_IG_DEVOUT;
	}
	else if ( InstanceIndex == INDEX_IG_INDUSTRIALISTS )
	{
		return COLOR_IG_INDUSTRIALISTS;
	}
	else if ( InstanceIndex == INDEX_IG_INTELLIGENTSIA )
	{
		return COLOR_IG_INTELLIGENTSIA;
	}
	else if ( InstanceIndex == INDEX_IG_LANDOWNERS )
	{
		return COLOR_IG_LANDOWNERS;
	}
	else if ( InstanceIndex == INDEX_IG_PETTY_BOURGEOISIE )
	{
		return COLOR_IG_PETTY_BOURGEOISIE;
	}
	else if ( InstanceIndex == INDEX_IG_RURAL_FOLK )
	{
		return COLOR_IG_RURAL_FOLK;
	}
	else if ( InstanceIndex == INDEX_IG_TRADE_UNIONS )
	{
		return COLOR_IG_TRADE_UNIONS;
	}

	return COLOR_IG_DEFAULT;
}
uint GetUserDataUint( uint InstanceIndex )
{
	return uint( Data[ InstanceIndex + PDXMESH_USER_DATA_OFFSET + 0 ].x );
}
float4 GetUserDataBuildingLightColor( uint InstanceIndex )
{
	return Data[ InstanceIndex + PDXMESH_USER_DATA_OFFSET + 0 ];
}
float GetUserDataPrettyValue( uint InstanceIndex )
{
	return Data[ InstanceIndex + PDXMESH_USER_DATA_OFFSET + 1 ].x;
}
float GetUserDataRandomValueCity( uint InstanceIndex )
{
	return Data[ InstanceIndex + PDXMESH_USER_DATA_OFFSET + 1 ].y;
}
float GetUserDataShouldLightActivate( uint InstanceIndex )
{
	return Data[ InstanceIndex + PDXMESH_USER_DATA_OFFSET + 1 ].z;
}

#ifndef PDXMESH_AlphaBlendShadowMap
	#define PDXMESH_AlphaBlendShadowMap DiffuseMap
#endif

#ifndef PDXMESH_DISABLE_DITHERED_OPACITY
	#define PDXMESH_USE_DITHERED_OPACITY
#endif

void PdxMeshApplyDitheredOpacity( in float Opacity, in float2 NoiseCoordinate )
{
	#ifdef PDXMESH_SCREENDOOR_DITHER				
		const float4x4 ThresholdMatrix =
		{
			1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
			13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
			4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
			16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
		};
		float Factor = ThresholdMatrix[NoiseCoordinate.x % 4][NoiseCoordinate.y % 4];
	#else
		float Factor = CalcRandom( NoiseCoordinate );
	#endif
	
	clip( Opacity - Factor * sign( Opacity ) );
}

float PdxMeshApplyOpacity( in float Alpha, in float2 NoiseCoordinate, in float Opacity )
{
	#ifdef PDXMESH_USE_DITHERED_OPACITY
		if( Opacity < 1.0f )
		{
			PdxMeshApplyDitheredOpacity( Opacity, NoiseCoordinate );
		}
	#endif
	return Alpha;
}

float4 CalcHeightBlendFactors( float4 MaterialHeights, float4 MaterialFactors, float BlendRange )
{
	float4 Mat = MaterialHeights + MaterialFactors;
	float BlendStart = max( max( Mat.x, Mat.y ), max( Mat.z, Mat.w ) ) - BlendRange;

	float4 MatBlend = max( Mat - vec4( BlendStart ), vec4( 0.0 ) );

	float Epsilon = 0.00001;
	return float4( MatBlend ) / ( dot( MatBlend, vec4( 1.0 ) ) + Epsilon );
}

float2 CalcDetailUV( float2 WorldSpacePosXZ )
{
	return WorldSpacePosXZ * _DetailTileFactor;
}

void CalculateDetails( float2 WorldSpacePosXZ, out float4 DetailDiffuseHeight, out float3 DetailNormal, out float4 DetailMaterial )
{
	float2 DetailCoordinates = WorldSpacePosXZ * _WorldSpaceToDetail;
	float2 DetailCoordinatesScaled = DetailCoordinates * _DetailTextureSize;
	float2 DetailCoordinatesScaledFloored = floor( DetailCoordinatesScaled );
	float2 DetailCoordinatesFrac = DetailCoordinatesScaled - DetailCoordinatesScaledFloored;
	DetailCoordinates = DetailCoordinatesScaledFloored * _DetailTexelSize + _DetailTexelSize * 0.5;

	float4 Factors = float4(
		(1.0 - DetailCoordinatesFrac.x) * (1.0 - DetailCoordinatesFrac.y),
		DetailCoordinatesFrac.x * (1.0 - DetailCoordinatesFrac.y),
		(1.0 - DetailCoordinatesFrac.x) * DetailCoordinatesFrac.y,
		DetailCoordinatesFrac.x * DetailCoordinatesFrac.y
	);

	float4 DetailIndex = PdxTex2D( DetailIndexTexture, DetailCoordinates ) * 255.0;
	float4 DetailMask = PdxTex2D( DetailMaskTexture, DetailCoordinates ) * Factors[0];

	float2 Offsets[3];
	Offsets[0] = float2( _DetailTexelSize.x, 0.0 );
	Offsets[1] = float2( 0.0, _DetailTexelSize.y );
	Offsets[2] = float2( _DetailTexelSize.x, _DetailTexelSize.y );

	for ( int k = 0; k < 3; ++k )
	{
		float2 DetailCoordinates2 = DetailCoordinates + Offsets[k];

		float4 DetailIndices = PdxTex2DLod0( DetailIndexTexture, DetailCoordinates2 ) * 255.0;
		float4 DetailMasks = PdxTex2DLod0( DetailMaskTexture, DetailCoordinates2 ) * Factors[k+1];

		for ( int i = 0; i < 4; ++i )
		{
			for ( int j = 0; j < 4; ++j )
			{
				if ( DetailIndex[j] == DetailIndices[i] )
				{
					DetailMask[j] += DetailMasks[i];
				}
			}
		}
	}

	float2 DetailUV = CalcDetailUV( WorldSpacePosXZ );
	
	float2 DDX = ApplyUpscaleLodBiasMultiplier( ddx(DetailUV) );
	float2 DDY = ApplyUpscaleLodBiasMultiplier( ddy(DetailUV) );

	float4 DetailTexture0 = PdxTex2DGrad( DetailTextures, float3( DetailUV, DetailIndex[0] ), DDX, DDY ) * smoothstep( 0.0, 0.1, DetailMask[0] );
	float4 DetailTexture1 = PdxTex2DGrad( DetailTextures, float3( DetailUV, DetailIndex[1] ), DDX, DDY ) * smoothstep( 0.0, 0.1, DetailMask[1] );
	float4 DetailTexture2 = PdxTex2DGrad( DetailTextures, float3( DetailUV, DetailIndex[2] ), DDX, DDY ) * smoothstep( 0.0, 0.1, DetailMask[2] );
	float4 DetailTexture3 = PdxTex2DGrad( DetailTextures, float3( DetailUV, DetailIndex[3] ), DDX, DDY ) * smoothstep( 0.0, 0.1, DetailMask[3] );

	float4 BlendFactors = CalcHeightBlendFactors( float4( DetailTexture0.a, DetailTexture1.a, DetailTexture2.a, DetailTexture3.a ), DetailMask, _DetailBlendRange );
	//BlendFactors = DetailMask;

	DetailDiffuseHeight = DetailTexture0 * BlendFactors.x +
					DetailTexture1 * BlendFactors.y +
					DetailTexture2 * BlendFactors.z +
					DetailTexture3 * BlendFactors.w;

	DetailMaterial = vec4( 0.0 );
	float4 DetailNormalSample = vec4( 0.0 );

	for ( int i = 0; i < 4; ++i )
	{
		float BlendFactor = BlendFactors[i];
		if ( BlendFactor > 0.0 )
		{
			float3 ArrayUV = float3( DetailUV, DetailIndex[i] );
			float4 NormalTexture = PdxTex2DGrad( NormalTextures, ArrayUV, DDX, DDY );
			float4 MaterialTexture = PdxTex2DGrad( MaterialTextures, ArrayUV, DDX, DDY );

			DetailNormalSample += NormalTexture * BlendFactor;
			DetailMaterial += MaterialTexture * BlendFactor;
		}
	}

	DetailNormal = UnpackRRxGNormal( DetailNormalSample ).xyz;
}

//-------------------------------
// Debugging --------------------
//-------------------------------
float3 GetNumMaterials( float4 Index )
{
	int nNumMaterials = 0;
	for ( int i = 0; i < 4; ++i )
	{
		if ( Index[i] < 1.0 )
		{
			nNumMaterials++;
		}
	}

	if ( nNumMaterials == 1 )
		return float3( 1, 0, 0 );
	else if ( nNumMaterials == 2 )
		return float3( 0, 1, 0 );
	else if ( nNumMaterials == 3 )
		return float3( 0, 0, 1 );
	else if ( nNumMaterials == 4 )
		return float3( 1, 1, 0 );

	return float3( 0, 0, 0 );
}


//#define TERRAIN_DEBUG
//#define TERRAIN_DEBUG_WIREFRAME
//#define TERRAIN_DEBUG_HEIGHT
//#define TERRAIN_DEBUG_LOOKUP_BORDER
//#define TERRAIN_DEBUG_HEIGHTMAP_BORDER
//#define TERRAIN_DEBUG_NORMAL
//#define TERRAIN_DEBUG_NUM_MATERIALS
//#define TERRAIN_DEBUG_DETAIL_BORDER
//#define TERRAIN_DEBUG_DETAIL_MASK
//#define TERRAIN_DEBUG_DETAIL_INDEX
void TerrainDebug( inout float3 Color, float3 WorldSpacePos )
{
#ifdef TERRAIN_DEBUG
	float3 Result = float3(0,0,0);

	float2 LookupCoordinates = GetLookupCoordinates( WorldSpacePos.xz );
#ifdef TERRAIN_DEBUG_WIREFRAME
	float3 Wireframe = vec3( GetTextureBorder( LookupCoordinates, IndirectionSize * (BaseTileSize - 1), 0.02 ) );
	Result += Wireframe;
#endif

#ifdef TERRAIN_DEBUG_HEIGHT
	Result += float3( GetHeight01( WorldSpacePos.xz ), 0, 0 );
#endif

#ifdef TERRAIN_DEBUG_LOOKUP_BORDER
	float3 LookupBorder = float3( 0.0, 0.0, GetTextureBorder( LookupCoordinates, IndirectionSize, 0.0006 ) );
	Result += LookupBorder;
#endif
#ifdef TERRAIN_DEBUG_HEIGHTMAP_BORDER
	float2 HeightMapCoord = GetHeightMapCoordinates( WorldSpacePos.xz );
	float3 HeightMapBorder = float3( GetTextureBorder( HeightMapCoord, PackedHeightMapSize, 0.02 ), 0.0, 0.0 );
	Result += HeightMapBorder;
#endif

#ifdef TERRAIN_DEBUG_NORMAL
	Result = saturate( CalculateNormal( WorldSpacePos.xz ) );
#endif

	float2 DetailCoordinates = WorldSpacePos.xz * _WorldSpaceToDetail + _DetailTexelSize * 0.5;
	float4 DetailMask = PdxTex2D( DetailMaskTexture, DetailCoordinates );
	float4 DetailIndex = PdxTex2D( DetailIndexTexture, DetailCoordinates );
#ifdef TERRAIN_DEBUG_NUM_MATERIALS
	Result = GetNumMaterials( DetailIndex );
#endif
#ifdef TERRAIN_DEBUG_DETAIL_BORDER
	float3 IndexBorder = float3( 0.0, 0.0, GetTextureBorder( DetailCoordinates, _DetailTextureSize, 0.05 ) );
	Result += IndexBorder; // * GetModValueFloor( DetailCoordinates.y * (_DetailTextureSize.y), 4 );
#endif
#ifdef TERRAIN_DEBUG_DETAIL_MASK
	DetailMask /= dot( DetailMask, vec4( 1.0 ) );
	Result += DetailMask.rgb;
#endif

#ifdef TERRAIN_DEBUG_DETAIL_INDEX
	Result += DetailIndex.rgb;
#endif

	Color = Result;
#endif
}

// Implements https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f

float CalcMipLevel(float2 texture_coord)
{
	float2 dx = ddx(texture_coord);
	float2 dy = ddy(texture_coord);
	float delta_max_sqr = max(dot(dx, dx), dot(dy, dy));
	return max(0.0, 0.5 * log2(delta_max_sqr));
}

float RescaleAlphaByMipLevel( float Alpha, float2 UV, PdxTextureSampler2D Sampler )
{
	// 0.25 approximates the loss of density from mip mapping
	const float MIP_SCALE = 0.25f;
	float2 TextureSize;
	PdxTex2DSize( Sampler, TextureSize );
	float2 Scaled_UV = UV * TextureSize;
	return Alpha * ( 1.0f + ( CalcMipLevel( Scaled_UV ) * MIP_SCALE ) );
}

// This `Cutoff` value (between [0.0, 1.0]) can be tweaked to change the "thickness"
// of the edges where the transparency is, lower value -> thicker edge
float SharpenAlpha( float Alpha, float Cutoff )
{
	float Result = ( ( Alpha - Cutoff ) / max( fwidth( Alpha ), 0.0001f ) ) + 0.5f;
	return saturate( Result );
}

float CalcLightFalloff( float LightRadius, float Distance, float Falloff )
{
	// TODO other, square, falloff?
	return saturate( (LightRadius - Distance) / Falloff );
}

float CalcLightFalloff( float LightRadius, float Distance )
{
	// This is basically the unreal method, square distance falloff but capped at "LightRadius" distance and capped at intensity 1 at distance 0.
	return pow( saturate( 1.0 - pow( Distance / LightRadius, 4.0 ) ), 2.0 ) / ( Distance * Distance + 1.0 );
}


float3 MetalnessToDiffuse( float Metalness, float3 Diffuse )
{
	return lerp( Diffuse, vec3(0.0), Metalness );
}

float3 MetalnessToSpec( float Metalness, float3 Diffuse, float Spec )
{
	return lerp( vec3(Spec), Diffuse, Metalness );
}


#ifndef PDX_NumMips
	#define PDX_NumMips 10.0
#endif

#ifndef PDX_MipOffset
	#define PDX_MipOffset 2.0
#endif

#define PDX_SimpleLighting


struct SMaterialProperties
{
	float 	_PerceptualRoughness;
	float 	_Roughness;
	float	_Metalness;
	
	float3	_DiffuseColor;
	float3	_SpecularColor;
	float3	_Normal;
};

struct SLightingProperties
{
	float3		_ToCameraDir;
	float3		_ToLightDir;
	float3		_LightIntensity;
	float		_ShadowTerm;
	float		_CubemapIntensity;
	// this rotation matrix is used to rotate cubemap sampling vectors, thus "faking" a rotation of the cubemap
	float4x4	_CubemapYRotation;
};

float RemapSpec( float SampledSpec )
{
	return 0.25 * SampledSpec;
}
	
float RoughnessFromPerceptualRoughness( float PerceptualRoughness )
{
	return PerceptualRoughness * PerceptualRoughness;
}

float BurleyToMipSimple( float PerceptualRoughness )
{
   float Scale = PerceptualRoughness * (1.7 - 0.7 * PerceptualRoughness);
   return Scale * ( PDX_NumMips - 1 - PDX_MipOffset );
}

float3 GetSpecularDominantDir( float3 Normal, float3 Reflection, float Roughness )
{
	float Smoothness = saturate( 1.0 - Roughness );
	float LerpFactor = Smoothness * ( sqrt( Smoothness ) + Roughness );
	return normalize( lerp( Normal, Reflection, LerpFactor ) );
}

float GetReductionInMicrofacets( float Roughness )
{
	return 1.0 / (Roughness*Roughness + 1.0);
}

float F_Schlick( float f0, float f90, float CosAngle )
{
	return f0 + ( f90 - f0 ) * pow( 1.0 - CosAngle, 5.0 );
}

float3 F_Schlick( float3 f0, float3 f90, float CosAngle )
{
	return f0 + ( f90 - f0 ) * pow( 1.0 - CosAngle, 5.0 );
}
        

float DisneyDiffuse( float NdotV, float NdotL, float LdotH, float LinearRoughness )
{
	float EnergyBias = lerp( 0.0, 0.5, LinearRoughness );
	float EnergyFactor = lerp( 1.0, 1.0 / 1.51, LinearRoughness );
	float f90 = EnergyBias + 2.0 * LdotH * LdotH * LinearRoughness;
	float LightScatter = F_Schlick( 1.0, f90, NdotL );
	float ViewScatter = F_Schlick( 1.0, f90, NdotV );
	
	return LightScatter * ViewScatter * EnergyFactor;
}

float CalcDiffuseBRDF( float NdotV, float NdotL, float LdotH, float PerceptualRoughness )
{
#ifdef PDX_SimpleLighting
	return 1.0 / PI;
#else
	return DisneyDiffuse( NdotV, NdotL, LdotH, PerceptualRoughness ) / PI;
#endif
}


float D_GGX( float NdotH, float Alpha )
{
	float Alpha2 = Alpha * Alpha;
	float f = ( NdotH * Alpha2 - NdotH ) * NdotH + 1.0;
	return Alpha2 / (PI * f * f);
}

float G1( float CosAngle, float k )
{
	return 1.0 / ( CosAngle * ( 1.0 - k ) + k );
}

float V_Schlick( float NdotL, float NdotV, float Alpha )
{
	float k = Alpha * 0.5;
	return G1( NdotL, k ) * G1( NdotV, k ) * 0.25;
}

float V_Optimized( float LdotH, float Alpha )
{
	float k = Alpha * 0.5;
	float k2 = k*k;
	float invk2 = 1.0 - k2;
	return 0.25 / ( LdotH * LdotH * invk2 + k2 );
}
        
float3 CalcSpecularBRDF( float3 SpecularColor, float LdotH, float NdotH, float NdotL, float NdotV, float Roughness )
{
	float3 F = F_Schlick( SpecularColor, vec3(1.0), LdotH );
	float D = D_GGX( NdotH, lerp( 0.03, 1.0, Roughness ) ); // Remap to avoid super small and super bright highlights
#ifdef PDX_SimpleLighting
	float Vis = V_Optimized( LdotH, Roughness );
#else
	float Vis = V_Schlick( NdotL, NdotV, Roughness );
#endif
	return D * F * Vis;
}

void CalculateLightingFromLight( SMaterialProperties MaterialProps, float3 ToCameraDir, float3 ToLightDir, float3 LightIntensity, out float3 DiffuseOut, out float3 SpecularOut )
{
	float3 H = normalize( ToCameraDir + ToLightDir );
	float NdotV = saturate( dot( MaterialProps._Normal, ToCameraDir ) ) + 1e-5;
	float NdotL = saturate( dot( MaterialProps._Normal, ToLightDir ) ) + 1e-5;
	float NdotH = saturate( dot( MaterialProps._Normal, H ) );
	float LdotH = saturate( dot( ToLightDir, H ) );
	
	float DiffuseBRDF = CalcDiffuseBRDF( NdotV, NdotL, LdotH, MaterialProps._PerceptualRoughness );
	DiffuseOut = DiffuseBRDF * MaterialProps._DiffuseColor * LightIntensity * NdotL;
	
#ifdef PDX_HACK_ToSpecularLightDir
	float3 H_Spec = normalize( ToCameraDir + PDX_HACK_ToSpecularLightDir );
	float NdotL_Spec = saturate( dot( MaterialProps._Normal, PDX_HACK_ToSpecularLightDir ) ) + 1e-5;
	float NdotH_Spec = saturate( dot( MaterialProps._Normal, H_Spec ) );
	float LdotH_Spec = saturate( dot( PDX_HACK_ToSpecularLightDir, H_Spec ) );
	float3 SpecularBRDF = CalcSpecularBRDF( MaterialProps._SpecularColor, LdotH_Spec, NdotH_Spec, NdotL_Spec, NdotV, MaterialProps._Roughness );
	SpecularOut = SpecularBRDF * LightIntensity * NdotL;
#else
	float3 SpecularBRDF = CalcSpecularBRDF( MaterialProps._SpecularColor, LdotH, NdotH, NdotL, NdotV, MaterialProps._Roughness );
	SpecularOut = SpecularBRDF * LightIntensity * NdotL;
#endif
}

void CalculateLightingFromLight( SMaterialProperties MaterialProps, SLightingProperties LightingProps, out float3 DiffuseOut, out float3 SpecularOut )
{
	CalculateLightingFromLight( MaterialProps, LightingProps._ToCameraDir, LightingProps._ToLightDir, LightingProps._LightIntensity * LightingProps._ShadowTerm, DiffuseOut, SpecularOut );
}

void CalculateLightingFromIBL( SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap, out float3 DiffuseIBLOut, out float3 SpecularIBLOut )
{
	float3 RotatedDiffuseCubemapUV = mul( CastTo3x3( LightingProps._CubemapYRotation ), MaterialProps._Normal );
	float3 DiffuseRad = PdxTexCubeLod( EnvironmentMap, RotatedDiffuseCubemapUV, ( PDX_NumMips - 1 - PDX_MipOffset ) ).rgb * LightingProps._CubemapIntensity; // TODO, maybe we should split diffuse and spec intensity?
	DiffuseIBLOut = DiffuseRad * MaterialProps._DiffuseColor;
	
	float3 ReflectionVector = reflect( -LightingProps._ToCameraDir, MaterialProps._Normal );
	float3 DominantReflectionVector = GetSpecularDominantDir( MaterialProps._Normal, ReflectionVector, MaterialProps._Roughness );

	float NdotR = saturate( dot( MaterialProps._Normal, DominantReflectionVector ) );
	float3 SpecularReflection = F_Schlick( MaterialProps._SpecularColor, vec3(1.0), NdotR );
	float SpecularFade = GetReductionInMicrofacets( MaterialProps._Roughness );

	float MipLevel = BurleyToMipSimple( MaterialProps._PerceptualRoughness );
	float3 RotatedSpecularCubemapUV = mul( CastTo3x3( LightingProps._CubemapYRotation ), DominantReflectionVector );
	float3 SpecularRad = PdxTexCubeLod( EnvironmentMap, RotatedSpecularCubemapUV, MipLevel ).rgb * LightingProps._CubemapIntensity; // TODO, maybe we should split diffuse and spec intensity?
	SpecularIBLOut = SpecularRad * SpecularFade * SpecularReflection;
}

float4x4 Float4x4Identity()
{
	return float4x4( 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );
}

SMaterialProperties GetMaterialProperties( float3 SampledDiffuse, float3 Normal, float SampledRoughness, float SampledSpec, float SampledMetalness )
{
	SMaterialProperties MaterialProps;
	
	MaterialProps._PerceptualRoughness = SampledRoughness;
	MaterialProps._Roughness = RoughnessFromPerceptualRoughness( MaterialProps._PerceptualRoughness );

	float SpecRemapped = RemapSpec( SampledSpec );
	MaterialProps._Metalness = SampledMetalness;

	MaterialProps._DiffuseColor = MetalnessToDiffuse( MaterialProps._Metalness, SampledDiffuse );
	MaterialProps._SpecularColor = MetalnessToSpec( MaterialProps._Metalness, SampledDiffuse, SpecRemapped );
	
	MaterialProps._Normal = Normal;
	
	return MaterialProps;
}

//-------------------------------
// Common lighting functions ----
//-------------------------------
SLightingProperties GetSunLightingProperties( float3 WorldSpacePos, float ShadowTerm )
{
	SLightingProperties LightingProps;
	LightingProps._ToCameraDir = normalize( CameraPosition - WorldSpacePos );
	LightingProps._ToLightDir = ToSunDir;
	LightingProps._LightIntensity = SunDiffuse * SunIntensity;
	LightingProps._ShadowTerm = ShadowTerm;
	LightingProps._CubemapIntensity = CubemapIntensity;
	LightingProps._CubemapYRotation = CubemapYRotation;
	
	return LightingProps;
}

SLightingProperties GetSunLightingProperties( float3 WorldSpacePos, PdxTextureSampler2DCmp ShadowMap )
{
	float4 ShadowProj = mul( ShadowMapTextureMatrix, float4( WorldSpacePos, 1.0 ) );
	float ShadowTerm = CalculateShadow( ShadowProj, ShadowMap );
	
	return GetSunLightingProperties( WorldSpacePos, ShadowTerm );
}

float3 CalculateSunLighting( SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap )
{
	float3 DiffuseLight;
	float3 SpecularLight;
	CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, SpecularLight );
	
	float3 DiffuseIBL;
	float3 SpecularIBL;
	CalculateLightingFromIBL( MaterialProps, LightingProps, EnvironmentMap, DiffuseIBL, SpecularIBL );
	
	return DiffuseLight + SpecularLight + DiffuseIBL + SpecularIBL;
}


//-------------------------------
// Debugging --------------------
//-------------------------------
//#define PDX_DEBUG_NORMAL
//#define PDX_DEBUG_DIFFUSE
//#define PDX_DEBUG_SPEC
//#define PDX_DEBUG_SPEC_RANGES
//#define PDX_DEBUG_ROUGHNESS
//#define PDX_DEBUG_METALNESS
//#define PDX_DEBUG_SHADOW
//#define PDX_DEBUG_SUN_LIGHT_SIMPLE_DIFFUSE // AKA Daniel mode
//#define PDX_DEBUG_SUN_LIGHT_ONLY_SPECULAR
//#define PDX_DEBUG_SUN_LIGHT
//#define PDX_DEBUG_SUN_LIGHT_WITH_SHADOW
//#define PDX_DEBUG_IBL_SIMPLE_DIFFUSE
//#define PDX_DEBUG_IBL_DIFFUSE
//#define PDX_DEBUG_IBL_SPECULAR
//#define PDX_DEBUG_IBL

void DebugReturn( inout float3 Out, SMaterialProperties MaterialProps, SLightingProperties LightingProps )
{
#ifdef PDX_DEBUG_NORMAL
	Out = saturate( MaterialProps._Normal );
#endif

#ifdef PDX_DEBUG_DIFFUSE
	Out = MaterialProps._DiffuseColor;
#endif

#ifdef PDX_DEBUG_SPEC
	Out = MaterialProps._SpecularColor;
#endif

#ifdef PDX_DEBUG_ROUGHNESS
	Out = vec3( MaterialProps._PerceptualRoughness );
#endif

#ifdef PDX_DEBUG_METALNESS
	Out = vec3( MaterialProps._Metalness );
#endif

#ifdef PDX_DEBUG_SPEC_RANGES
	// Shows extremely low specular values in red
	// Shows common material values in green (2-6%)
	// Shows gemstone material values in yellow (8-17%)
	// Shows metalness in blue
	// Shows everything else in gray scale	
	// Values based on page 14-15 in http://renderwonk.com/publications/s2010-shading-course/hoffman/s2010_physically_based_shading_hoffman_a_notes.pdf
	float Spec = MaterialProps._SpecularColor.r;
	
	float e = 0.002f;
	float ErrorThreshold = 0.01f;
	float DielectricLow = 0.02f;
	float DielectricHigh = 0.06f;
	float GemstoneLow = 0.08f;
	float GemstoneHigh = 0.17f;
	
	float Error = smoothstep( ErrorThreshold, 0.0, Spec );
	float CommonMask = smoothstep( DielectricLow-e, DielectricLow, Spec ) * smoothstep( DielectricHigh+e, DielectricHigh, Spec);
	float GemstoneMask = smoothstep( GemstoneLow-e, GemstoneLow, Spec ) * smoothstep( GemstoneHigh+e, GemstoneHigh, Spec);
	float ScaledSpec = ( Spec / RemapSpec(1.0f) );
	float3 DebugSpecColor = float3( GemstoneMask, CommonMask + GemstoneMask, 0.0 ) * ScaledSpec;
	Out = lerp( vec3(ScaledSpec), DebugSpecColor, CommonMask + GemstoneMask );
	Out = lerp( Out, float3(1.0,0.0,0.0), Error );
	Out = lerp( Out, float3(0.0,0.0,1.0), MaterialProps._Metalness );
#endif

#ifdef PDX_DEBUG_SHADOW
	Out = vec3( LightingProps._ShadowTerm );
#endif

#ifdef PDX_DEBUG_SUN_LIGHT_SIMPLE_DIFFUSE
	SMaterialProperties MaterialPropsCopy = MaterialProps;
	MaterialPropsCopy._DiffuseColor = vec3( 1.0 );
	MaterialPropsCopy._SpecularColor = vec3( 0.0 );
	
	float3 SpecularLight;
	CalculateLightingFromLight( MaterialPropsCopy, LightingProps, Out, SpecularLight );
#endif

#ifdef PDX_DEBUG_SUN_LIGHT_ONLY_SPECULAR			
	float3 DiffuseLight;			
	CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, Out );
#endif

#if defined( PDX_DEBUG_SUN_LIGHT ) || defined( PDX_DEBUG_SUN_LIGHT_WITH_SHADOW )
	float3 DiffuseLight;
	float3 SpecularLight;

	#ifdef PDX_DEBUG_SUN_LIGHT_WITH_SHADOW
		CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, SpecularLight );
	#else
		SLightingProperties LightingPropsNoShadow = LightingProps;
		LightingPropsNoShadow._ShadowTerm = 1.0;
		CalculateLightingFromLight( MaterialProps, LightingPropsNoShadow, DiffuseLight, SpecularLight );
	#endif
	
	Out = DiffuseLight + SpecularLight;
#endif
}

void DebugReturn( inout float3 Out, SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap )
{
	DebugReturn( Out, MaterialProps, LightingProps );

#if defined( PDX_DEBUG_IBL ) || defined( PDX_DEBUG_IBL_DIFFUSE ) || defined( PDX_DEBUG_IBL_SPECULAR ) || defined( PDX_DEBUG_IBL_SIMPLE_DIFFUSE )
	float3 DiffuseIBL;
	float3 SpecularIBL;
	
	SMaterialProperties MaterialPropsCopy = MaterialProps;
	#ifdef PDX_DEBUG_IBL_SIMPLE_DIFFUSE
		MaterialPropsCopy._DiffuseColor = vec3( 1.0 );
	#endif
	
	CalculateLightingFromIBL( MaterialPropsCopy, LightingProps, EnvironmentMap, DiffuseIBL, SpecularIBL );
	
	#if defined( PDX_DEBUG_IBL_DIFFUSE ) || defined( PDX_DEBUG_IBL_SIMPLE_DIFFUSE )
		Out = DiffuseIBL;
	#endif
	#ifdef PDX_DEBUG_IBL_SPECULAR
		Out = SpecularIBL;
	#endif
	#ifdef PDX_DEBUG_IBL
		Out = DiffuseIBL + SpecularIBL;
	#endif
#endif
}

float3 SampleNormalMapTexture( PdxTextureSampler2D Texture, float2 UV, float2 Scale, float Rotation, float Offset, float NormalFlatten )
{
	float2 Rotate = float2( cos( Rotation ), sin( Rotation ) );

	float2 UVCoord = float2( UV.x * Rotate.x - UV.y * Rotate.y, UV.x * Rotate.y + UV.y * Rotate.x );
	UVCoord *= Scale;
	UVCoord.x += Offset;
	
	float3 Normal = UnpackNormal( PdxTex2DUpscaleNative( Texture, UVCoord ) ).xzy;
	
	float2 InvRotate = float2( cos( -Rotation ), sin( -Rotation ) );
	Normal.xz = float2( Normal.x * InvRotate.x - Normal.z * InvRotate.y, Normal.x * InvRotate.y + Normal.z * InvRotate.x );
	Normal.z *= -1;
	
	Normal.y *= NormalFlatten;
	
	return normalize( Normal );
}

void SampleFlowTexture( PdxTextureSampler2D FlowMapTexture, PdxTextureSampler2D FlowNormalTexture, float2 FlowCoord, float2 NormalCoord, float2 Offset, float2 DDX, float2 DDY, out float3 Normal, out float FoamMask )
{
	float3 FlowMap = PdxTex2DLod0( FlowMapTexture, FlowCoord ).rgb;
	float2 FlowDir = FlowMap.xy * 2.0 - 1.0;
	FlowDir = FlowDir / ( length( FlowDir ) + 0.000001 ); // Intel did not like normalize()

	float2x2 FlowRotMat = Create2x2( -FlowDir.y, FlowDir.x, -FlowDir.x, -FlowDir.y );
	float2x2 FlowInvRotMat = Create2x2( -FlowDir.y, -FlowDir.x, FlowDir.x, -FlowDir.y );
	float4 Sample = PdxTex2DGrad( FlowNormalTexture, mul( FlowInvRotMat, NormalCoord ) - Offset * FlowMap.b, DDX, DDY );
	
	Normal = UnpackNormal( Sample ).xzy;
	Normal.y *= 1.0 / max( 0.01, FlowMap.b );
	Normal.xz = mul( FlowRotMat, Normal.xz );
	
	FoamMask = Sample.a * FlowMap.b;
}

float3 CalcFlow( PdxTextureSampler2D FlowMapTexture, PdxTextureSampler2D FlowNormalTexture, float2 FlowMapUV, float2 NormalMapUV, out float FoamMask )
{
	float FlowMapScale = 1.5;				
	float2 FlowCoordScale = _WaterFlowMapSize * FlowMapScale;
	float2 FlowCoord = FlowMapUV * FlowCoordScale;
	
	float2 BlendFactor = abs( 2.0 * frac( FlowCoord ) - 1.0 ) - 0.5;
	BlendFactor = 0.5 - 4.0 * BlendFactor * BlendFactor * BlendFactor;
	//BlendFactor = 1.0 - abs( 2.0 * frac( FlowCoord ) - 1.0 );
	
	float2 NormalCoord = NormalMapUV * _WaterFlowNormalScale;
	float2 DDX = ApplyUpscaleNativeLodBiasMultiplier( ddx( NormalCoord ) );
	float2 DDY = ApplyUpscaleNativeLodBiasMultiplier( ddy( NormalCoord ) );
	
	float2 Offset = float2( 0.0, -_WaterFlowTime );
	
	float4 Sample1;
	SampleFlowTexture( FlowMapTexture, FlowNormalTexture, floor( FlowCoord ) / FlowCoordScale, NormalCoord, Offset, DDX, DDY, Sample1.xyz, Sample1.a );
	float4 Sample2;
	SampleFlowTexture( FlowMapTexture, FlowNormalTexture, floor( FlowCoord + float2(0.5, 0.0) ) / FlowCoordScale, NormalCoord, Offset, DDX, DDY, Sample2.xyz, Sample2.a );
	float4 Sample3;
	SampleFlowTexture( FlowMapTexture, FlowNormalTexture, floor( FlowCoord + float2(0.0, 0.5) ) / FlowCoordScale, NormalCoord, Offset, DDX, DDY, Sample3.xyz, Sample3.a );
	float4 Sample4;
	SampleFlowTexture( FlowMapTexture, FlowNormalTexture, floor( FlowCoord + float2(0.5, 0.5) ) / FlowCoordScale, NormalCoord, Offset, DDX, DDY, Sample4.xyz, Sample4.a );
	
	float4 Sample12 = lerp( Sample2, Sample1, BlendFactor.x );
	float4 Sample34 = lerp( Sample4, Sample3, BlendFactor.x );
	
	float4 Sample = lerp( Sample34, Sample12, BlendFactor.y );
	
	Sample.y *= _WaterFlowNormalFlatten;
	float3 Normal = normalize( Sample.xyz );
	
	FoamMask = Sample.a;
	return Normal;
}

static const float MaxHeight = 50.0;
float CompressWorldSpace( float3 WorldSpacePos )
{
	float3 CameraPos = CameraPosition;
	if ( CameraPos.y > MaxHeight )
	{
		float Above = CameraPos.y - MaxHeight;
		float3 ToCameraDir = normalize( CameraPosition - WorldSpacePos );
		CameraPos = CameraPosition - ToCameraDir * (Above / ToCameraDir.y);
	}
	float3 ToCamera = CameraPos - WorldSpacePos;
	return length( ToCamera );
}

float3 DecompressWorldSpace( float3 WorldSpacePos, float Length )
{
	float3 ToCameraDir = normalize( CameraPosition - WorldSpacePos );
		
	float3 CameraPos = CameraPosition;
	if ( CameraPos.y > MaxHeight )
	{
		float Above = CameraPos.y - MaxHeight;
		CameraPos = CameraPosition - ToCameraDir * (Above / ToCameraDir.y);
	}
	
	float3 RefractionWorldSpacePos = CameraPos - ToCameraDir * Length;
	return RefractionWorldSpacePos;
}

void ApplyDither( in VS_OUTPUT_MAPOBJECT_SHADOW Input )
{
	float Opacity = UnpackAndGetMapObjectOpacity( Input.InstanceIndex24_Opacity8 );
	PdxMeshApplyDitheredOpacity( Opacity, Input.Position.xy );
}

/*
 * This file contains default implementations of province overlays using the primary and secondary province colors.
 * The third province colors currently have no default overlay implementation (perhaps a default highlight implementation should be included here?)
 * More info: https://confluence.paradoxinteractive.com/display/PROG/Province+overlays
 */


//#define BORDER_DISTANCE_FIELD_SAMPLES_MEDIUM
#define BORDER_DISTANCE_FIELD_SAMPLES_HIGH
float CalcDistanceFieldValue( in float2 NormalizedCoordinate )
{
	float Distance = PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate ).r;

	#if defined( BORDER_DISTANCE_FIELD_SAMPLES_MEDIUM ) || defined( BORDER_DISTANCE_FIELD_SAMPLES_HIGH )
	float2 Offset = vec2( .75f ) * InvGradientTextureSize; // (at the time of writing) this equals 3 color map texels
	Distance += PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate + ( Offset * float2( -1,-1 ) ) ).r;
	Distance += PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate + ( Offset * float2( 1,-1 ) ) ).r;
	Distance += PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate + ( Offset * float2( -1, 1 ) ) ).r;
	Distance += PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate + ( Offset * float2( 1, 1 ) ) ).r;
	#endif

	#if defined( BORDER_DISTANCE_FIELD_SAMPLES_HIGH )
	Distance += PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate + ( Offset * float2( -1, 0 ) ) ).r;
	Distance += PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate + ( Offset * float2( 1, 0 ) ) ).r;
	Distance += PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate + ( Offset * float2( 0, 1 ) ) ).r;
	Distance += PdxTex2D( BorderDistanceFieldTexture, NormalizedCoordinate + ( Offset * float2( 0,-1 ) ) ).r;
	#endif

	#if defined( BORDER_DISTANCE_FIELD_SAMPLES_HIGH )
		Distance /= 9.0f;
	#elif defined( BORDER_DISTANCE_FIELD_SAMPLES_MEDIUM )
		Distance /= 5.0f;
	#endif

	return Distance;
}

// This default implementation is using the secondary province colors to draw diagonal stripes over provinces (e.g. occupied provinces in titus)
void ApplySecondaryProvinceOverlay( in float2 NormalizedCoordinate, in float DistanceFieldValue, inout float4 Color )
{
	float4 SecondaryColor = BilinearColorSampleAtOffset( NormalizedCoordinate, IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, SecondaryProvinceColorsOffset );
	SecondaryColor.a *= smoothstep( GB_EdgeWidth, GB_EdgeWidth + 0.01f, DistanceFieldValue );
	ApplyDiagonalStripes( Color, SecondaryColor, 0.8, NormalizedCoordinate );
}

// This default implementation is using the alternate province colors to draw a solid color over provinces
void ApplyAlternateProvinceOverlay( in float2 NormalizedCoordinate, inout float4 Color )
{
	float4 AlternateColor = BilinearColorSampleAtOffset(
		NormalizedCoordinate,
		IndirectionMapSize,
		InvIndirectionMapSize,
		ProvinceColorIndirectionTexture,
		ProvinceColorTexture,
		AlternateProvinceColorsOffset );

	Color.rgb = lerp( Color.rgb, AlternateColor.rgb, AlternateColor.a );
	Color.a = Color.a * ( 1.0f - AlternateColor.a ) + AlternateColor.a;
}

// This default implementation is using the primary province colors with the gradiant border system; it is highly customizeable through the GradientBorders constant buffer. 
// Typically, this function is used to draw gradient borders and/or uniform "province colors"
float4 CalcPrimaryProvinceOverlay( in float2 NormalizedCoordinate, in float DistanceFieldValue )
{
	float4 PrimaryColor = BilinearColorSample( NormalizedCoordinate, IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture );

	float GradientAlpha = lerp( GB_GradientAlphaInside, GB_GradientAlphaOutside, RemapClamped( DistanceFieldValue, GB_EdgeWidth + GB_GradientWidth, GB_EdgeWidth, 0.0f, 1.0f ) );
	float Edge = smoothstep( GB_EdgeWidth + max( 0.0001f, GB_EdgeSmoothness ), GB_EdgeWidth, DistanceFieldValue );

	float4 Color;
	Color.rgb = lerp( PrimaryColor.rgb * GB_GradientColorMul, PrimaryColor.rgb * GB_EdgeColorMul, Edge );
	Color.a = PrimaryColor.a * max( GradientAlpha * ( 1.0f - pow( Edge, 2 ) ), GB_EdgeAlpha * Edge );

	return Color;
}

void GetGradiantBorderBlendValues( in float4 ProvinceOverlayColor, out float PreLightingBlend, out float PostLightingBlend )
{
	PreLightingBlend = GB_PreLightingBlend * ProvinceOverlayColor.a;
	PostLightingBlend = GB_PostLightingBlend * ProvinceOverlayColor.a;
}

// This is a high-level convencience function that can be used if no overlay shader customization is required
void GetProvinceOverlayAndBlend( in float2 NormalizedCoordinate, out float3 ProvinceOverlayColor, out float PreLightingBlend, out float PostLightingBlend )
{
	float DistanceFieldValue = CalcDistanceFieldValue( NormalizedCoordinate );
	float4 ProvinceOverlayColorWithAlpha = CalcPrimaryProvinceOverlay( NormalizedCoordinate, DistanceFieldValue );

	ApplySecondaryProvinceOverlay( NormalizedCoordinate, DistanceFieldValue, ProvinceOverlayColorWithAlpha );
	ApplyAlternateProvinceOverlay( NormalizedCoordinate, ProvinceOverlayColorWithAlpha );

	GetGradiantBorderBlendValues( ProvinceOverlayColorWithAlpha, PreLightingBlend, PostLightingBlend );
	ProvinceOverlayColor = ProvinceOverlayColorWithAlpha.rgb;
}

float3 GameCalculateSunLighting( SMaterialProperties MaterialProps, SLightingProperties LightingProps  )
{
	float3 DiffuseLight = vec3( 0.0f );
	float3 SpecularLight = vec3( 0.0f );

	// Light vectors
	float3 H = normalize( LightingProps._ToCameraDir + LightingProps._ToLightDir );
	float NdotV = abs( dot( MaterialProps._Normal, LightingProps._ToCameraDir ) ) + 1e-5;		// Add small values to avoid values of 0
	float NdotL = saturate( dot( MaterialProps._Normal, LightingProps._ToLightDir ) + 1e-5 );
	float NdotH = saturate( dot( MaterialProps._Normal, H ) + 1e-5 );
	float LdotH = saturate( dot( LightingProps._ToLightDir, H ) + 1e-5 );
	float3 LightIntensity = LightingProps._LightIntensity * NdotL * LightingProps._ShadowTerm;

	// Sun diffuse light
	float DiffuseBRDF = CalcDiffuseBRDF( NdotV, NdotL, LdotH, MaterialProps._PerceptualRoughness );
	DiffuseLight = DiffuseBRDF * MaterialProps._DiffuseColor * LightIntensity;

	// Sun specular light
	float3 F = F_Schlick( MaterialProps._SpecularColor, vec3( 1.0f ), LdotH );
	float D = D_GGX( NdotH, lerp( 0.03f , 1.0f , MaterialProps._Roughness ) );		// Remap to avoid super small and super bright highlights
	#ifdef PDX_SimpleLighting
		float Vis = V_Optimized( LdotH, MaterialProps._Roughness );
	#else
		float Vis = V_Schlick( NdotL, NdotV, MaterialProps._Roughness );
	#endif
	SpecularLight = D * F * Vis * LightIntensity;

	return DiffuseLight + SpecularLight;
}

SLightingProperties GetSecondSunLightingProperties( float3 WorldSpacePos )
{
	SLightingProperties LightingProps;
	LightingProps._ToCameraDir = normalize( CameraPosition - WorldSpacePos );

	LightingProps._ToLightDir = _SecondSunDir;
	LightingProps._LightIntensity = _SecondSunDiffuse * _SecondSunIntensity;

	// Default these values
	LightingProps._ShadowTerm = 1.0f;
	LightingProps._CubemapIntensity = 0.0f;
	LightingProps._CubemapYRotation = Float4x4Identity();

	return LightingProps;
}

float3 CalculateSecondSunLighting( SMaterialProperties MaterialProps, SLightingProperties LightingProps )
{
	return GameCalculateSunLighting( MaterialProps, LightingProps );
}

float ScaleRoughnessByDistance( float Roughness, float3 WorldSpacePos )
{
	float3 Intersection = CameraPosition - WorldSpacePos;
	float Scalar = Intersection.y;
	float Distance = length( Intersection );

	Roughness = 1.0 - Roughness;
	float ReducedRoughness = 1.0 - RemapClamped( Distance, _DistanceRoughnessPosition * Scalar, _DistanceRoughnessPosition * Scalar + _DistanceRoughnessBlend, Roughness, Roughness * _DistanceRoughnessScale );

	return ReducedRoughness;
}


float2 CalcHeightBlendFactors( float2 MaterialHeights, float2 MaterialFactors, float BlendRange )
{
	float2 Mat = MaterialHeights + MaterialFactors;
	float BlendStart = max( Mat.x, Mat.y ) - max( BlendRange, 0.0 );

	float2 MatBlend = max( Mat - vec2( BlendStart ), vec2( 0.0 ) );

	float Epsilon = 0.00001f;
	return float2( MatBlend ) / ( dot( MatBlend, vec2( 1.0 ) ) + Epsilon );
}

/* Amplitude reflection coefficient (s-polarized) */
float Rs(float n1, float n2, float cosI, float cosT)
{
	return ( n1 * cosI - n2 * cosT ) / ( n1 * cosI + n2 * cosT );
}

/* Amplitude reflection coefficient (p-polarized) */
float Rp(float n1, float n2, float cosI, float cosT)
{
	return ( n2 * cosI - n1 * cosT ) / ( n1 * cosT + n2 * cosI );
}

/* Amplitude transmission coefficient (s-polarized) */
float Ts( float n1, float n2, float cosI, float cosT )
{
	return 2 * n1 * cosI / ( n1 * cosI + n2 * cosT );
}

/* Amplitude transmission coefficient (p-polarized) */
float Tp( float n1, float n2, float cosI, float cosT )
{
	return 2 * n1 * cosI / ( n1 * cosT + n2 * cosI );
}

// cosI is the cosine of the incident angle, that is, cos0 = dot(view angle, normal)
// lambda is the wavelength of the incident light (e.g. lambda = 510 for green)
// From http://www.gamedev.net/page/resources/_/technical/graphics-programming-and-theory/thin-film-interference-for-computer-graphics-r2962
float ThinFilmReflectance(float cos0, float lambda, float thickness, float n0, float n1, float n2 )
{

	// Compute the phase change term (constant)
	float d10 = ( n1 > n0 ) ? 0.0 : PI;
	float d12 = ( n1 > n2 ) ? 0.0 : PI;
	float delta = d10 + d12;

	// Compute cos1, the cosine of the reflected angle
	float sin1 = pow( n0 / n1, 2.0 ) * (1.0 - pow( cos0, 2.0 ) );
	if ( sin1 > 1 ) return 1.0; // total internal reflection
	float cos1 = sqrt( 1.0 - sin1 );

	// Compute cos2, the cosine of the final transmitted angle, i.e. cos(theta_2)
	float sin2 = pow( n0 / n2, 2.0 ) * ( 1.0 - pow( cos0, 2.0 ) );
	if ( sin2 > 1.0 )
	{
		return 1.0; // Total internal reflection
	}

	float cos2 = sqrt( 1.0 - sin2 );

	// Get the reflection transmission amplitude Fresnel coefficients
	float alpha_s = Rs( n1, n0, cos1, cos0 ) * Rs( n1, n2, cos1, cos2 ); // rho_10 * rho_12 (s-polarized)
	float alpha_p = Rp( n1, n0, cos1, cos0 ) * Rp( n1, n2, cos1, cos2 ); // rho_10 * rho_12 (p-polarized)

	float beta_s = Ts( n0, n1, cos0, cos1 ) * Ts( n1, n2, cos1, cos2 ); // tau_01 * tau_12 (s-polarized)
	float beta_p = Tp( n0, n1, cos0, cos1 ) * Tp( n1, n2, cos1, cos2 ); // tau_01 * tau_12 (p-polarized)

	// Compute the phase term (phi)
	float phi = ( 2.0 * PI / lambda ) * ( 2.0 * n1 * thickness * cos1 ) + delta;

	// Evaluate the transmitted intensity for the two possible polarizations
	float ts = pow( beta_s, 2.0 ) / ( pow( alpha_s, 2.0 ) - 2.0 * alpha_s * cos( phi ) + 1.0 );
	float tp = pow( beta_p, 2.0 ) / ( pow( alpha_p, 2.0 ) - 2.0 * alpha_p * cos( phi ) + 1.0 );

	// Take into account conservation of energy for transmission
	float beamRatio = ( n2 * cos2 ) / ( n0 * cos0 );

	// Calculate the average transmitted intensity
	float t = beamRatio * ( ts + tp ) / 2;

	// Derive the reflected intensity
	return saturate( 1 - t );
}

float GetDevastation( float2 MapCoordinates )
{
	float Devastation = PdxTex2D( DevastationPollution, MapCoordinates ).r;
	Devastation += DevastationForceAdd;
	Devastation = CubicBezier( Devastation, DevastationBezierPoint1, DevastationBezierPoint2 );

	if( Devastation <= 0.0 )
	{
		return 0.0;
	}

	float2 DevastationCoords = float2( MapCoordinates.x * 2.0, MapCoordinates.y ) * DevastationNoiseTiling;
	float Noise = 1.0 - PdxTex2D( DevastationPollution, DevastationCoords ).a;
	Noise = lerp( 0.0, Noise, Devastation );
	Noise = LevelsScan( Noise, DevastationAreaPosition, DevastationAreaContrast );
	return Noise;
}

float GetDevastationExclusionMask( float2 MapCoordinates )
{
	// Exclusion mask
	float DevastationMask = PdxTex2D( DevastationPollution, float2( MapCoordinates.x, MapCoordinates.y ) ).b;
	DevastationMask = smoothstep( DevastationExclusionMaskMin, DevastationExclusionMaskMax, DevastationMask );
	return DevastationMask;
}

float GetPollution( float2 MapCoordinates )
{
	float Pollution = PdxTex2D( DevastationPollution, MapCoordinates ).g;
	Pollution += PollutionForceAdd;
	Pollution = CubicBezier( Pollution, PollutionBezierPoint1, PollutionBezierPoint2 );

	if( Pollution <= 0.0 )
	{
		return 0.0;
	}

	float2 PollutionCoords = float2( MapCoordinates.x * 2.0, MapCoordinates.y ) * PollutionNoiseTiling;
	float Noise = 1.0 - PdxTex2D( DevastationPollution, PollutionCoords ).a;
	Noise = lerp( 0.0, Noise, Pollution );
	Noise = LevelsScan( Noise, PollutionAreaPosition, PollutionAreaContrast );
	return Noise;
}

void ApplyDevastationMaterialVFX( inout float4 Diffuse, float DevastationMask, float2 UV, float2 TerrainBlendFactors )
{
	// Effect Properties
	float3 BurnColour = float3( 1.0, 0.3, 0.0 );

	float BorderEffectStrength = 7.0;

	float FireUVDistortionStrength = 0.5f;

	float2 PanSpeedA = float2( 0.005, 0.001 );
	float2 PanSpeedB = float2( 0.010, 0.005 );

	// UV & UV Panning Properties
	float2 UVPan02 = float2( -frac( GlobalTime * PanSpeedA.x ), frac( GlobalTime * PanSpeedA.y ) );
	float2 UVPan01 = float2( frac( GlobalTime * PanSpeedB.x ),  frac( GlobalTime * PanSpeedB.y ) );

	float2 UV02 = ( UV + 0.5 ) * 0.1;
	float2 UV01 = UV * 0.2;

	// Pan and Sample noise for UV distortion
	UV02 += UVPan02;
	float DevastationAlpha02 = PdxTex2D( DevastationPollution, float3( UV02, DevastationTexIndex + DevastationTexIndexOffset ) ).a;

	// Apply the UV Distortion
	UV01 += UVPan01;
	UV01 += DevastationAlpha02 * FireUVDistortionStrength;
	float DevastationAlpha01 = PdxTex2D( DevastationPollution, float3( UV01, DevastationTexIndex + DevastationTexIndexOffset ) ).a;

	// Adjust Mask Value ranges to clamp the effect
	DevastationAlpha01 = max( smoothstep( 0.1, 0.5, DevastationAlpha01 ), 0.88 );

	// Calculate the effect masks
	float BorderMask = saturate( saturate( TerrainBlendFactors.y - 0.4 ) - saturate( TerrainBlendFactors.y - 0.6 ) );
	BorderMask = saturate( TerrainBlendFactors.x * ( DevastationMask - 0.1 ) ) * DevastationAlpha01;
	BorderMask *= BorderEffectStrength * DevastationAlpha01;

	float FinalMask = BorderMask;

	BurnColour = PdxTex2D( DevastationVFXLUT , saturate( float2( FinalMask, FinalMask) ) ).rgb;

	float3 Result = lerp( Diffuse.rgb, BurnColour, FinalMask );

	Diffuse.rgb = Result;
}

void ApplyDevastationTrees( inout float4 Diffuse, float2 MapCoordinates )
{
	// Devastation area
	float Devastation = saturate( GetDevastation( MapCoordinates ) * 2.0 );
	if( Devastation <= 0.0 )
	{
		return;
	}

	// Diffuse coloration
	float3 DevastatedDiffuse = RGBtoHSV( Diffuse.rgb );
	DevastatedDiffuse.x += DevastationTreeHue;				// Hue
	DevastatedDiffuse.y *= DevastationTreeSaturation;		// Saturation
	DevastatedDiffuse.z *= DevastationTreeValue;			// Value
	DevastatedDiffuse = HSVtoRGB( DevastatedDiffuse );

	// Alpha
	float DevastatedAlpha = smoothstep( DevastationTreeAlphaReduce, 1.0, Diffuse.a );

	// Return
	Diffuse.a = lerp( Diffuse.a, DevastatedAlpha, Devastation );
	Diffuse.rgb = lerp( Diffuse.rgb, DevastatedDiffuse, Devastation );
}

void ApplyPollutionTrees( inout float4 Diffuse, float2 MapCoordinates )
{
	// Pollution area
	float Pollution = saturate( GetPollution( MapCoordinates ) * 2.0 );
	if( Pollution <= 0.0 )
	{
		return;
	}

	// Diffuse coloration
	float3 PollutedDiffuse = RGBtoHSV( Diffuse.rgb );
	PollutedDiffuse.x += PollutionTreeHue;				// Hue
	PollutedDiffuse.y *= PollutionTreeSaturation;		// Saturation
	PollutedDiffuse.z *= PollutionTreeValue;			// Value
	PollutedDiffuse = HSVtoRGB( PollutedDiffuse );

	// Alpha
	float PollutedAlpha = smoothstep( PollutionTreeAlphaReduce, 1.0, Diffuse.a );

	// Return
	Diffuse.a = lerp( Diffuse.a, PollutedAlpha, Pollution );
	Diffuse.rgb = lerp( Diffuse.rgb, PollutedDiffuse, Pollution );
}

void ApplyDevastationRoads( inout float4 Diffuse, float2 WorldSpacePosXZ )
{
	// UVs
	float2 MapCoordinates = WorldSpacePosXZ * _WorldSpaceToTerrain0To1;
	float2 DetailUV = CalcDetailUV( WorldSpacePosXZ ) * DevastationTextureTiling;

	// Devastation area
	float Devastation = saturate( GetDevastation( MapCoordinates ) * ROAD_DEVASTATION_MULT );

	if( Devastation <= 0.0 )
	{
		return;
	}

	// Diffuse coloration
	float3 DevastatedDiffuse = Overlay( Diffuse.rgb, ROAD_DEVASTATION_COLOR );
	Diffuse.rgb = lerp( Diffuse.rgb, DevastatedDiffuse, Devastation );

	// Terrain material blend
	float DevAlpha = PdxTex2D( DetailTextures, float3( DetailUV, DevastationTexIndex + DevastationTexIndexOffset ) ).a;
	DevAlpha = lerp( 1.0, DevAlpha, 1.0 - DevastationHeightWeight );
	Devastation = clamp( Devastation, 0.0, ROAD_DEVASTATION_MAX );
	float2 BlendFactors = CalcHeightBlendFactors( float2( 1.0, DevAlpha ), float2( 1.0 - Devastation, Devastation ), _DetailBlendRange * DevastationHeightContrast );

	// Return
	Diffuse.a = saturate( Diffuse.a - BlendFactors.y );
}

void ApplyDevastationWater( inout float3 Color, float2 WorldSpacePosXZ )
{
	// UVs
	float2 MapCoordinates = WorldSpacePosXZ * _WorldSpaceToTerrain0To1;
	float2 DetailUV = CalcDetailUV( WorldSpacePosXZ ) * DevastationTextureTiling;

	// Devastation area
	float Devastation = saturate( GetDevastation( MapCoordinates ) * WATER_DEVASTATION_MULT );
	if( Devastation <= 0.0 )
	{
		return;
	}

	Color = lerp( Color, WATER_DEVASTATION_COLOR, Devastation );
}

void ApplyDevastationShore( inout float3 Color, float2 WorldSpacePosXZ )
{
	// UVs
	float2 MapCoordinates = WorldSpacePosXZ * _WorldSpaceToTerrain0To1;
	float2 DetailUV = CalcDetailUV( WorldSpacePosXZ ) * DevastationTextureTiling;

	// Devastation area
	float Devastation = saturate( GetDevastation( MapCoordinates ) * SHORE_DEVASTATION_MULT );
	if( Devastation <= 0.0 )
	{
		return;
	}

	Color = Overlay( Color, SHORE_DEVASTATION_COLOR, Devastation );
}

void ApplyDevastationBuilding( inout float3 Diffuse, float2 WorldSpacePosXZ, float Height, float2 UV )
{
	// UVs
	float2 MapCoordinates = WorldSpacePosXZ * _WorldSpaceToTerrain0To1;
	float2 DetailUV = CalcDetailUV( float2( UV.x, UV.y * 2.0f ) ) * BUILDING_DEVASTATION_UV_SCALE;

	// Devastation area
	float Devastation = saturate( GetDevastation( MapCoordinates ) * BUILDING_DEVASTATION_MULT );
	if( Devastation <= 0.0 )
	{
		return;
	}

	// Diffuse
	float4 DevDiffuse = PdxTex2D( DetailTextures, float3( DetailUV, DevastationTexIndex + DevastationTexIndexOffset ) );
	float3 HSV_ = RGBtoHSV( DevDiffuse.rgb );
	HSV_.x += DevastationHue;					// Hue
	HSV_.y *= DevastationSaturation; 			// Saturation
	HSV_.z *= DevastationValue;					// Value
	DevDiffuse.rgb = HSVtoRGB( HSV_ );

	float TintBlend = ( smoothstep( BUILDING_DEVASTATION_HEIGHT_MIN, BUILDING_DEVASTATION_HEIGHT_MAX, ( 1.0 - Height ) * Devastation ) );
	Diffuse = lerp( Diffuse, DevDiffuse, TintBlend );
}

void ApplyDevastationDecal( inout float4 Diffuse, float2 WorldSpacePosXZ, float Blend )
{
	// UVs
	float2 MapCoordinates = WorldSpacePosXZ * _WorldSpaceToTerrain0To1;
	float2 DetailUV = CalcDetailUV( WorldSpacePosXZ ) * DevastationTextureTiling;

	// Devastation area
	float Devastation = saturate( GetDevastation( MapCoordinates ) );
	if( Devastation <= 0.0 )
	{
		return;
	}

	// Terrain material blend
	float DevAlpha = PdxTex2D( DetailTextures, float3( DetailUV, DevastationTexIndex + DevastationTexIndexOffset ) ).a;
	DevAlpha = lerp( 1.0, DevAlpha, 1.0 - DevastationHeightWeight );
	float2 BlendFactors = CalcHeightBlendFactors( float2( Blend, DevAlpha ), float2( 1.0 - Devastation, Devastation ), _DetailBlendRange * DevastationHeightContrast );

	// Diffuse coloration
	float3 DevastatedDiffuse = Overlay( Diffuse.rgb, DECAL_DEVASTATION_COLOR );
	Diffuse.rgb = lerp( Diffuse.rgb, DevastatedDiffuse, saturate( Devastation * DECAL_DEVASTATION_MULT ) );

	// Return
	Diffuse.a = saturate( Diffuse.a - BlendFactors.y );
}

void ApplyDevastationMaterial( inout float4 Diffuse, inout float3 Normal, inout float4 Properties, float2 WorldSpacePosXZ )
{
	// UVs
	float2 MapCoordinates = WorldSpacePosXZ * _WorldSpaceToTerrain0To1;
	float2 DetailUV = CalcDetailUV( WorldSpacePosXZ ) * DevastationTextureTiling;

	// Devastation area
	float Devastation = GetDevastation( MapCoordinates );
	Devastation = clamp( Devastation, 0.0, DevastationAreaMax );
	if( Devastation <= 0.0 )
	{
		return;
	}

	// Diffuse
	float4 DevDiffuse = PdxTex2D( DetailTextures, float3( DetailUV, DevastationTexIndex + DevastationTexIndexOffset ) );
	float3 HSV_ = RGBtoHSV( DevDiffuse.rgb );
	HSV_.x += DevastationHue;			// Hue
	HSV_.y *= DevastationSaturation; 	// Saturation
	HSV_.z *= DevastationValue;			// Value
	DevDiffuse.rgb = HSVtoRGB( HSV_ );

	// Normal
	float4 DevNormalRRxG = PdxTex2D( NormalTextures, float3( DetailUV, DevastationTexIndex + DevastationTexIndexOffset ) );
	float3 DevNormal = UnpackRRxGNormal( DevNormalRRxG ).xyz;

	// Properties
	float4 DevProperties = PdxTex2D( MaterialTextures, float3( DetailUV, DevastationTexIndex + DevastationTexIndexOffset ) );

	// Exclusion mask
	Devastation *= GetDevastationExclusionMask( MapCoordinates );

	// Terrain material blend
	Diffuse.a = lerp( 0.0, Diffuse.a, DevastationHeightWeight );
	DevDiffuse.a = lerp( 1.0, DevDiffuse.a, 1.0 - DevastationHeightWeight );
	float2 BlendFactors = CalcHeightBlendFactors( float2( Diffuse.a, DevDiffuse.a), float2( 1.0 - Devastation, Devastation ), _DetailBlendRange * DevastationHeightContrast );

	// Return
	Diffuse = Diffuse * BlendFactors.x + DevDiffuse * BlendFactors.y;

	// Apply VFX on the final Diffuse
	ApplyDevastationMaterialVFX(Diffuse, Devastation, DetailUV, BlendFactors );

	Normal = Normal * BlendFactors.x +  DevNormal * BlendFactors.y;
	Properties = Properties * BlendFactors.x + DevProperties * BlendFactors.y;
}

void ApplyPollutionMaterial( inout float4 Diffuse, inout float3 Normal, inout float4 Properties, float2 WorldSpacePosXZ, inout float IridescenceMask )
{
	// UVs
	float2 MapCoordinates = WorldSpacePosXZ * _WorldSpaceToTerrain0To1;
	float2 DetailUV = CalcDetailUV( WorldSpacePosXZ ) * PollutionTextureTiling;

	// Pollution area
	float Pollution = GetPollution( MapCoordinates );
	Pollution = Remap( Pollution, 0.0, 1.0, 0.0, PollutionAreaMax );
	if( Pollution <= 0.0 )
	{
		return;
	}

	// Diffuse
	float4 PolDiffuse = PdxTex2D( DetailTextures, float3( DetailUV, PollutionTexIndex + PollutionTexIndexOffset ) );

	float3 HSV_ = RGBtoHSV( Diffuse.rgb );
	HSV_.x += PollutionHue;			// Hue
	HSV_.y *= PollutionSaturation; 	// Saturation
	HSV_.z *= PollutionValue;		// Value
	float3 PollutedTerrain = HSVtoRGB( HSV_ );

	float Noise2 = GetPollution( MapCoordinates );
	Diffuse.rgb = lerp( Diffuse.rgb, PollutedTerrain, Noise2 );

	// Normal
	float4 PolNormalRRxG = PdxTex2D( NormalTextures, float3( DetailUV, PollutionTexIndex + PollutionTexIndexOffset ) );
	float3 PolNormal = UnpackRRxGNormal( PolNormalRRxG ).xyz;

	// Properties
	float4 PolProperties = PdxTex2D( MaterialTextures, float3( DetailUV, PollutionTexIndex + PollutionTexIndexOffset ) );

	// Exclusion mask
	float PollutionMask = PdxTex2D( DevastationPollution, float2( MapCoordinates.x, MapCoordinates.y ) ).b;
	PollutionMask = smoothstep( PollutionExclusionMaskMin, PollutionExclusionMaskMax, PollutionMask );
	Pollution *= PollutionMask;

	// Terrain material blend
	Diffuse.a = lerp( 0.0, Diffuse.a, PollutionHeightWeight );
	PolDiffuse.a = lerp( 1.0, PolDiffuse.a, 1.0 - PollutionHeightWeight );
	float2 BlendFactors = CalcHeightBlendFactors( float2( Diffuse.a, PolDiffuse.a), float2( 1.0 - Pollution, Pollution ), _DetailBlendRange * PollutionHeightContrast );
	BlendFactors.x += BlendFactors.y * ( 1.0f - PollutionAlpha );
	BlendFactors.y -= BlendFactors.y * ( 1.0f - PollutionAlpha );

	// Return
	Diffuse = Diffuse * BlendFactors.x + PolDiffuse * BlendFactors.y;
	Normal = Normal * BlendFactors.x + PolNormal * BlendFactors.y;
	Properties = Properties * BlendFactors.x + PolProperties * BlendFactors.y;
	IridescenceMask = BlendFactors.y;
}

void GetIridescense( inout SMaterialProperties MaterialProps, float NdotV, PdxTextureSamplerCube EnvironmentMap, float3 WorldSpacePos, inout float IridescenceMask )
{
	// UVs
	float2 MapCoordinates = WorldSpacePos.xz * _WorldSpaceToTerrain0To1;
	float2 DetailUV = CalcDetailUV( WorldSpacePos.xz ) * PollutionTextureTiling;

	// Pollution area
	float Pollution = GetPollution( MapCoordinates );
	Pollution = Remap( Pollution, 0.0, 1.0, 0.0, PollutionAreaMax );
	if( Pollution <= 0.0 )
	{
		return;
	}

	// Iridescense noise
	float2 Coords = float2( MapCoordinates.x * 2.0, MapCoordinates.y ) * IridescenseNoiseTiling;
	float Noise = PdxTex2D( DevastationPollution, Coords ).a;
	Noise = saturate( LevelsScan( Noise, IridescensePosition, IridescenseContrast ) );

	// Weight / Opactity
	IridescenceMask = IridescenceMask * IridescenseOpacity * Noise;

	float3 PolIridescence = MaterialProps._SpecularColor;
	#ifdef HIGH_QUALITY_SHADERS
		float thickness = abs( IridescenseThicknessMin * ( 1.0 - Noise ) + IridescenseThicknessmax * Noise );

		// Specular color
		PolIridescence.r = ThinFilmReflectance( NdotV, IridescenseRed, thickness, IridescenseMediumn, IridescenseFilmn, Iridescenseinternaln ); 		// Red
		PolIridescence.g = ThinFilmReflectance( NdotV, IridescenseGreen, thickness, IridescenseMediumn, IridescenseFilmn, Iridescenseinternaln ); 	// Green
		PolIridescence.b = ThinFilmReflectance( NdotV, IridescenseBlue, thickness, IridescenseMediumn, IridescenseFilmn, Iridescenseinternaln ); 	// Blue

		MaterialProps._SpecularColor = lerp( MaterialProps._SpecularColor, PolIridescence, IridescenceMask );
		MaterialProps._PerceptualRoughness = lerp( MaterialProps._PerceptualRoughness, IridescenseRoughness, IridescenceMask );
		MaterialProps._Roughness = RoughnessFromPerceptualRoughness( MaterialProps._PerceptualRoughness );
	#else
		// Wavelengths sin function
		PolIridescence.r = sin( 2.0 * PI * Noise / ( NdotV * IridescenseRed / 1000.0 ) ) * 0.5 + 0.5;		// Red
		PolIridescence.g = sin( 2.0 * PI * Noise / ( NdotV * IridescenseGreen / 1000.0 ) ) * 0.5 + 0.5;	// Gree
		PolIridescence.b = sin( 2.0 * PI * Noise / ( NdotV * IridescenseBlue / 1000.0 ) ) * 0.5 + 0.5;	// Blue
		PolIridescence *= 0.25f;

		MaterialProps._SpecularColor = lerp( MaterialProps._SpecularColor, PolIridescence, IridescenceMask );
		MaterialProps._PerceptualRoughness = lerp( MaterialProps._PerceptualRoughness, IridescenseRoughness, IridescenceMask );
		MaterialProps._Roughness = RoughnessFromPerceptualRoughness( MaterialProps._PerceptualRoughness );
	#endif
}

void CalculateIridescenceRimlight( SMaterialProperties MaterialProps, SLightingProperties LightingProps, inout float3 SpecularLight, float IridescenceMask )
{
	float3 RimlightVector = normalize( IridescenseRimlightDirection );
	float3 H = normalize( RimlightVector - CameraLookAtDir );
	float NdotL = saturate( dot( MaterialProps._Normal, RimlightVector ) );
	float NdotH = saturate( dot( MaterialProps._Normal, H ) );
	float3 LightIntensity = LightingProps._LightIntensity * NdotL * LightingProps._ShadowTerm;

	// Sun specular light
	float D = D_GGX( NdotH, lerp( 0.03f , 1.0 , MaterialProps._Roughness ) ); 			// Remap to avoid super small and super bright highlights
	float3 SpecularLightRim = D * MaterialProps._SpecularColor * LightIntensity * IridescenseRimlightStrength;

	SpecularLight = SpecularLight + SpecularLightRim;
}


#ifndef FOG_OF_WAR_BLEND_FUNCTION
	#define FOG_OF_WAR_BLEND_FUNCTION loc_BlendFogOfWar
	float4 loc_BlendFogOfWar( float Alpha )
	{
		return float4( vec3(0.0), 1.0 - Alpha );
	}
#endif

void loc_ApplyFogOfWarPattern( inout float Alpha, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
	if( FogOfWarPatternStrength > 0.0f )
	{
		float2 UV = Coordinate.xz * InverseWorldSize * FogOfWarPatternTiling;
		UV += FogOfWarPatternSpeed * FogOfWarTime;
		float Noise1 = 1.0f - PdxTex2D( FogOfWarAlphaMask, UV ).g;
		float Noise2 = 1.0f - PdxTex2D( FogOfWarAlphaMask, UV * -0.13 ).g;
		float Detail = 0.5f;
		
		float Noise = saturate( Noise2 * (1.0f-Detail) + Detail * 0.5f + (Noise1-0.5f) * Detail );
		
		Noise *= 1.0f - Alpha;
		Alpha = smoothstep( 0.0, 1.0, Alpha + Noise * FogOfWarPatternStrength );
	}
}
float GetFogOfWarAlpha( in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{		
	float Alpha = PdxTex2D( FogOfWarAlphaMask, Coordinate.xz * InverseWorldSize ).r;
	
	loc_ApplyFogOfWarPattern( Alpha, Coordinate, FogOfWarAlphaMask );
	
	return FogOfWarAlphaMin + Alpha * (1.0f - FogOfWarAlphaMin);
}
float GetFogOfWarAlphaMultiSampled( in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
	float Width = 5.0f;
	float Alpha = 0.0f; 
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 0,-1) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2(-1, 0) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 1, 0) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 0, 1) * Width ) * InverseWorldSize ).r;
	Alpha /= 4.0f;
	
	loc_ApplyFogOfWarPattern( Alpha, Coordinate, FogOfWarAlphaMask );
	
	return FogOfWarAlphaMin + Alpha * (1.0f - FogOfWarAlphaMin);
}

float3 FogOfWarBlend( float3 Color, float Alpha )
{		
	float4 ColorAndAlpha = FOG_OF_WAR_BLEND_FUNCTION( Alpha );
	return lerp( Color, ColorAndAlpha.rgb, ColorAndAlpha.a );
}

// Immediate mode
float3 JominiApplyFogOfWar( in float3 Color, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return Color;
#else
	float Alpha = GetFogOfWarAlpha( Coordinate, FogOfWarAlphaMask );
	return FogOfWarBlend( Color, Alpha );
#endif
}
float3 JominiApplyFogOfWarMultiSampled( in float3 Color, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return Color;
#else
	float Alpha = GetFogOfWarAlphaMultiSampled( Coordinate, FogOfWarAlphaMask );
	return FogOfWarBlend( Color, Alpha );
#endif
}

// Post process
float4 JominiApplyFogOfWar( in float3 WorldSpacePos, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return float4( vec3(0.0), 1.0 );
#else
	return FOG_OF_WAR_BLEND_FUNCTION( GetFogOfWarAlpha( WorldSpacePos, FogOfWarAlphaMask ) );
#endif
}

#ifndef ApplyFogOfWar		
#define ApplyFogOfWar JominiApplyFogOfWar
#endif
#ifndef ApplyFogOfWarMultiSampled		
#define ApplyFogOfWarMultiSampled JominiApplyFogOfWarMultiSampled
#endif

#define FowFadeEnd			150.0
#define FowFadeStart		101.0


float SampleFowNoiseLowSpec( in float3 Coordinate )
{
		// Uv tiling
		float2 MasterUVTiling = _FoWMasterUVTiling * Coordinate.xz * InverseWorldSize;
		MasterUVTiling.x *= _FoWMasterUVScale.x;
		MasterUVTiling.y *= _FoWMasterUVScale.y;
		float2 UV = MasterUVTiling * _FoWLayer1Tiling;

		// Animation
		float2 AnimUV = float2(_FoWLayer1Speed.x * _FoWMasterUVSpeed.x, _FoWLayer1Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		UV += AnimUV * _FoWMasterUVScale;

		// Layer sample
		float Layer1 = PdxTex2D( FogOfWarNoise, UV ).r;
		Layer1 = smoothstep( _FoWLayer1Min, _FoWLayer1Max, Layer1 );

		// Detail noise blending
		float Cloud = smoothstep( _FoWLayer1Min, _FoWLayer1Max, Layer1 );
		return Cloud;
}

float SampleFowNoise( in float3 Coordinate, inout float3 Normal )
{
		// Uv tiling and animation
		float2 MasterUVTiling = _FoWMasterUVTiling * Coordinate.xz * InverseWorldSize;

		// Scale
		MasterUVTiling.x *= _FoWMasterUVScale.x;
		MasterUVTiling.y *= _FoWMasterUVScale.y;

		float2 UV = MasterUVTiling * _FoWLayer1Tiling;
		float2 UV2 = MasterUVTiling * _FoWLayer2Tiling;
		float2 UV3 = MasterUVTiling * _FoWLayer3Tiling;

		// Animation
		float2 AnimUV = float2(_FoWLayer1Speed.x * _FoWMasterUVSpeed.x, _FoWLayer1Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		float2 AnimUV2 = float2(_FoWLayer2Speed.x * _FoWMasterUVSpeed.x, _FoWLayer2Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		float2 AnimUV3 = float2(_FoWLayer3Speed.x * _FoWMasterUVSpeed.x, _FoWLayer3Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		UV += AnimUV * _FoWMasterUVScale;
		UV2 += AnimUV2 * _FoWMasterUVScale;
		UV3 +=AnimUV3 * _FoWMasterUVScale;

		// Layers sample
		float Layer1 = PdxTex2D( FogOfWarNoise, UV ).g;
		float Layer2 = PdxTex2D( FogOfWarNoise, UV2 ).g;
		float Layer3 = PdxTex2D( FogOfWarNoise, UV3 ).g;

		// Layers min/max adjustment
		Layer1 = smoothstep( _FoWLayer1Min, _FoWLayer1Max, Layer1 );
		Layer2 = smoothstep( _FoWLayer2Min, _FoWLayer2Max, Layer2 );
		Layer3 = smoothstep( _FoWLayer3Min, _FoWLayer3Max, Layer3 );

		// Detail noise blending
		float Cloud = Overlay(Layer1, Layer2, _FoWLayer2Balance );
		Cloud = Overlay(Cloud, Layer3, _FoWLayer3Balance );

		Normal = PdxTex2D( FogOfWarNormal, UV ).xzy - 0.5;
		Normal.xz *= _CloudNormalStrength;
		Normal = saturate( Normal );

		return Cloud;
}

float SampleFowReflection( in float2 Coordinate )
{
		// Uv tiling and animation
		float2 MasterUVTiling = _FoWMasterUVTiling * Coordinate * InverseWorldSize;

		// Scale
		MasterUVTiling.x *= _FoWMasterUVScale.x;
		MasterUVTiling.y *= _FoWMasterUVScale.y;

		float2 UV = MasterUVTiling * _FoWLayer1Tiling;
		float2 UV2 = MasterUVTiling * _FoWLayer2Tiling;
		float2 UV3 = MasterUVTiling * _FoWLayer3Tiling;

		// Animation
		float2 AnimUV = float2(_FoWLayer1Speed.x * _FoWMasterUVSpeed.x, _FoWLayer1Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		float2 AnimUV2 = float2(_FoWLayer2Speed.x * _FoWMasterUVSpeed.x, _FoWLayer2Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		float2 AnimUV3 = float2(_FoWLayer3Speed.x * _FoWMasterUVSpeed.x, _FoWLayer3Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		UV += AnimUV * _FoWMasterUVScale;
		UV2 += AnimUV2 * _FoWMasterUVScale;
		UV3 +=AnimUV3 * _FoWMasterUVScale;

		// Layers sample
		float Layer1 = PdxTex2D( FogOfWarNoise, UV ).g;
		float Layer2 = PdxTex2D( FogOfWarNoise, UV2 ).g;
		float Layer3 = PdxTex2D( FogOfWarNoise, UV3 ).g;

		// Layers min/max adjustment
		Layer1 = smoothstep( _FoWLayer1Min, _FoWLayer1Max, Layer1 );
		Layer2 = smoothstep( _FoWLayer2Min, _FoWLayer2Max, Layer2 );
		Layer3 = smoothstep( _FoWLayer3Min, _FoWLayer3Max, Layer3 );

		// Detail noise blending
		float Cloud = Overlay(Layer1, Layer2, _FoWLayer2Balance );
		Cloud = Overlay(Cloud, Layer3, _FoWLayer3Balance );

		return Cloud;
}

float SampleFowNoiseShadow( in float3 Coordinate )
{

		// Uv tiling and animation
		float2 MasterUVTiling = _FoWMasterUVTiling * Coordinate.xz * InverseWorldSize;

		// Scale
		MasterUVTiling.x *= _FoWMasterUVScale.x;
		MasterUVTiling.y *= _FoWMasterUVScale.y;

		float2 UV = MasterUVTiling * _FoWLayer1Tiling;
		float2 UV2 = MasterUVTiling * _FoWLayer2Tiling;
		float2 UV3 = MasterUVTiling * _FoWLayer3Tiling;

		// Animation
		float2 AnimUV = float2(_FoWLayer1Speed.x * _FoWMasterUVSpeed.x, _FoWLayer1Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		float2 AnimUV2 = float2(_FoWLayer2Speed.x * _FoWMasterUVSpeed.x, _FoWLayer2Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		float2 AnimUV3 = float2(_FoWLayer3Speed.x * _FoWMasterUVSpeed.x, _FoWLayer3Speed.y * _FoWMasterUVSpeed.y) * FogOfWarTime * 0.01f;
		UV += AnimUV * _FoWMasterUVScale;
		UV2 += AnimUV2 * _FoWMasterUVScale;
		UV3 +=AnimUV3 * _FoWMasterUVScale;

		// Layers sample
		float Layer1 = PdxTex2D( FogOfWarNoise, UV ).a;
		float Layer2 = PdxTex2D( FogOfWarNoise, UV2 ).a;
		float Layer3 = PdxTex2D( FogOfWarNoise, UV3 ).a;

		// Layers min/max adjustment
		Layer1 = LevelsScan( Layer1, _FowShadowLayer1Min, _FowShadowLayer1Max);
		Layer2 = LevelsScan( Layer2, _FowShadowLayer2Min, _FowShadowLayer2Max);
		Layer3 = LevelsScan( Layer3, _FowShadowLayer3Min, _FowShadowLayer3Max);

		// Detail noise blending
		float Cloud = Overlay(Layer1, Layer2 );
		Cloud = Overlay(Cloud, Layer3 );

		return Cloud;
}

float3 GameApplyFogOfWar( in float3 Color, in float3 Coordinate, float ShadowMultiplier = 1.0 )
{
	#ifdef PDX_DEBUG_FOW_OFF
		return Color;
	#endif

	#ifdef JOMINI_DISABLE_FOG_OF_WAR
		return Color;
	#endif

	// Alpha fade
	float FadeStart = FowFadeEnd - FowFadeStart;
	float DistanceBlend = FadeStart - CameraPosition.y + FowFadeStart;
	DistanceBlend = RemapClamped( DistanceBlend, 0.0, FadeStart, 0.0, 1.0 );

	float Alpha = 1.0 - PdxTex2D( FogOfWarAlpha, Coordinate.xz * InverseWorldSize ).r;
	Alpha = lerp( Alpha, 0.0, DistanceBlend );

	#ifdef PDX_DEBUG_FOW_MASK
		return float4( Alpha.rrr, 1.0f );
	#endif
	if( _FoWShowAlphaMask > 0.0f )
	{
		return vec3( 1.0f - Alpha );
	}

	float ShadowAlpha = smoothstep( _FoWShadowAlphaStart, _FoWShadowAlphaStop, Alpha ) * _FoWShadowColor.a;
	float CloudsAlpha = smoothstep( _FoWCloudsAlphaStart, _FoWCloudsAlphaStop, Alpha ) * _FoWCloudsColor.a;

	// Paralax offset
	float3 ToCam = normalize( CameraPosition - Coordinate );
	float ParalaxDist = ( _FoWCloudHeight - Coordinate.y ) / ToCam.y;
	float3 ParalaxCoord = Coordinate + ToCam * ParalaxDist;

	// Sun shadow offset
	float ShadowCordDist = ( _FoWCloudHeight - Coordinate.y ) / ToSunDir.y;
	Coordinate =  Coordinate + ToSunDir * ShadowCordDist;

	// Cloud and shadow texture
	float3 Normal = float3( 0.0, 1.0, 0.0 );
	#ifdef LOW_QUALITY_SHADERS
		float CloudTex = smoothstep( _FoWMasterStart, _FoWMasterStop, SampleFowNoiseLowSpec( ParalaxCoord ) );
		float ShadowTex = smoothstep( _FoWShadowTexStart, _FoWShadowTexStop, SampleFowNoiseLowSpec( Coordinate ) );
	#else
		float CloudTex = smoothstep( _FoWMasterStart, _FoWMasterStop, SampleFowNoise( ParalaxCoord, Normal ) );
		float ShadowTex = smoothstep( _FoWShadowTexStart, _FoWShadowTexStop, SampleFowNoiseShadow( Coordinate ) );
	#endif

	// Apply clouds
	float GradientControlDay = smoothstep( _FoWCloudsColorDayGradientMin, _FoWCloudsColorDayGradientMax, CloudTex );
	float3 CloudsColor = lerp( _FoWCloudsColorGradient.rgb, _FoWCloudsColor.rgb, GradientControlDay ) ;

	float GradientControlSunset = smoothstep( _FoWCloudsColorSunsetGradientMin, _FoWCloudsColorSunsetGradientMax, CloudTex );
	float3 CloudsColorSunset = lerp( _FoWCloudsColorSunsetGradient.rgb, _FoWCloudsColorSunset.rgb, GradientControlSunset );

	float GradientControlNight = smoothstep( _FoWCloudsColorNightGradientMin, _FoWCloudsColorNightGradientMax, CloudTex );
	float3 CloudsColorNight = lerp( _FoWCloudsColorNightGradient.rgb, _FoWCloudsColorNight.rgb, GradientControlNight );

	// Apply sunset and night color
	float SunsetValue = 0.0;
	float SunsetValueClose = 0.0;
	if ( _DayNightValue >= 0.5 )
	{
		SunsetValue = 1.0;
		SunsetValueClose = 1.0;
	}
	else
	{
		SunsetValue = Remap( _DayNightValue, 0.0f, 0.5, 0.0, 1.0 );
		SunsetValueClose = RemapClamped( _DayNightValue, _CloudSunsetColorValueMin, _CloudSunsetColorValueMax, 0.0, 1.0 );
	}
	CloudsColor = lerp( CloudsColor, CloudsColorSunset, SunsetValue );
	CloudsColor = lerp( CloudsColor, CloudsColorNight, SunsetValueClose );

	// Normal calculation
	float SunsetIntensityValue = smoothstep( 0.5, 1.0, SunsetValue );
	float SunValue = lerp( 1.0, 0.0, SunsetIntensityValue );
	float NightIntensityValue = smoothstep( 0.0, 0.5, _NightValue );
	SunValue = lerp( SunValue, 1.0, NightIntensityValue );
	float3 SunDir = ToSunDir;
	float NdotL = saturate( dot( Normal, SunDir ) + 1e-5 );
	CloudsColor *= _CloudAmbientValue;
	float CloudBrightScale = saturate( smoothstep( _CloudLightMin, _CloudLightMax, NdotL ) );
	CloudsColor += ( CloudsColor * CloudBrightScale * SunValue * _CloudLightMultiplier );

	// Apply Fog of war and cloud shadow
	float3 FinalColor = lerp( Color, _FoWShadowColor.rgb, _FoWShadowMult * ShadowAlpha );					// Fow darkness
	FinalColor = lerp( FinalColor, _FoWShadowColor.rgb, _FoWShadowMult * ShadowTex * ShadowMultiplier * SunValue );	// Cloud Shadow
	FinalColor = lerp( FinalColor, CloudsColor, CloudTex * CloudsAlpha );

	return FinalColor;
}
// Post process
float4 GameApplyFogOfWar( in float3 WorldSpacePos, PdxTextureSampler2D FogOfWarAlphaMask )
{
	#ifdef PDX_DEBUG_FOW_OFF
	return vec4(0);
	#endif

	float Alpha = GetFogOfWarAlpha( WorldSpacePos, FogOfWarAlphaMask );

	#ifdef PDX_DEBUG_FOW_MASK
	return float4( Alpha.rrr, 1.0f );
	#endif

	return FOG_OF_WAR_BLEND_FUNCTION( Alpha );
}

#undef ApplyFogOfWar
#define ApplyFogOfWar GameApplyFogOfWar

		#define LAND_COLOR ToLinear( HSVtoRGB( float3( 0.11f, 0.06f, 0.89f ) ) )
		#define HIGHLIGHT_RANGE 0.5f

		int SampleCountryIndex( float2 MapCoords )
		{
			float2 ColorIndex = PdxTex2D( ProvinceColorIndirectionTexture, MapCoords ).rg;
			int Index = ColorIndex.x * 255.0 + ColorIndex.y * 255.0 * 256.0;
			return PdxReadBuffer( ProvinceCountryIdBuffer, Index ).r;
		}

		void ApplyStripeColorBlend( float2 MapCoords, float2 ParalaxCoord, inout float3 Color, inout float PreLightingBlend )
		{
			// Coat of arms should only be shown in some map modes
			if( !_MapCoaEnabled )
			{
				return;
			}

			int CountryId = SampleCountryIndex( MapCoords );
			if( CountryId >= 0 )
			{
				float Opacity = 1.0f;
				#ifdef HIGH_QUALITY_SHADERS
					float2 Texel = vec2( 1.0f ) / _ProvinceMapSize;
					float2 Pixel = ( MapCoords * _ProvinceMapSize + 0.5 );
					float2 FracCoord = frac( Pixel );
					Pixel = floor( Pixel ) / _ProvinceMapSize - Texel * 0.5f;
					float C00 = 1.0f - saturate( abs( CountryId - SampleCountryIndex( Pixel ) ) );
					float C10 = 1.0f - saturate( abs( CountryId - SampleCountryIndex( Pixel + float2( Texel.x, 0.0 ) ) ) );
					float C01 = 1.0f - saturate( abs( CountryId - SampleCountryIndex( Pixel + float2( 0.0, Texel.y ) ) ) );
					float C11 = 1.0f - saturate( abs( CountryId - SampleCountryIndex( Pixel + Texel ) ) );
					float x0 = lerp( C00, C10, FracCoord.x );
					float x1 = lerp( C01, C11, FracCoord.x );
					Opacity = RemapClamped( lerp( x0, x1, FracCoord.y ), 0.5f, 0.75f, 0.0f, 1.0f );
				#endif

				float4 StripeColor = PdxTex2DLoad0( CountryColors, int2( CountryId, 0 ) );

				Opacity *= ( _MapCoaBlendOccupation * ( 1.0f - _FlatmapLerp ) ) + ( _MapCoaBlendOccupationFlatmap * _FlatmapLerp );

				float FadeStart = ( _MapCoaBlendFadeStart - _MapCoaBlendFadeEnd );
				float CloseZoomBlend = FadeStart - CameraPosition.y + ( _MapCoaBlendFadeEnd );
				CloseZoomBlend = smoothstep( FadeStart, 0.0f, CloseZoomBlend );
				Opacity *= CloseZoomBlend;

				float StripeScale = lerp( _MapCoaStripeScale, _MapCoaStripeScaleFlatmap, _FlatmapLerp );
				Opacity *= CalculateStripeMask( MapCoords, 0.0, StripeScale );

				float Gradient = 1.0 - PdxTex2D( HighlightGradient, MapCoords ).g;
				float GradientAdd = LevelsScan( Gradient, OCCUPATION_HIGHLIGHT_POSITION, OCCUPATION_HIGHLIGHT_CONTRAST );
				float HighlightAlpha = GradientAdd * Gradient;
				float3 HighlightColor = StripeColor.rgb * OCCUPATION_HIGHLIGHT_COLOR_MULT;

				PreLightingBlend = saturate( Opacity + PreLightingBlend + HighlightAlpha);

				Color = lerp( Color, StripeColor.rgb, Opacity );
				Color = lerp( Color, saturate( HighlightColor ), saturate( HighlightAlpha * OCCUPATION_HIGHLIGHT_STRENGTH ) * OCCUPATION_HIGHLIGHT_ALPHA );
			}
		}

		void ApplyCoaColorBlend( float2 MapCoords, float2 ParalaxCoord, inout float3 Color, inout float PreLightingBlend )
		{
			// Coat of arms should only be shown in some map modes
			if( !_MapCoaEnabled )
			{
				return;
			}

			// Provinces where Controller == Owner will have CountryId -1
			int CountryId = SampleCountryIndex( MapCoords );
			if( CountryId >= 0 )
			{
				float Opacity = 1.0f;
				#ifdef HIGH_QUALITY_SHADERS
					float2 Texel = vec2( 1.0f ) / _ProvinceMapSize;
					float2 Pixel = ( MapCoords * _ProvinceMapSize + 0.5 );
					float2 FracCoord = frac( Pixel );
					Pixel = floor( Pixel ) / _ProvinceMapSize - Texel * 0.5f;
					float C00 = 1.0f - saturate( abs( CountryId - SampleCountryIndex( Pixel ) ) );
					float C10 = 1.0f - saturate( abs( CountryId - SampleCountryIndex( Pixel + float2( Texel.x, 0.0 ) ) ) );
					float C01 = 1.0f - saturate( abs( CountryId - SampleCountryIndex( Pixel + float2( 0.0, Texel.y ) ) ) );
					float C11 = 1.0f - saturate( abs( CountryId - SampleCountryIndex( Pixel + Texel ) ) );
					float x0 = lerp( C00, C10, FracCoord.x );
					float x1 = lerp( C01, C11, FracCoord.x );
					Opacity = RemapClamped( lerp( x0, x1, FracCoord.y ), 0.5f, 0.75f, 0.0f, 1.0f );
				#endif
				float4 FlagUvs = PdxReadBuffer4( CountryCoaUvBuffer, CountryId );
				float2 CoaSize = _FlatmapLerp < 0.5f ? float2( _MapCoaSize, _MapCoaSize / _MapCoaAspectRatio ) : float2( _MapCoaSizeFlatmap, _MapCoaSizeFlatmap / _MapCoaAspectRatio );
				float2 CoaUV = ParalaxCoord * _ProvinceMapSize / CoaSize;

				// Rotate
				float2 Rotation = float2( cos( _MapCoaAngle ), sin( _MapCoaAngle ) );
				CoaUV.x *= _MapCoaAspectRatio;
				CoaUV = float2( CoaUV.x * Rotation.x - CoaUV.y * Rotation.y, CoaUV.x * Rotation.y + CoaUV.y * Rotation.x );
				CoaUV.x /= _MapCoaAspectRatio;

				float2 CoaDdx = ddx( CoaUV );
				float2 CoaDdy = ddy( CoaUV );

				// Offset rows horizontally
				CoaUV.x += _MapCoaRowOffset * int( mod( CoaUV.y, _MapCoaRowCount ) );

				// Tile, flip, and scale to match the atlas
				CoaUV = frac( CoaUV );
				CoaUV.y = 1.0f - CoaUV.y;
				CoaUV = FlagUvs.xy + CoaUV * FlagUvs.zw;

				// First blend in gradient border color on top of CoA color
				// Then adjust the border blend value so that CoA is always shown regardless of gradient
				float3 CoaColor = PdxTex2DGrad( CoaAtlas, CoaUV, CoaDdx, CoaDdy ).rgb;
				CoaColor = ToLinear( CoaColor );

				Opacity *= ( _MapCoaBlend * ( 1.0f - _FlatmapLerp ) ) + ( _MapCoaBlendFlatmap * _FlatmapLerp );

				float FadeStart = ( _MapCoaBlendFadeStart - _MapCoaBlendFadeEnd );
				float CloseZoomBlend = FadeStart - CameraPosition.y + ( _MapCoaBlendFadeEnd );
				CloseZoomBlend = smoothstep( FadeStart, 0.0f, CloseZoomBlend );
				Opacity *= CloseZoomBlend;

				PreLightingBlend = max( Opacity, PreLightingBlend );

				// Occupation highlight
				float Gradient = 1.0 - PdxTex2D( HighlightGradient, MapCoords ).g;
				float GradientAdd = LevelsScan( Gradient, OCCUPATION_HIGHLIGHT_POSITION, OCCUPATION_HIGHLIGHT_CONTRAST );
				float HighlightAlpha = Opacity * GradientAdd * Gradient;
				float3 HighlightColor = Color * OCCUPATION_HIGHLIGHT_COLOR_MULT;

				Color = lerp( Color, saturate( CoaColor ), Opacity );
				Color = lerp( Color, saturate( HighlightColor ), saturate( HighlightAlpha * OCCUPATION_HIGHLIGHT_STRENGTH ) * OCCUPATION_HIGHLIGHT_ALPHA );
			}
 		}

		void ApplyMapTextureAndAlpha( inout float3 Color, inout float alpha, float Mask, float2 UV, int index )
		{
			float4 MapTexture = PdxTex2D( MapPaintingTextures, float3( UV, index ) );
			Color = lerp( Color, MapTexture.rgb, Mask * MapTexture.a );
			alpha = lerp( alpha, alpha * MapTexture.a, Mask );
		}

		void GameProvinceOverlayAndBlend( float2 ColorMapCoords, float3 WorldSpacePos, out float3 ColorOverlay, out float PreLightingBlend, out float PostLightingBlend )
		{
			// Paralx Coord
			float3 ToCam = normalize( CameraPosition - WorldSpacePos );
			float ParalaxDist = ( _ImpassableTerrainHeight - WorldSpacePos.y ) / ToCam.y;
			float3 ParalaxCoord = WorldSpacePos + ToCam * ParalaxDist;
			ParalaxCoord.xz = ParalaxCoord.xz * _WorldSpaceToTerrain0To1;

			// Gradient border values
			float DistanceFieldValue = CalcDistanceFieldValue( ColorMapCoords );
			float Edge = smoothstep( GB_EdgeWidth + max( 0.001f, GB_EdgeSmoothness ), GB_EdgeWidth, DistanceFieldValue );
			float GradientAlpha = lerp( GB_GradientAlphaInside, GB_GradientAlphaOutside, RemapClamped( DistanceFieldValue, GB_EdgeWidth + GB_GradientWidth, GB_EdgeWidth, 0.0f, 1.0f ) );

			// Default color
			ColorOverlay = LAND_COLOR;
			float4 ProvinceOverlayColorWithAlpha = vec4( 0.0f );

			// Color textures
			float4 PrimaryColor = BilinearColorSample( ColorMapCoords, IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture );
			float4 SecondaryColor = BilinearColorSampleAtOffset( ColorMapCoords, IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, SecondaryProvinceColorsOffset );
			float4 AlternateColor = BilinearColorSampleAtOffset( ColorMapCoords, IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, AlternateProvinceColorsOffset );

			// Land/Ocean/Lake masks
			float LandMask = PdxTex2DLod0( LandMaskMap, float2( ColorMapCoords.x, 1.0f - ColorMapCoords.y ) ).r;
			float EndLandMask = 0.0f;
			float ShoreLinesStripes = 0.0f;

			// Primary as texture or color
			if ( !_UseMapmodeTextures )
			{
				// Get color
				ProvinceOverlayColorWithAlpha = AlphaBlendAOverB( PrimaryColor, SecondaryColor );
				ProvinceOverlayColorWithAlpha.rgb = lerp( ProvinceOverlayColorWithAlpha.rgb * GB_GradientColorMul, ProvinceOverlayColorWithAlpha.rgb * GB_EdgeColorMul, Edge );
				ProvinceOverlayColorWithAlpha.a = ProvinceOverlayColorWithAlpha.a * max( GradientAlpha, GB_EdgeAlpha * Edge );

				// Apply decentralized country color
				float4 DecentralizedColor = _DecentralizedCountryColor;
				float DecentralizedMask = saturate( 1.0f - Edge );

				DecentralizedColor.rgb = _DecentralizedCountryColor.rgb;
				DecentralizedColor.a *= AlternateColor.g;
				DecentralizedMask = DecentralizedMask * DecentralizedColor.a * _FlatmapLerp;
				ProvinceOverlayColorWithAlpha = lerp( ProvinceOverlayColorWithAlpha, DecentralizedColor, DecentralizedMask );

				// Apply impassable terrain color
				float4 ImpassableDiffuse = float4( PdxTex2D( ImpassableTerrainTexture, float2( ParalaxCoord.x * 2.0f, 1.0f - ParalaxCoord.z ) * _ImpassableTerrainTiling ).rgb,  AlternateColor.r );
				ImpassableDiffuse.rgb = Lighten( ImpassableDiffuse.rgb, _ImpassableTerrainColor.rgb );
				float ImpassableMask = ImpassableDiffuse.a * _ImpassableTerrainColor.a * ( 1.0f - _FlatmapLerp );

				// Fade impassable close
				float FadeStart = ( _DistanceFadeStart - _DistanceFadeEnd );
				float CloseZoomBlend = FadeStart - CameraPosition.y + _DistanceFadeEnd;
				CloseZoomBlend = smoothstep( FadeStart, 0.0f, CloseZoomBlend );
				ImpassableMask *= CloseZoomBlend;
				ProvinceOverlayColorWithAlpha = lerp( ProvinceOverlayColorWithAlpha, ImpassableDiffuse, ImpassableMask );

				// Get blendmode
				GetGradiantBorderBlendValues( ProvinceOverlayColorWithAlpha, PreLightingBlend, PostLightingBlend );

				// Apply impassable terrain blendmode
				PreLightingBlend = lerp( PreLightingBlend, 0.0f, ImpassableMask );
				PostLightingBlend = lerp( PostLightingBlend, 1.0f, ImpassableMask );

				// Apply output
				ColorOverlay = ProvinceOverlayColorWithAlpha.rgb;
			}
			else
			{
				float2 MapTextureUvSize = _FlatmapLerp < 0.5f ? _MapPaintingTextureTiling : _MapPaintingFlatmapTextureTiling;
				float2 MapTextureUv = float2( ParalaxCoord.x * 2.0f, 1.0f - ParalaxCoord.z ) * MapTextureUvSize;

				// Offset rows horizontally
				MapTextureUv.x += MAPMODE_UV_ROW_OFFSET * int( mod( MapTextureUv.y, MAPMODE_UV_ROW_COUNT ) );

				float MapTextureAlpha = 1.0f;
				float AlphaMask = 0.0f;

				if ( !_UsePrimaryRedAsGradient )
				{
					ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, PrimaryColor.r, MapTextureUv, 0 );
					AlphaMask += PrimaryColor.r;
				}
				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, PrimaryColor.g, MapTextureUv, 1 );
				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, PrimaryColor.b, MapTextureUv, 2 );
				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, PrimaryColor.a, MapTextureUv, 3 );

				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, SecondaryColor.r, MapTextureUv, 4 );
				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, SecondaryColor.g, MapTextureUv, 5 );
				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, SecondaryColor.b, MapTextureUv, 6 );
				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, SecondaryColor.a, MapTextureUv, 7 );

				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, AlternateColor.r, MapTextureUv, 8 );
				ApplyMapTextureAndAlpha( ColorOverlay, MapTextureAlpha, AlternateColor.g, MapTextureUv, 9 );

				AlphaMask += PrimaryColor.g + PrimaryColor.b + PrimaryColor.a;
				AlphaMask += SecondaryColor.r + SecondaryColor.g + SecondaryColor.b + SecondaryColor.a;
				AlphaMask += AlternateColor.r + AlternateColor.g;
				AlphaMask = saturate( AlphaMask * MapTextureAlpha );

				ProvinceOverlayColorWithAlpha.a = lerp( ProvinceOverlayColorWithAlpha.a, 1.0f, AlphaMask );

				ColorOverlay = lerp( ColorOverlay * GB_GradientColorMul, ColorOverlay * GB_EdgeColorMul, Edge );
				ProvinceOverlayColorWithAlpha.a = ProvinceOverlayColorWithAlpha.a * max( GradientAlpha * ( 1.0f - pow( Edge, 2 ) ), GB_EdgeAlpha * Edge );

				GetGradiantBorderBlendValues( ProvinceOverlayColorWithAlpha, PreLightingBlend, PostLightingBlend );
			}

			// Apply stylised noise
			#ifndef LOW_QUALITY_SHADERS
				#if defined( TERRAIN_FLAT_MAP ) || defined( TERRAIN_FLAT_MAP_LERP )
					float DetailScale1 = 10.0f;
					float DetailScale2 = 3.0f;
					float DetailTexture1 = PdxTex2D( FlatmapNoiseMap, float2( ( ColorMapCoords.x * DetailScale1 * 2.0f ), 1.0f - ( ColorMapCoords.y * DetailScale1 ) ) ).g;
					float DetailTexture2 = PdxTex2D( FlatmapNoiseMap, float2( ( ColorMapCoords.x * DetailScale2 * 2.0f ), 1.0f - ( ColorMapCoords.y * DetailScale2 ) ) ).g;
					float DetailTexture3 = GetOverlay( DetailTexture1,  DetailTexture2, 1.0f );

					// Don't blend in mapmodes
					if ( !_UseMapmodeTextures )
					{
						ColorOverlay = saturate( GetOverlay( ColorOverlay, vec3( 1.0f - DetailTexture3 ), _FlatmapLerp ) );
					}
				#endif
			#endif

			if ( _UseStripeOccupation == true )
			{
				ApplyStripeColorBlend( ColorMapCoords, ParalaxCoord.xz, ColorOverlay, PreLightingBlend );
			}
			else
			{
				ApplyCoaColorBlend( ColorMapCoords, ParalaxCoord.xz, ColorOverlay, PreLightingBlend );
			}

			PreLightingBlend *= _OverlayOpacity;
			PostLightingBlend *= _OverlayOpacity;
		}

		float3 ApplyDynamicFlatmap( float3 FlatmapDiffuse, float2 ColorMapCoords, float2 WorldSpacePosXZ )
		{
			float ExtentStr = _ShorelineExtentStr;
			float Alpha = _ShorelineAlpha;
			float UVScale = _ShoreLinesUVScale;

			#ifndef LOW_QUALITY_SHADERS
				float MaskBlur = _ShorelineMaskBlur;
				float LandMaskBlur = PdxTex2DLod( LandMaskMap, float2( ColorMapCoords.x, 1.0f - ColorMapCoords.y ), MaskBlur ).r;
				float ShoreLines = PdxTex2D( FlatmapNoiseMap, ColorMapCoords * UVScale ).r;
				ShoreLines *= saturate( Alpha );
			#endif

			float LandMask = 0.0f;
			float ShoreLinesStripes = 0.0f;

			float4 AlternateColor = BilinearColorSampleAtOffset( ColorMapCoords, IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, AlternateProvinceColorsOffset );
			AlternateColor.rg = vec2( 0.0f ); // Zero out unused channels to avoid issues
			float4 LakeColor = float4( 0.0f, 0.0f, 0.0f, 1.0f ); // Needs to match color in mappaintingmanager.cpp
			float4 SeaColor = float4( 0.0f, 0.0f, 1.0f, 0.0f );	// Needs to match color in mappaintingmanager.cpp
			float4 LakeDiff = LakeColor - AlternateColor;
			float4 SeaDiff = SeaColor - AlternateColor;
			float4 LakeSeaDiff = dot( LakeDiff, LakeDiff ) * dot( SeaDiff, SeaDiff );

			// Land color
			float3 Land = LAND_COLOR;
			float OutlineValue = 1.0f - smoothstep( 0.75f, 1.0f, LakeSeaDiff );
			Land = lerp( Land, FlatmapDiffuse, OutlineValue );

			// Not a lake and doesn't have water mass
			if( dot( LakeDiff, LakeDiff ) > 0.1f )
			{
				#ifndef LOW_QUALITY_SHADERS
					ShoreLinesStripes = saturate( LandMaskBlur * ShoreLines * _ShorelineExtentStr );
				#endif
				ShoreLinesStripes = saturate( ShoreLinesStripes * _ShorelineAlpha );
				ShoreLinesStripes = clamp( ShoreLinesStripes, 0.0, 0.5f );
				FlatmapDiffuse = lerp( FlatmapDiffuse, vec3( 0.0f ), ShoreLinesStripes );

				// Not sea, so apply land mask
				if( dot( SeaDiff, SeaDiff ) > 0.1f )
				{
					LandMask = LakeSeaDiff;
				}
			}

			// Blends in shorelines/flatmap color adjustments
			FlatmapDiffuse = lerp( FlatmapDiffuse, Land, LandMask );

			return FlatmapDiffuse;
		}

		// Convenicence function for changing blend modes in all shaders
		float3 ApplyColorOverlay( float3 Color, float3 ColorOverlay, float Blend )
		{
			float3 HSV_ = RGBtoHSV( ColorOverlay.rgb );
			HSV_.x += 0.0f;		// Hue
			HSV_.y *= 0.95f; 	// Saturation
			HSV_.z *= 0.35f;	// Value
			ColorOverlay.rgb = lerp( ColorOverlay.rgb, HSVtoRGB( HSV_ ), 1.0f - _FlatmapLerp );

			Color = lerp( Color, ColorOverlay, Blend );
			return Color;
		}

		float3 ApplyHighlight( float3 Color, float2 Coordinate )
		{
			float Gradient = PdxTex2D( HighlightGradient, Coordinate ).r;

			float SingleSamplingSafeDistance = 0.49f;
			float4 HighlightColor = vec4( 0 );
			if( abs( 0.5f - PdxTex2D( HighlightGradient, Coordinate ).r ) > SingleSamplingSafeDistance )
			{
				// Optimisation - We can use the gradient to quickly gauge where it's safe to use a single sample
				// If the gradient is close to 0.5 then there is a color change somewhere nearby, and multi sampling is needed.
				// Otherwise a single sample will do
				HighlightColor = ColorSampleAtOffset( Coordinate, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
			}
			else
			{
			#ifdef HIGH_QUALITY_SHADERS
				// Lots of double samples here
				// There's no meassurable difference between this naive implementation and a bespoke
				// implementation for reducing the number of samples (on GTX 1080Ti) so assuming the
				// the texture cache is able to handle this just fine.
				// Naive implementation reduces code duplication and makes code simpler
				float2 Offset = InvIndirectionMapSize;
				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2( -1, -1 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2(  0, -1 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2(  1, -1 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );

				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2( -1,  0 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2(  0,  0 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2(  1,  0 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );

				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2( -1,  1 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2(  0,  1 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
				HighlightColor += BilinearColorSampleAtOffset( Coordinate + Offset * float2(  1,  1 ), IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
				HighlightColor /= 9.0f;
			#else
				HighlightColor = BilinearColorSampleAtOffset( Coordinate, IndirectionMapSize, InvIndirectionMapSize, ProvinceColorIndirectionTexture, ProvinceColorTexture, HighlightProvinceColorsOffset );
			#endif
			}

			HighlightColor.a *= 1.0f - Gradient;
			HighlightColor.a = RemapClamped( HighlightColor.a, 0.0f, HIGHLIGHT_RANGE, 0.0f, 1.0f );

			Color = lerp( Color, HighlightColor.rgb, HighlightColor.a );
			return Color;
		}
	float ApplyOpacity( float BaseAlpha, float2 NoiseCoordinate, in uint InstanceIndex )
{
#ifdef JOMINI_MAP_OBJECT
	float Opacity = UnpackAndGetMapObjectOpacity( InstanceIndex );
#else
	float Opacity = PdxMeshGetOpacity( InstanceIndex );
#endif
	return PdxMeshApplyOpacity( BaseAlpha, NoiseCoordinate, Opacity );
}



// === Main Code === 

#define DIFFUSE_UV_SET Input.UV0
#define NORMAL_UV_SET Input.UV0
#define PROPERTIES_UV_SET Input.UV0
#define UNIQUE_UV_SET Input.UV1

PS_COLOR_SSAO main( VS_OUTPUT Input, bool PDX_IsFrontFace : SV_IsFrontFace )
{
	PS_COLOR_SSAO Out;

	#ifdef UNDERWATER
		clip( _WaterHeight - Input.WorldSpacePos.y + 0.1 ); // +0.1 to avoid gap between water and mesh
	#endif

	float2 MapCoords = Input.WorldSpacePos.xz * _WorldSpaceToTerrain0To1;
	float2 ProvinceCoords = Input.WorldSpacePos.xz / _ProvinceMapSize;
	float LocalHeight = Input.WorldSpacePos.y - GetHeight( Input.WorldSpacePos.xz );

	float4 Diffuse = PdxTex2D( DiffuseMap, DIFFUSE_UV_SET );
	float4 Properties = PdxTex2D( PropertiesMap, PROPERTIES_UV_SET );

	// Alpha
	Diffuse.a = ApplyOpacity( Diffuse.a, Input.Position.xy, Input.InstanceIndex );
	#ifdef ALPHA_TO_COVERAGE
		Diffuse.a = RescaleAlphaByMipLevel( Diffuse.a, DIFFUSE_UV_SET, DiffuseMap );
		Diffuse.a = SharpenAlpha( Diffuse.a, 0.5f );
	#endif
	clip( Diffuse.a - 0.001f );

	// Normal calculation
	float4 NormalSample = PdxTex2D( NormalMap, NORMAL_UV_SET );
	float3 InNormal = normalize( Input.Normal );
	float3x3 TBN = Create3x3( normalize( Input.Tangent ), normalize( Input.Bitangent ), InNormal );
	float3 Normal = normalize( mul( UnpackRRxGNormal( NormalSample ), TBN ) );

	// Devastation
	ApplyDevastationBuilding( Diffuse.rgb, Input.WorldSpacePos.xz, LocalHeight, DIFFUSE_UV_SET );

	// Revolution flag
	#ifdef REVOLUTIONFLAG
			#if defined( IG_USERDATA )
				uint InterestGroupColorIndex = GetUserDataUint( Input.InstanceIndex );
				float4 InterestGroupColor = GetInterestGroupColorUserdata( InterestGroupColorIndex );
			#else
				float4 InterestGroupColor = GetInterestGroupColorDefine();
			#endif
		Diffuse.rgb = Overlay( Diffuse.rgb, ToLinear( HSVtoRGB( InterestGroupColor.rgb ) ) );
	#endif

	// Baked AO
	#if defined( TINT_COLOR )
		float4 Unique = PdxTex2D( TintMap, UNIQUE_UV_SET );
		Diffuse.rgb = Overlay( Diffuse.rgb, Unique.rgb );
	#endif

	// Bottom tint effetc
	float TintAngleModifier = saturate( 1.0 - dot( InNormal, float3( 0.0, 1.0, 0.0 ) ) );	// Removes tint from angles facing upwards
	float TintBlend = ( 1.0 - smoothstep( _MeshTintHeightMin, _MeshTintHeightMax, LocalHeight ) ) * _MeshTintColor.a * TintAngleModifier;
	Diffuse.rgb = lerp(  Diffuse.rgb, Overlay( Diffuse.rgb, _MeshTintColor.rgb ), TintBlend );

	// Colormap blend, pre light
	#if defined( COLORMAP )
		float3 ColorMap = PdxTex2D( ColorTexture, float2( MapCoords.x, 1.0 - MapCoords.y ) ).rgb;
		Diffuse.rgb = SoftLight( Diffuse.rgb, ColorMap, ( 1 - Properties.r ) );
	#endif

	// Color overlay, pre light
	#ifndef UNDERWATER
		#ifndef NO_BORDERS
			float3 ColorOverlay;
			float PreLightingBlend;
			float PostLightingBlend;
			GameProvinceOverlayAndBlend( ProvinceCoords, Input.WorldSpacePos, ColorOverlay, PreLightingBlend, PostLightingBlend );
			Diffuse.rgb = ApplyColorOverlay( Diffuse.rgb, ColorOverlay, PreLightingBlend );
		#endif
	#endif

	// Light and shadow
	float3 Color = Diffuse.rgb;
	Properties.a = ScaleRoughnessByDistance( Properties.a, Input.WorldSpacePos );
	SMaterialProperties MaterialProps = GetMaterialProperties( Diffuse.rgb, Normal, Properties.a, Properties.g, Properties.b );
	SLightingProperties LightingProps = GetSunLightingProperties( Input.WorldSpacePos, ShadowMap );
	#ifndef LOW_QUALITY_SHADERS
		#ifndef FLATLIGHT
			Color = CalculateSunLighting( MaterialProps, LightingProps, EnvironmentMap );

			// Second sun
			#ifndef SINGLESUN
				SLightingProperties SecondLightingProps = GetSecondSunLightingProperties( Input.WorldSpacePos );
				float3 SecondSunColor = CalculateSecondSunLighting( MaterialProps, SecondLightingProps );
				Color += SecondSunColor;
			#endif
		#endif
	#endif
	#if defined( EMISSIVE_NIGHT ) || defined( EMISSIVE_NIGHT_RANDOM )
			float ActivationThreshold = 0.05;
			float ShouldActivate = 1.0;
			float4 LightColor = _NightLightColor;

			#if defined( HUB_BUILDING )
				ActivationThreshold = GetUserDataRandomValueCity( Input.InstanceIndex );
				#if defined( EMISSIVE_NIGHT_RANDOM )
					ShouldActivate = clamp( GetUserDataShouldLightActivate( Input.InstanceIndex ), 0.0f, 1.0f );
				#endif
				LightColor = GetUserDataBuildingLightColor( Input.InstanceIndex );
			#endif

			float DayNightModifier = Remap( _DayNightValue, _LightsActivateBegin, _LightsActivateEnd, 0.0, 1.0 );
			float LightValue = saturate( Remap( DayNightModifier, ActivationThreshold, _LightsFadeTime + ActivationThreshold, 0.0, 1.0 ) );
			if ( DayNightModifier > ActivationThreshold )
			{
				Color += NormalSample.b * LightColor.rgb * LightColor.a * LightValue * ShouldActivate;
			}
	#endif

	// Effects, post light
	#ifndef UNDERWATER
		#ifndef NO_BORDERS
			Color = ApplyColorOverlay( Color, ColorOverlay, PostLightingBlend );
		#endif
		#ifndef NO_FOG
			if( _FlatmapLerp < 1.0 )
			{
				float3 Unfogged = Color;
				Color = ApplyFogOfWar( Color, Input.WorldSpacePos );
				Color = GameApplyDistanceFog( Color, Input.WorldSpacePos );
				Color = lerp( Color, Unfogged, _FlatmapLerp );
			}
		#endif
	#endif

	// Refraction
	#ifdef UNDERWATER
		Diffuse.a = CompressWorldSpace( Input.WorldSpacePos );
	#endif

	// Province Highlight
	Color = ApplyHighlight( Color, ProvinceCoords );

	// Flatmap
	#ifdef FLATMAP
	 	float LandMask = PdxTex2DLod0( LandMaskMap, float2( MapCoords.x, 1.0 - MapCoords.y ) ).r;
		Diffuse.a *= ( 1.0 - ( LandMask * ( 1.0 - _FlatmapOverlayLandOpacity ) ) );
	#endif

	// Debug
	DebugReturn( Color, MaterialProps, LightingProps, EnvironmentMap );

	// Output
	Out.Color = float4( Color, Diffuse.a );
	float3 SSAOColor_ = _SSAOColorMesh.rgb + GameCalculateDistanceFogFactor( Input.WorldSpacePos );
	#ifndef UNDERWATER
		#ifndef NO_BORDERS
			SSAOColor_ = SSAOColor_ + PostLightingBlend;
		#endif
	#endif
	Out.SSAOColor = float4( saturate ( SSAOColor_ ), Diffuse.a);

	return Out;
}

