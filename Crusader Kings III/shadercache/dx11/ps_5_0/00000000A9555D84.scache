

// === Shader Info === 

// Shader file: gfx/FX/cw/particle2.shader
// Effect: ParticleColor



// === Defines === 

#define PDX_DIRECTX_11
#define PIXEL_SHADER
#define PDX_HLSL
#define VENDOR_NVIDIA
#define PDX_MAX_HEIGHTMAP_COMPRESS_LEVELS 5
#define JOMINI_REFRACTION_ENABLED
#define PDX_WINDOWS


// === HLSL Macros === 

#define PDX_POSITION SV_Position
#define PDX_COLOR SV_Target
#define PDX_COLOR0 SV_Target0
#define PDX_COLOR0_SRC1 SV_Target1 // Use this when doing dual source blending, currently only supports that for render target #0
#define PDX_COLOR1 SV_Target1
#define PDX_COLOR2 SV_Target2
#define PDX_COLOR3 SV_Target3
#define PDX_COLOR4 SV_Target4
#define PDX_COLOR5 SV_Target5
#define PDX_COLOR6 SV_Target6
#define PDX_COLOR7 SV_Target7
#define PDX_VertexID SV_VertexID
#define PDX_InstanceID SV_InstanceID
#define PDX_DispatchThreadID SV_DispatchThreadID
#define PDX_GroupThreadID SV_GroupThreadID
#define PDX_GroupID SV_GroupID
#define PDX_GroupIndex SV_GroupIndex
#define PDX_TessFactor SV_TessFactor
#define PDX_InsideTessFactor SV_InsideTessFactor
#define PDX_OutputControlPointID SV_OutputControlPointID
#define PDX_DomainLocation SV_DomainLocation
#define PDX_RenderTargetArrayIndex SV_RenderTargetArrayIndex
#define PDX_ViewportArrayIndex SV_ViewportArrayIndex

#define PdxDomainTypeTriangle "tri"
#define PdxDomainTypeQuad "quad"
#define PdxDomainTypeIsoline "isoline"

#define PdxPartitioningModeInteger "integer"
#define PdxPartitioningModeFractionalEven "fractional_even"
#define PdxPartitioningModeFractionalOdd "fractional_odd"

#define PdxPrimitiveTypePoint point
#define PdxPrimitiveTypeLine line
#define PdxPrimitiveTypeTriangle triangle
#define PdxPrimitiveTypeLineAdjacency lineadj
#define PdxPrimitiveTypeTriangleAdjacency triangleadj

#define PdxTessellatorOutputTopologyPoint "point"
#define PdxTessellatorOutputTopologyLine "line"
#define PdxTessellatorOutputTopologyTriangleCw "triangle_cw"
#define PdxTessellatorOutputTopologyTriangleCcw "triangle_ccw"

#define PdxMeshShaderOutputTopologyLine "line"
#define PdxMeshShaderOutputTopologyTriangle "triangle"

#define mod( X, Y ) ( (X) % (Y) )

float2x2 Create2x2( in float2 x, in float2 y )
{
	return transpose( float2x2( x, y ) );
}
// TODO, Create3x3 should be transposed in hlsl, and not in glsl, and then the mul() arguments should be reversed
#define Create3x3 float3x3
float4x4 Create4x4( in float4 x, in float4 y, in float4 z, in float4 w )
{
	return transpose( float4x4( x, y, z, w ) );
}

#define GetMatrixData( Matrix, row, col ) ( Matrix [ row ] [ col ] )

float3x3 CastTo3x3( in float4x4 M )
{
	return (float3x3)M;
}

#define lessThan( a, b ) ( (a) < (b) )

float2 vec2(float vValue) { return float2(vValue, vValue); }
float3 vec3(float vValue) { return float3(vValue, vValue, vValue); }
float4 vec4(float vValue) { return float4(vValue, vValue, vValue, vValue); }


struct PdxTextureSampler2D
{
    Texture2D 		_Texture;
    SamplerState 	_Sampler;
};
struct PdxTextureSampler2DMS
{
    Texture2DMS<float4>		_Texture;
};

struct PdxTextureSampler2DArray
{
    Texture2DArray	_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSampler3D
{
    Texture3D 		_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSamplerCube
{
    TextureCube 	_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSampler2DCmp
{
    Texture2D 				_Texture;
    SamplerComparisonState 	_Sampler;
};

// These are for separate Texture/Sampler objects
#define PdxSampleTex2D(tex,samp,uv) (tex).Sample( (samp), (uv) )
#define PdxSampleTex2DLod(tex,samp,uv,lod) (tex).SampleLevel( (samp), (uv), (lod) )
#define PdxSampleTex2DGrad(tex,samp,uv,ddx,ddy) (tex).SampleGrad( (samp), (uv), (ddx), (ddy) )
#define PdxSampleTex2DGather(tex,samp,uv) (tex).Gather( (samp), (uv) )

#define PdxSampleTex3D(tex,samp,uv) (tex).Sample( (samp), (uv) )
#define PdxSampleTex3DLod(tex,samp,uv,lod) (tex).SampleLevel( (samp), (uv), (lod) )

#define PdxTexture2DSize(tex,size) (tex).GetDimensions( (size).x, (size).y )
#define PdxTexture2DLoad(tex,uv,lod) (tex).Load( int3((uv), (lod)) )

#define PdxTexture2DArraySize(tex,size,elements) (tex).GetDimensions( (size).x, (size).y, elements )

#define PdxTexture3DSize(tex,size) (tex).GetDimensions( (size).x, (size).y, (size).z )
#define PdxTexture3DLoad(tex,uv,lod) (tex).Load( int4((uv), (lod)) )

// These are for the combined TextureSampler objects
#define PdxTex2DSize(samp,size) PdxTexture2DSize( (samp)._Texture, (size) )
#define PdxTex2D(samp,uv) PdxSampleTex2D( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex2DLod(samp,uv,lod) PdxSampleTex2DLod( (samp)._Texture, (samp)._Sampler, (uv), (lod) )
#define PdxTex2DLodOffset(samp,uv,lod,offset) (samp)._Texture.SampleLevel( (samp)._Sampler, (uv), (lod), (offset) )
#define PdxTex2DBias(samp,uv,bias) (samp)._Texture.SampleBias( (samp)._Sampler, (uv), (bias) )
#define PdxTex2DGrad(samp,uv,ddx,ddy) PdxSampleTex2DGrad( (samp)._Texture, (samp)._Sampler, (uv), (ddx), (ddy) )
#define PdxTex2DGather(samp,uv) PdxSampleTex2DGather( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex2DLoad(samp,uv,lod) PdxTexture2DLoad( (samp)._Texture, (uv), (lod) )
#define PdxTex2DMultiSampled(samp,texelcoord,sampleidx) (samp)._Texture.Load( (texelcoord), (sampleidx) )
#define PdxTex2DMSSize(samp,size,samples) (samp)._Texture.GetDimensions( (size).x, (size).y, (samples) )

#define PdxTex3D(samp,uv) PdxSampleTex3D( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex3DLod(samp,uv,lod) PdxSampleTex3DLod( (samp)._Texture, (samp)._Sampler, (uv), (lod) )
#define PdxTex3DLoad(samp,uv,lod) PdxTexture3DLoad( (samp)._Texture, (uv), (lod) )

#define PdxTexCube(samp,uv) (samp)._Texture.Sample( (samp)._Sampler, (uv) )
#define PdxTexCubeLod(samp,uv,lod) (samp)._Texture.SampleLevel( (samp)._Sampler, (uv), (lod) )
#define PdxTexCubeBias(samp,uv,bias) (samp)._Texture.SampleBias( (samp)._Sampler, (uv), (bias) )

#define PdxTex2DCmpLod0(samp,uv,value) (samp)._Texture.SampleCmpLevelZero( (samp)._Sampler, (uv), (value) )

// Vulkan fails to compile shaders with this function call properly
// Commenting it out until we can fix this issue
//#define PdxCalculateLod(samp,uv) (samp)._Texture.CalculateLevelOfDetail( (samp)._Sampler, (uv) )

float4x4 FixProjection( float4x4 ProjectionMatrix )
{
	// Enable for "debug" drawing to see if some objects is missing fix
	#if 0
	for ( int i = 0; i < 4; ++i )
	{
		GetMatrixData( ProjectionMatrix, 0, i ) *= 0.5;
		GetMatrixData( ProjectionMatrix, 1, i ) *= 0.5;
	}
	#endif
	
	return ProjectionMatrix;
}

#define PdxBufferFloat  Buffer<float>
#define PdxBufferFloat2	Buffer<float2>
#define PdxBufferFloat3	Buffer<float3>
#define PdxBufferFloat4	Buffer<float4>
#define PdxBufferInt  	Buffer<int>
#define PdxBufferInt2	Buffer<int2>
#define PdxBufferInt3	Buffer<int3>
#define PdxBufferInt4	Buffer<int4>
#define PdxBufferUint   Buffer<uint>
#define PdxBufferUint2	Buffer<uint2>
#define PdxBufferUint3	Buffer<uint3>
#define PdxBufferUint4	Buffer<uint4>

#define PdxStructuredBuffer StructuredBuffer
#define PdxRWStructuredBuffer RWStructuredBuffer
#define PdxRasterizerOrderedBuffer RasterizerOrderedBuffer
#define PdxRasterizerOrderedStructuredBuffer RasterizerOrderedStructuredBuffer

float 	PdxReadBuffer( in PdxBufferFloat Buf, int Index )  		{ return Buf.Load( Index ); }
float2	PdxReadBuffer2( in PdxBufferFloat2 Buf, int Index )		{ return Buf.Load( Index ); }
float3	PdxReadBuffer3( in PdxBufferFloat3 Buf, int Index )		{ return Buf.Load( Index ); }
float4	PdxReadBuffer4( in PdxBufferFloat4 Buf, int Index )		{ return Buf.Load( Index ); }

int  	PdxReadBuffer( in PdxBufferInt Buf, int Index ) 		{ return Buf.Load( Index ); }
int2 	PdxReadBuffer2( in PdxBufferInt2 Buf, int Index )		{ return Buf.Load( Index ); }
int3 	PdxReadBuffer3( in PdxBufferInt3 Buf, int Index )    	{ return Buf.Load( Index ); }
int4 	PdxReadBuffer4( in PdxBufferInt4 Buf, int Index )    	{ return Buf.Load( Index ); }

uint  	PdxReadBuffer( in PdxBufferUint Buf, int Index )    	{ return Buf.Load( Index ); }
uint2 	PdxReadBuffer2( in PdxBufferUint2 Buf, int Index )  	{ return Buf.Load( Index ); }
uint3 	PdxReadBuffer3( in PdxBufferUint3 Buf, int Index )  	{ return Buf.Load( Index ); }
uint4 	PdxReadBuffer4( in PdxBufferUint4 Buf, int Index )  	{ return Buf.Load( Index ); }

#define PdxReadRWBuffer(buffer,index) (buffer)[(index)]
#define PdxWriteRWBuffer(buffer,index,value) (buffer)[(index)] = (value)

#define UINT16_MAX 0xffff
#define PI 3.14159265359

float2x2 Create2x2( float a, float b, float c, float d ) { return Create2x2( float2( a, b ), float2( c, d ) ); }

#define PdxSampleTex2DLod0(tex,samp,uv) PdxSampleTex2DLod( (tex), (samp), (uv), 0 )

#define PdxTexture2DLoad0(tex,uv) PdxTexture2DLoad( (tex), (uv), 0 )

#define PdxTex2DProj(samp,uv_proj) PdxTex2DLod0( (samp), (uv_proj).xy / (uv_proj).w )
#define PdxTex2DLod0(samp,uv) PdxTex2DLod( (samp), (uv), 0 )
#define PdxTex2DLod0Offset(samp,uv,offset) PdxTex2DLodOffset( (samp), (uv), 0, (offset) )
#define PdxTex2DLoad0(samp,uv) PdxTex2DLoad( (samp), (uv), 0 )

#define PdxTex3DLod0(samp,uv) PdxTex3DLod( (samp), (uv), 0 )
#define PdxTex3DLoad0(samp,uv) PdxTex3DLoad( (samp), (uv), 0 )

float4 FixProjectionAndMul( float4x4 ProjectionMatrix, float4 Vector )
{
	return mul( FixProjection( ProjectionMatrix ), Vector );
}



// === Vertex Structs === 

struct VS_INPUT_PARTICLE
{
	float2 UV0 : TEXCOORD0;
	float4 Pos : TEXCOORD1;
	float4 RotQ : TEXCOORD2;
	float2 Size : TEXCOORD3;
	float3 BillboardAxis : TEXCOORD4;
	float4 Color : TEXCOORD5;
};
struct VS_OUTPUT_PARTICLE
{
	float4 Pos : PDX_POSITION;
	float4 Color : COLOR;
	float2 UV0 : TEXCOORD0;
	float3 WorldSpacePos : TEXCOORD1;
};
struct PS_COLOR_SSAO
{
	float4 Color : PDX_COLOR0;
	float4 SSAOColor : PDX_COLOR1;
};


// === Constant Buffers === 

cbuffer pdx_hlsl_cb53
{
	float4x4 ViewProjectionMatrix;
	float4x4 InvViewProjectionMatrix;
	float4x4 ViewMatrix;
	float4x4 InvViewMatrix;
	float4x4 ProjectionMatrix;
	float4x4 InvProjectionMatrix;
	float4x4 ShadowMapTextureMatrix;
	float3 CameraPosition;
	float ZNear;
	float3 CameraLookAtDir;
	float ZFar;
	float3 CameraUpDir;
	float CameraFoV;
	float3 CameraRightDir;
	float _UpscaleLodBias;
	float _UpscaleLodBiasNative;
	float _UpscaleLodBiasMultiplier;
	float _UpscaleLodBiasMultiplierNative;
	float _UpscaleLodBiasEnabled;
}
cbuffer pdx_hlsl_cb35
{
	int2 FlipbookDimensions;
}
cbuffer pdx_hlsl_cb17
{
	float3 AmbientPosX;
	float CubemapIntensity;
	float3 AmbientNegX;
	float3 AmbientPosY;
	float3 AmbientNegY;
	float3 AmbientPosZ;
	float3 AmbientNegZ;
	float3 ShadowAmbientPosX;
	float3 ShadowAmbientNegX;
	float3 ShadowAmbientPosY;
	float3 ShadowAmbientNegY;
	float3 ShadowAmbientPosZ;
	float3 ShadowAmbientNegZ;
	float FogMax;
	float3 SunDiffuse;
	float SunIntensity;
	float3 ToSunDir;
	float FogBegin2;
	float3 FogColor;
	float FogEnd2;
	float4x4 CubemapYRotation;
	float TreeSwayLoopSpeed;
	float TreeSwayWindStrengthSpatialModifier;
	float TreeSwaySpeed;
	float TreeSwayWindClusterSizeModifier;
	float3 TreeSwayWorldDirection;
	float TreeHeightImpactOnSway;
	float TreeSwayScale;
}
cbuffer pdx_hlsl_cb9
{
	float2 FogOfWarAlphaMapSize;
	float2 InverseWorldSize;
	float2 FogOfWarPatternSpeed;
	float FogOfWarPatternStrength;
	float FogOfWarPatternTiling;
	float FogOfWarTime;
	float FogOfWarAlphaMin;
}


// === Samplers === 

SamplerState _sampler_0_ : register(s0);


// === Textures === 

Texture2D DiffuseMap_Texture;
static PdxTextureSampler2D DiffuseMap = { DiffuseMap_Texture, _sampler_0_ };
Texture2D FogOfWarAlpha_Texture;
static PdxTextureSampler2D FogOfWarAlpha = { FogOfWarAlpha_Texture, _sampler_0_ };


// === RW Textures === 



// === Buffer Textures === 



// === RW Buffer Textures === 



// === Shader Code === 

float CalcViewSpaceDepth( float Depth )
{
	Depth = 2.0 * Depth - 1.0;
	float ZLinear = 2.0 * ZNear * ZFar / (ZFar + ZNear - Depth * (ZFar - ZNear));
	return ZLinear;
}

float3 ViewSpacePosFromDepth( float Depth, float2 UV )
{
	float x = UV.x * 2.0 - 1.0;
	float y = (1.0 - UV.y) * 2.0 - 1.0;
	
	float4 ProjectedPos = float4( x, y, Depth, 1.0 );
	
	float4 ViewSpacePos = mul( InvProjectionMatrix, ProjectedPos );
	
	return ViewSpacePos.xyz / ViewSpacePos.w;
}

float3 WorldSpacePositionFromDepth( float Depth, float2 UV )
{
	float3 WorldSpacePos = mul( InvViewMatrix, float4( ViewSpacePosFromDepth( Depth, UV ), 1.0 ) ).xyz;		
	return WorldSpacePos;  
}
float3 QRotVector( float4 RotQ, float3 V )
{
	return V + 2.0 * cross( RotQ.xyz, cross( RotQ.xyz, V ) + RotQ.w * V );
}

float2 CalcCellUV( float2 UV, int Columns, int Rows, float Time )
{
	int TotalFrames = ( Columns * Rows );
	uint CurrentFrame = uint( TotalFrames * Time );
	float2 CellUV;
	CellUV.x = float( CurrentFrame % Columns ) / Columns;
	CellUV.y = float( CurrentFrame / Columns ) / Rows;
	
	UV.x = ( UV.x / Columns );
	UV.y = ( UV.y / Rows );
	
	return CellUV + UV;
}
float CalculateDistanceFogFactor( float3 WorldSpacePos )
{
	float3 Diff = CameraPosition - WorldSpacePos;
	float vFogFactor = 1.0 - abs( normalize( Diff ).y ); // abs b/c of reflections
	float vSqDistance = dot( Diff, Diff );

	float vMin = min( ( vSqDistance - FogBegin2 ) / ( FogEnd2 - FogBegin2 ), FogMax );
	return saturate( vMin * vFogFactor );
}

float3 ApplyDistanceFog( float3 Color, float vFogFactor )
{
	return lerp( Color, FogColor, vFogFactor );
}

float3 ApplyDistanceFog( float3 Color, float3 WorldSpacePos )
{
	return ApplyDistanceFog( Color, CalculateDistanceFogFactor( WorldSpacePos ) );
}

#ifndef FOG_OF_WAR_BLEND_FUNCTION
	#define FOG_OF_WAR_BLEND_FUNCTION loc_BlendFogOfWar
	float4 loc_BlendFogOfWar( float Alpha )
	{
		return float4( vec3(0.0), 1.0 - Alpha );
	}
#endif

void loc_ApplyFogOfWarPattern( inout float Alpha, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
	if( FogOfWarPatternStrength > 0.0f )
	{
		float2 UV = Coordinate.xz * InverseWorldSize * FogOfWarPatternTiling;
		UV += FogOfWarPatternSpeed * FogOfWarTime;
		float Noise1 = 1.0f - PdxTex2D( FogOfWarAlphaMask, UV ).g;
		float Noise2 = 1.0f - PdxTex2D( FogOfWarAlphaMask, UV * -0.13 ).g;
		float Detail = 0.5f;
		
		float Noise = saturate( Noise2 * (1.0f-Detail) + Detail * 0.5f + (Noise1-0.5f) * Detail );
		
		Noise *= 1.0f - Alpha;
		Alpha = smoothstep( 0.0, 1.0, Alpha + Noise * FogOfWarPatternStrength );
	}
}
float GetFogOfWarAlpha( in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{		
	float Alpha = PdxTex2D( FogOfWarAlphaMask, Coordinate.xz * InverseWorldSize ).r;
	
	loc_ApplyFogOfWarPattern( Alpha, Coordinate, FogOfWarAlphaMask );
	
	return FogOfWarAlphaMin + Alpha * (1.0f - FogOfWarAlphaMin);
}
float GetFogOfWarAlphaMultiSampled( in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
	float Width = 5.0f;
	float Alpha = 0.0f; 
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 0,-1) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2(-1, 0) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 1, 0) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 0, 1) * Width ) * InverseWorldSize ).r;
	Alpha /= 4.0f;
	
	loc_ApplyFogOfWarPattern( Alpha, Coordinate, FogOfWarAlphaMask );
	
	return FogOfWarAlphaMin + Alpha * (1.0f - FogOfWarAlphaMin);
}

float3 FogOfWarBlend( float3 Color, float Alpha )
{		
	float4 ColorAndAlpha = FOG_OF_WAR_BLEND_FUNCTION( Alpha );
	return lerp( Color, ColorAndAlpha.rgb, ColorAndAlpha.a );
}

// Immediate mode
float3 JominiApplyFogOfWar( in float3 Color, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return Color;
#else
	float Alpha = GetFogOfWarAlpha( Coordinate, FogOfWarAlphaMask );
	return FogOfWarBlend( Color, Alpha );
#endif
}
float3 JominiApplyFogOfWarMultiSampled( in float3 Color, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return Color;
#else
	float Alpha = GetFogOfWarAlphaMultiSampled( Coordinate, FogOfWarAlphaMask );
	return FogOfWarBlend( Color, Alpha );
#endif
}

// Post process
float4 JominiApplyFogOfWar( in float3 WorldSpacePos, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return float4( vec3(0.0), 1.0 );
#else
	return FOG_OF_WAR_BLEND_FUNCTION( GetFogOfWarAlpha( WorldSpacePos, FogOfWarAlphaMask ) );
#endif
}

#ifndef ApplyFogOfWar		
#define ApplyFogOfWar JominiApplyFogOfWar
#endif
#ifndef ApplyFogOfWarMultiSampled		
#define ApplyFogOfWarMultiSampled JominiApplyFogOfWarMultiSampled
#endif



// === Main Code === 

float4 main( VS_OUTPUT_PARTICLE Input, bool PDX_IsFrontFace : SV_IsFrontFace ) : PDX_COLOR
{
	return Input.Color;
}

