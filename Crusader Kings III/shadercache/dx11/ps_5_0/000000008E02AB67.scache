

// === Shader Info === 

// Shader file: gfx/FX/pdxborder.shader
// Effect: PdxBorderStruggle



// === Defines === 

#define PDX_DIRECTX_11
#define PIXEL_SHADER
#define PDX_HLSL
#define VENDOR_NVIDIA
#define PDX_MAX_HEIGHTMAP_COMPRESS_LEVELS 5
#define JOMINI_REFRACTION_ENABLED
#define PDX_WINDOWS


// === HLSL Macros === 

#define PDX_POSITION SV_Position
#define PDX_COLOR SV_Target
#define PDX_COLOR0 SV_Target0
#define PDX_COLOR0_SRC1 SV_Target1 // Use this when doing dual source blending, currently only supports that for render target #0
#define PDX_COLOR1 SV_Target1
#define PDX_COLOR2 SV_Target2
#define PDX_COLOR3 SV_Target3
#define PDX_COLOR4 SV_Target4
#define PDX_COLOR5 SV_Target5
#define PDX_COLOR6 SV_Target6
#define PDX_COLOR7 SV_Target7
#define PDX_VertexID SV_VertexID
#define PDX_InstanceID SV_InstanceID
#define PDX_DispatchThreadID SV_DispatchThreadID
#define PDX_GroupThreadID SV_GroupThreadID
#define PDX_GroupID SV_GroupID
#define PDX_GroupIndex SV_GroupIndex
#define PDX_TessFactor SV_TessFactor
#define PDX_InsideTessFactor SV_InsideTessFactor
#define PDX_OutputControlPointID SV_OutputControlPointID
#define PDX_DomainLocation SV_DomainLocation
#define PDX_RenderTargetArrayIndex SV_RenderTargetArrayIndex
#define PDX_ViewportArrayIndex SV_ViewportArrayIndex

#define PdxDomainTypeTriangle "tri"
#define PdxDomainTypeQuad "quad"
#define PdxDomainTypeIsoline "isoline"

#define PdxPartitioningModeInteger "integer"
#define PdxPartitioningModeFractionalEven "fractional_even"
#define PdxPartitioningModeFractionalOdd "fractional_odd"

#define PdxPrimitiveTypePoint point
#define PdxPrimitiveTypeLine line
#define PdxPrimitiveTypeTriangle triangle
#define PdxPrimitiveTypeLineAdjacency lineadj
#define PdxPrimitiveTypeTriangleAdjacency triangleadj

#define PdxTessellatorOutputTopologyPoint "point"
#define PdxTessellatorOutputTopologyLine "line"
#define PdxTessellatorOutputTopologyTriangleCw "triangle_cw"
#define PdxTessellatorOutputTopologyTriangleCcw "triangle_ccw"

#define PdxMeshShaderOutputTopologyLine "line"
#define PdxMeshShaderOutputTopologyTriangle "triangle"

#define mod( X, Y ) ( (X) % (Y) )

float2x2 Create2x2( in float2 x, in float2 y )
{
	return transpose( float2x2( x, y ) );
}
// TODO, Create3x3 should be transposed in hlsl, and not in glsl, and then the mul() arguments should be reversed
#define Create3x3 float3x3
float4x4 Create4x4( in float4 x, in float4 y, in float4 z, in float4 w )
{
	return transpose( float4x4( x, y, z, w ) );
}

#define GetMatrixData( Matrix, row, col ) ( Matrix [ row ] [ col ] )

float3x3 CastTo3x3( in float4x4 M )
{
	return (float3x3)M;
}

#define lessThan( a, b ) ( (a) < (b) )

float2 vec2(float vValue) { return float2(vValue, vValue); }
float3 vec3(float vValue) { return float3(vValue, vValue, vValue); }
float4 vec4(float vValue) { return float4(vValue, vValue, vValue, vValue); }


struct PdxTextureSampler2D
{
    Texture2D 		_Texture;
    SamplerState 	_Sampler;
};
struct PdxTextureSampler2DMS
{
    Texture2DMS<float4>		_Texture;
};

struct PdxTextureSampler2DArray
{
    Texture2DArray	_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSampler3D
{
    Texture3D 		_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSamplerCube
{
    TextureCube 	_Texture;
    SamplerState 	_Sampler;
};

struct PdxTextureSampler2DCmp
{
    Texture2D 				_Texture;
    SamplerComparisonState 	_Sampler;
};

// These are for separate Texture/Sampler objects
#define PdxSampleTex2D(tex,samp,uv) (tex).Sample( (samp), (uv) )
#define PdxSampleTex2DLod(tex,samp,uv,lod) (tex).SampleLevel( (samp), (uv), (lod) )
#define PdxSampleTex2DGrad(tex,samp,uv,ddx,ddy) (tex).SampleGrad( (samp), (uv), (ddx), (ddy) )
#define PdxSampleTex2DGather(tex,samp,uv) (tex).Gather( (samp), (uv) )

#define PdxSampleTex3D(tex,samp,uv) (tex).Sample( (samp), (uv) )
#define PdxSampleTex3DLod(tex,samp,uv,lod) (tex).SampleLevel( (samp), (uv), (lod) )

#define PdxTexture2DSize(tex,size) (tex).GetDimensions( (size).x, (size).y )
#define PdxTexture2DLoad(tex,uv,lod) (tex).Load( int3((uv), (lod)) )

#define PdxTexture2DArraySize(tex,size,elements) (tex).GetDimensions( (size).x, (size).y, elements )

#define PdxTexture3DSize(tex,size) (tex).GetDimensions( (size).x, (size).y, (size).z )
#define PdxTexture3DLoad(tex,uv,lod) (tex).Load( int4((uv), (lod)) )

// These are for the combined TextureSampler objects
#define PdxTex2DSize(samp,size) PdxTexture2DSize( (samp)._Texture, (size) )
#define PdxTex2D(samp,uv) PdxSampleTex2D( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex2DLod(samp,uv,lod) PdxSampleTex2DLod( (samp)._Texture, (samp)._Sampler, (uv), (lod) )
#define PdxTex2DLodOffset(samp,uv,lod,offset) (samp)._Texture.SampleLevel( (samp)._Sampler, (uv), (lod), (offset) )
#define PdxTex2DBias(samp,uv,bias) (samp)._Texture.SampleBias( (samp)._Sampler, (uv), (bias) )
#define PdxTex2DGrad(samp,uv,ddx,ddy) PdxSampleTex2DGrad( (samp)._Texture, (samp)._Sampler, (uv), (ddx), (ddy) )
#define PdxTex2DGather(samp,uv) PdxSampleTex2DGather( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex2DLoad(samp,uv,lod) PdxTexture2DLoad( (samp)._Texture, (uv), (lod) )
#define PdxTex2DMultiSampled(samp,texelcoord,sampleidx) (samp)._Texture.Load( (texelcoord), (sampleidx) )
#define PdxTex2DMSSize(samp,size,samples) (samp)._Texture.GetDimensions( (size).x, (size).y, (samples) )

#define PdxTex3D(samp,uv) PdxSampleTex3D( (samp)._Texture, (samp)._Sampler, (uv) )
#define PdxTex3DLod(samp,uv,lod) PdxSampleTex3DLod( (samp)._Texture, (samp)._Sampler, (uv), (lod) )
#define PdxTex3DLoad(samp,uv,lod) PdxTexture3DLoad( (samp)._Texture, (uv), (lod) )

#define PdxTexCube(samp,uv) (samp)._Texture.Sample( (samp)._Sampler, (uv) )
#define PdxTexCubeLod(samp,uv,lod) (samp)._Texture.SampleLevel( (samp)._Sampler, (uv), (lod) )
#define PdxTexCubeBias(samp,uv,bias) (samp)._Texture.SampleBias( (samp)._Sampler, (uv), (bias) )

#define PdxTex2DCmpLod0(samp,uv,value) (samp)._Texture.SampleCmpLevelZero( (samp)._Sampler, (uv), (value) )

// Vulkan fails to compile shaders with this function call properly
// Commenting it out until we can fix this issue
//#define PdxCalculateLod(samp,uv) (samp)._Texture.CalculateLevelOfDetail( (samp)._Sampler, (uv) )

float4x4 FixProjection( float4x4 ProjectionMatrix )
{
	// Enable for "debug" drawing to see if some objects is missing fix
	#if 0
	for ( int i = 0; i < 4; ++i )
	{
		GetMatrixData( ProjectionMatrix, 0, i ) *= 0.5;
		GetMatrixData( ProjectionMatrix, 1, i ) *= 0.5;
	}
	#endif
	
	return ProjectionMatrix;
}

#define PdxBufferFloat  Buffer<float>
#define PdxBufferFloat2	Buffer<float2>
#define PdxBufferFloat3	Buffer<float3>
#define PdxBufferFloat4	Buffer<float4>
#define PdxBufferInt  	Buffer<int>
#define PdxBufferInt2	Buffer<int2>
#define PdxBufferInt3	Buffer<int3>
#define PdxBufferInt4	Buffer<int4>
#define PdxBufferUint   Buffer<uint>
#define PdxBufferUint2	Buffer<uint2>
#define PdxBufferUint3	Buffer<uint3>
#define PdxBufferUint4	Buffer<uint4>

#define PdxStructuredBuffer StructuredBuffer
#define PdxRWStructuredBuffer RWStructuredBuffer
#define PdxRasterizerOrderedBuffer RasterizerOrderedBuffer
#define PdxRasterizerOrderedStructuredBuffer RasterizerOrderedStructuredBuffer

float 	PdxReadBuffer( in PdxBufferFloat Buf, int Index )  		{ return Buf.Load( Index ); }
float2	PdxReadBuffer2( in PdxBufferFloat2 Buf, int Index )		{ return Buf.Load( Index ); }
float3	PdxReadBuffer3( in PdxBufferFloat3 Buf, int Index )		{ return Buf.Load( Index ); }
float4	PdxReadBuffer4( in PdxBufferFloat4 Buf, int Index )		{ return Buf.Load( Index ); }

int  	PdxReadBuffer( in PdxBufferInt Buf, int Index ) 		{ return Buf.Load( Index ); }
int2 	PdxReadBuffer2( in PdxBufferInt2 Buf, int Index )		{ return Buf.Load( Index ); }
int3 	PdxReadBuffer3( in PdxBufferInt3 Buf, int Index )    	{ return Buf.Load( Index ); }
int4 	PdxReadBuffer4( in PdxBufferInt4 Buf, int Index )    	{ return Buf.Load( Index ); }

uint  	PdxReadBuffer( in PdxBufferUint Buf, int Index )    	{ return Buf.Load( Index ); }
uint2 	PdxReadBuffer2( in PdxBufferUint2 Buf, int Index )  	{ return Buf.Load( Index ); }
uint3 	PdxReadBuffer3( in PdxBufferUint3 Buf, int Index )  	{ return Buf.Load( Index ); }
uint4 	PdxReadBuffer4( in PdxBufferUint4 Buf, int Index )  	{ return Buf.Load( Index ); }

#define PdxReadRWBuffer(buffer,index) (buffer)[(index)]
#define PdxWriteRWBuffer(buffer,index,value) (buffer)[(index)] = (value)

#define UINT16_MAX 0xffff
#define PI 3.14159265359

float2x2 Create2x2( float a, float b, float c, float d ) { return Create2x2( float2( a, b ), float2( c, d ) ); }

#define PdxSampleTex2DLod0(tex,samp,uv) PdxSampleTex2DLod( (tex), (samp), (uv), 0 )

#define PdxTexture2DLoad0(tex,uv) PdxTexture2DLoad( (tex), (uv), 0 )

#define PdxTex2DProj(samp,uv_proj) PdxTex2DLod0( (samp), (uv_proj).xy / (uv_proj).w )
#define PdxTex2DLod0(samp,uv) PdxTex2DLod( (samp), (uv), 0 )
#define PdxTex2DLod0Offset(samp,uv,offset) PdxTex2DLodOffset( (samp), (uv), 0, (offset) )
#define PdxTex2DLoad0(samp,uv) PdxTex2DLoad( (samp), (uv), 0 )

#define PdxTex3DLod0(samp,uv) PdxTex3DLod( (samp), (uv), 0 )
#define PdxTex3DLoad0(samp,uv) PdxTex3DLoad( (samp), (uv), 0 )

float4 FixProjectionAndMul( float4x4 ProjectionMatrix, float4 Vector )
{
	return mul( FixProjection( ProjectionMatrix ), Vector );
}



// === Vertex Structs === 

struct VS_INPUT_PDX_BORDER
{
	float3 Position : TEXCOORD0;
	float2 UV : TEXCOORD1;
};
struct VS_OUTPUT_PDX_BORDER
{
	float4 Position : PDX_POSITION;
	float3 WorldSpacePos : TEXCOORD0;
	float2 UV : TEXCOORD1;
	float4 ShadowProj : TEXCOORD2;
};


// === Constant Buffers === 

cbuffer pdx_hlsl_cb53
{
	float4x4 ViewProjectionMatrix;
	float4x4 InvViewProjectionMatrix;
	float4x4 ViewMatrix;
	float4x4 InvViewMatrix;
	float4x4 ProjectionMatrix;
	float4x4 InvProjectionMatrix;
	float4x4 ShadowMapTextureMatrix;
	float3 CameraPosition;
	float ZNear;
	float3 CameraLookAtDir;
	float ZFar;
	float3 CameraUpDir;
	float CameraFoV;
	float3 CameraRightDir;
	float _UpscaleLodBias;
	float _UpscaleLodBiasNative;
	float _UpscaleLodBiasMultiplier;
	float _UpscaleLodBiasMultiplierNative;
	float _UpscaleLodBiasEnabled;
}
cbuffer pdx_hlsl_cb37
{
	float _HeightOffset;
	uint _UserId;
	float _Alpha;
}
cbuffer pdx_hlsl_cb17
{
	float3 AmbientPosX;
	float CubemapIntensity;
	float3 AmbientNegX;
	float3 AmbientPosY;
	float3 AmbientNegY;
	float3 AmbientPosZ;
	float3 AmbientNegZ;
	float3 ShadowAmbientPosX;
	float3 ShadowAmbientNegX;
	float3 ShadowAmbientPosY;
	float3 ShadowAmbientNegY;
	float3 ShadowAmbientPosZ;
	float3 ShadowAmbientNegZ;
	float FogMax;
	float3 SunDiffuse;
	float SunIntensity;
	float3 ToSunDir;
	float FogBegin2;
	float3 FogColor;
	float FogEnd2;
	float4x4 CubemapYRotation;
	float TreeSwayLoopSpeed;
	float TreeSwayWindStrengthSpatialModifier;
	float TreeSwaySpeed;
	float TreeSwayWindClusterSizeModifier;
	float3 TreeSwayWorldDirection;
	float TreeHeightImpactOnSway;
	float TreeSwayScale;
}
cbuffer pdx_hlsl_cb9
{
	float2 FogOfWarAlphaMapSize;
	float2 InverseWorldSize;
	float2 FogOfWarPatternSpeed;
	float FogOfWarPatternStrength;
	float FogOfWarPatternTiling;
	float FogOfWarTime;
	float FogOfWarAlphaMin;
}
cbuffer pdx_hlsl_cb52
{
	float ShadowFadeFactor;
	float Bias;
	float KernelScale;
	float ShadowScreenSpaceScale;
	int NumSamples;
	float4 DiscSamples[8];
}
cbuffer pdx_hlsl_cb4
{
	float2 MapSize;
	float GlobalTime;
	float FlatMapHeight;
	float FlatMapLerp;
	float MapHighlightIntensity;
	float SnowHighlightIntensity;
	int HasFlatMapLightingEnabled;
}


// === Samplers === 

SamplerState _sampler_0_ : register(s0);
SamplerState _sampler_1_ : register(s1);
SamplerComparisonState _sampler_2_ : register(s2);
SamplerState _sampler_3_ : register(s3);


// === Textures === 

Texture2D BorderTexture_Texture;
static PdxTextureSampler2D BorderTexture = { BorderTexture_Texture, _sampler_0_ };
Texture2D FogOfWarAlpha_Texture;
static PdxTextureSampler2D FogOfWarAlpha = { FogOfWarAlpha_Texture, _sampler_1_ };
Texture2D ShadowMap_Texture;
static PdxTextureSampler2DCmp ShadowMap = { ShadowMap_Texture, _sampler_2_ };
TextureCube EnvironmentMap_Texture;
static PdxTextureSamplerCube EnvironmentMap = { EnvironmentMap_Texture, _sampler_3_ };


// === RW Textures === 



// === Buffer Textures === 



// === RW Buffer Textures === 



// === Shader Code === 

float CalcViewSpaceDepth( float Depth )
{
	Depth = 2.0 * Depth - 1.0;
	float ZLinear = 2.0 * ZNear * ZFar / (ZFar + ZNear - Depth * (ZFar - ZNear));
	return ZLinear;
}

float3 ViewSpacePosFromDepth( float Depth, float2 UV )
{
	float x = UV.x * 2.0 - 1.0;
	float y = (1.0 - UV.y) * 2.0 - 1.0;
	
	float4 ProjectedPos = float4( x, y, Depth, 1.0 );
	
	float4 ViewSpacePos = mul( InvProjectionMatrix, ProjectedPos );
	
	return ViewSpacePos.xyz / ViewSpacePos.w;
}

float3 WorldSpacePositionFromDepth( float Depth, float2 UV )
{
	float3 WorldSpacePos = mul( InvViewMatrix, float4( ViewSpacePosFromDepth( Depth, UV ), 1.0 ) ).xyz;		
	return WorldSpacePos;  
}
float CalculateDistanceFogFactor( float3 WorldSpacePos )
{
	float3 Diff = CameraPosition - WorldSpacePos;
	float vFogFactor = 1.0 - abs( normalize( Diff ).y ); // abs b/c of reflections
	float vSqDistance = dot( Diff, Diff );

	float vMin = min( ( vSqDistance - FogBegin2 ) / ( FogEnd2 - FogBegin2 ), FogMax );
	return saturate( vMin * vFogFactor );
}

float3 ApplyDistanceFog( float3 Color, float vFogFactor )
{
	return lerp( Color, FogColor, vFogFactor );
}

float3 ApplyDistanceFog( float3 Color, float3 WorldSpacePos )
{
	return ApplyDistanceFog( Color, CalculateDistanceFogFactor( WorldSpacePos ) );
}
float CalcRandom( float Seed )
{
	float DotProduct = float( Seed ) * 12.9898;
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcRandom( float2 Seed )
{
	float DotProduct = dot( Seed, float2( 12.9898, 78.233 ) );
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcRandom( float3 Seed )
{
	float DotProduct = dot( Seed, float3( 12.9898,78.233,144.7272 ) );
	return frac( sin( DotProduct ) * 43758.5453 );
}

float CalcNoise( float2 Pos ) 
{
	int2 i = int2( floor( Pos ) );
	float2 f = frac( Pos );

	float a = CalcRandom( i );
	float b = CalcRandom( i + int2( 1, 0 ) );
	float c = CalcRandom( i + int2( 0, 1 ) );
	float d = CalcRandom( i + int2( 1, 1 ) );
	
	float2 u = f*f*(3.0-2.0*f);
	return lerp(a, b, u.x) + 
			(c - a)* u.y * (1.0 - u.x) + 
			(d - b) * u.x * u.y;
}
// --------------------------------------------------------------
// A collection of constants that can be used to tweak the shaders
// To update: run "reloadfx all"
// --------------------------------------------------------------

static const float TWO_PI = 6.28318530718f;
static const float HALF_PI = 1.57079632679f;

// --------------------------------------------------------------
// ------------------    Lighting       -------------------------
// --------------------------------------------------------------
static const float SHADOW_AMBIENT_MIN_FACTOR = 0.0;
static const float SHADOW_AMBIENT_MAX_FACTOR = 0.3;


// --------------------------------------------------------------
// ------------------    TERRAIN        -------------------------
// --------------------------------------------------------------
static const float COLORMAP_OVERLAY_STRENGTH 	= 1.00f;


// --------------------------------------------------------------
// ------------------    WATER          -------------------------
// --------------------------------------------------------------
static const float  WATER_TIME_SCALE	= 1.0f / 50.0f;


// --------------------------------------------------------------
// ------------------    HOVERING       -------------------------
// --------------------------------------------------------------
static const float3  HOVER_COLOR	= float3(1.0f, 0.772f, 0.341f);
static const float HOVER_INTENSITY = 10.0f;
static const float HOVER_FRESNEL_BIAS = 0.004f;
static const float HOVER_FRESNEL_POWER = 8.0f;

#ifndef FOG_OF_WAR_BLEND_FUNCTION
	#define FOG_OF_WAR_BLEND_FUNCTION loc_BlendFogOfWar
	float4 loc_BlendFogOfWar( float Alpha )
	{
		return float4( vec3(0.0), 1.0 - Alpha );
	}
#endif

void loc_ApplyFogOfWarPattern( inout float Alpha, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
	if( FogOfWarPatternStrength > 0.0f )
	{
		float2 UV = Coordinate.xz * InverseWorldSize * FogOfWarPatternTiling;
		UV += FogOfWarPatternSpeed * FogOfWarTime;
		float Noise1 = 1.0f - PdxTex2D( FogOfWarAlphaMask, UV ).g;
		float Noise2 = 1.0f - PdxTex2D( FogOfWarAlphaMask, UV * -0.13 ).g;
		float Detail = 0.5f;
		
		float Noise = saturate( Noise2 * (1.0f-Detail) + Detail * 0.5f + (Noise1-0.5f) * Detail );
		
		Noise *= 1.0f - Alpha;
		Alpha = smoothstep( 0.0, 1.0, Alpha + Noise * FogOfWarPatternStrength );
	}
}
float GetFogOfWarAlpha( in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{		
	float Alpha = PdxTex2D( FogOfWarAlphaMask, Coordinate.xz * InverseWorldSize ).r;
	
	loc_ApplyFogOfWarPattern( Alpha, Coordinate, FogOfWarAlphaMask );
	
	return FogOfWarAlphaMin + Alpha * (1.0f - FogOfWarAlphaMin);
}
float GetFogOfWarAlphaMultiSampled( in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
	float Width = 5.0f;
	float Alpha = 0.0f; 
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 0,-1) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2(-1, 0) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 1, 0) * Width ) * InverseWorldSize ).r;
	Alpha += PdxTex2D( FogOfWarAlphaMask, ( Coordinate.xz + float2( 0, 1) * Width ) * InverseWorldSize ).r;
	Alpha /= 4.0f;
	
	loc_ApplyFogOfWarPattern( Alpha, Coordinate, FogOfWarAlphaMask );
	
	return FogOfWarAlphaMin + Alpha * (1.0f - FogOfWarAlphaMin);
}

float3 FogOfWarBlend( float3 Color, float Alpha )
{		
	float4 ColorAndAlpha = FOG_OF_WAR_BLEND_FUNCTION( Alpha );
	return lerp( Color, ColorAndAlpha.rgb, ColorAndAlpha.a );
}

// Immediate mode
float3 JominiApplyFogOfWar( in float3 Color, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return Color;
#else
	float Alpha = GetFogOfWarAlpha( Coordinate, FogOfWarAlphaMask );
	return FogOfWarBlend( Color, Alpha );
#endif
}
float3 JominiApplyFogOfWarMultiSampled( in float3 Color, in float3 Coordinate, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return Color;
#else
	float Alpha = GetFogOfWarAlphaMultiSampled( Coordinate, FogOfWarAlphaMask );
	return FogOfWarBlend( Color, Alpha );
#endif
}

// Post process
float4 JominiApplyFogOfWar( in float3 WorldSpacePos, PdxTextureSampler2D FogOfWarAlphaMask )
{
#ifdef JOMINI_DISABLE_FOG_OF_WAR
	return float4( vec3(0.0), 1.0 );
#else
	return FOG_OF_WAR_BLEND_FUNCTION( GetFogOfWarAlpha( WorldSpacePos, FogOfWarAlphaMask ) );
#endif
}

#ifndef ApplyFogOfWar		
#define ApplyFogOfWar JominiApplyFogOfWar
#endif
#ifndef ApplyFogOfWarMultiSampled		
#define ApplyFogOfWarMultiSampled JominiApplyFogOfWarMultiSampled
#endif

float CalcLightFalloff( float LightRadius, float Distance, float Falloff )
{
	// TODO other, square, falloff?
	return saturate( (LightRadius - Distance) / Falloff );
}

float CalcLightFalloff( float LightRadius, float Distance )
{
	// This is basically the unreal method, square distance falloff but capped at "LightRadius" distance and capped at intensity 1 at distance 0.
	return pow( saturate( 1.0 - pow( Distance / LightRadius, 4.0 ) ), 2.0 ) / ( Distance * Distance + 1.0 );
}


float3 MetalnessToDiffuse( float Metalness, float3 Diffuse )
{
	return lerp( Diffuse, vec3(0.0), Metalness );
}

float3 MetalnessToSpec( float Metalness, float3 Diffuse, float Spec )
{
	return lerp( vec3(Spec), Diffuse, Metalness );
}


#ifndef PDX_NumMips
	#define PDX_NumMips 10.0
#endif

#ifndef PDX_MipOffset
	#define PDX_MipOffset 2.0
#endif

#define PDX_SimpleLighting


struct SMaterialProperties
{
	float 	_PerceptualRoughness;
	float 	_Roughness;
	float	_Metalness;
	
	float3	_DiffuseColor;
	float3	_SpecularColor;
	float3	_Normal;
};

struct SLightingProperties
{
	float3		_ToCameraDir;
	float3		_ToLightDir;
	float3		_LightIntensity;
	float		_ShadowTerm;
	float		_CubemapIntensity;
	// this rotation matrix is used to rotate cubemap sampling vectors, thus "faking" a rotation of the cubemap
	float4x4	_CubemapYRotation;
};

float RemapSpec( float SampledSpec )
{
	return 0.25 * SampledSpec;
}
	
float RoughnessFromPerceptualRoughness( float PerceptualRoughness )
{
	return PerceptualRoughness * PerceptualRoughness;
}

float BurleyToMipSimple( float PerceptualRoughness )
{
   float Scale = PerceptualRoughness * (1.7 - 0.7 * PerceptualRoughness);
   return Scale * ( PDX_NumMips - 1 - PDX_MipOffset );
}

float3 GetSpecularDominantDir( float3 Normal, float3 Reflection, float Roughness )
{
	float Smoothness = saturate( 1.0 - Roughness );
	float LerpFactor = Smoothness * ( sqrt( Smoothness ) + Roughness );
	return normalize( lerp( Normal, Reflection, LerpFactor ) );
}

float GetReductionInMicrofacets( float Roughness )
{
	return 1.0 / (Roughness*Roughness + 1.0);
}

float F_Schlick( float f0, float f90, float CosAngle )
{
	return f0 + ( f90 - f0 ) * pow( 1.0 - CosAngle, 5.0 );
}

float3 F_Schlick( float3 f0, float3 f90, float CosAngle )
{
	return f0 + ( f90 - f0 ) * pow( 1.0 - CosAngle, 5.0 );
}
        

float DisneyDiffuse( float NdotV, float NdotL, float LdotH, float LinearRoughness )
{
	float EnergyBias = lerp( 0.0, 0.5, LinearRoughness );
	float EnergyFactor = lerp( 1.0, 1.0 / 1.51, LinearRoughness );
	float f90 = EnergyBias + 2.0 * LdotH * LdotH * LinearRoughness;
	float LightScatter = F_Schlick( 1.0, f90, NdotL );
	float ViewScatter = F_Schlick( 1.0, f90, NdotV );
	
	return LightScatter * ViewScatter * EnergyFactor;
}

float CalcDiffuseBRDF( float NdotV, float NdotL, float LdotH, float PerceptualRoughness )
{
#ifdef PDX_SimpleLighting
	return 1.0 / PI;
#else
	return DisneyDiffuse( NdotV, NdotL, LdotH, PerceptualRoughness ) / PI;
#endif
}


float D_GGX( float NdotH, float Alpha )
{
	float Alpha2 = Alpha * Alpha;
	float f = ( NdotH * Alpha2 - NdotH ) * NdotH + 1.0;
	return Alpha2 / (PI * f * f);
}

float G1( float CosAngle, float k )
{
	return 1.0 / ( CosAngle * ( 1.0 - k ) + k );
}

float V_Schlick( float NdotL, float NdotV, float Alpha )
{
	float k = Alpha * 0.5;
	return G1( NdotL, k ) * G1( NdotV, k ) * 0.25;
}

float V_Optimized( float LdotH, float Alpha )
{
	float k = Alpha * 0.5;
	float k2 = k*k;
	float invk2 = 1.0 - k2;
	return 0.25 / ( LdotH * LdotH * invk2 + k2 );
}
        
float3 CalcSpecularBRDF( float3 SpecularColor, float LdotH, float NdotH, float NdotL, float NdotV, float Roughness )
{
	float3 F = F_Schlick( SpecularColor, vec3(1.0), LdotH );
	float D = D_GGX( NdotH, lerp( 0.03, 1.0, Roughness ) ); // Remap to avoid super small and super bright highlights
#ifdef PDX_SimpleLighting
	float Vis = V_Optimized( LdotH, Roughness );
#else
	float Vis = V_Schlick( NdotL, NdotV, Roughness );
#endif
	return D * F * Vis;
}

void CalculateLightingFromLight( SMaterialProperties MaterialProps, float3 ToCameraDir, float3 ToLightDir, float3 LightIntensity, out float3 DiffuseOut, out float3 SpecularOut )
{
	float3 H = normalize( ToCameraDir + ToLightDir );
	float NdotV = saturate( dot( MaterialProps._Normal, ToCameraDir ) ) + 1e-5;
	float NdotL = saturate( dot( MaterialProps._Normal, ToLightDir ) ) + 1e-5;
	float NdotH = saturate( dot( MaterialProps._Normal, H ) );
	float LdotH = saturate( dot( ToLightDir, H ) );
	
	float DiffuseBRDF = CalcDiffuseBRDF( NdotV, NdotL, LdotH, MaterialProps._PerceptualRoughness );
	DiffuseOut = DiffuseBRDF * MaterialProps._DiffuseColor * LightIntensity * NdotL;
	
#ifdef PDX_HACK_ToSpecularLightDir
	float3 H_Spec = normalize( ToCameraDir + PDX_HACK_ToSpecularLightDir );
	float NdotL_Spec = saturate( dot( MaterialProps._Normal, PDX_HACK_ToSpecularLightDir ) ) + 1e-5;
	float NdotH_Spec = saturate( dot( MaterialProps._Normal, H_Spec ) );
	float LdotH_Spec = saturate( dot( PDX_HACK_ToSpecularLightDir, H_Spec ) );
	float3 SpecularBRDF = CalcSpecularBRDF( MaterialProps._SpecularColor, LdotH_Spec, NdotH_Spec, NdotL_Spec, NdotV, MaterialProps._Roughness );
	SpecularOut = SpecularBRDF * LightIntensity * NdotL;
#else
	float3 SpecularBRDF = CalcSpecularBRDF( MaterialProps._SpecularColor, LdotH, NdotH, NdotL, NdotV, MaterialProps._Roughness );
	SpecularOut = SpecularBRDF * LightIntensity * NdotL;
#endif
}

void CalculateLightingFromLight( SMaterialProperties MaterialProps, SLightingProperties LightingProps, out float3 DiffuseOut, out float3 SpecularOut )
{
	CalculateLightingFromLight( MaterialProps, LightingProps._ToCameraDir, LightingProps._ToLightDir, LightingProps._LightIntensity * LightingProps._ShadowTerm, DiffuseOut, SpecularOut );
}

void CalculateLightingFromIBL( SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap, out float3 DiffuseIBLOut, out float3 SpecularIBLOut )
{
	float3 RotatedDiffuseCubemapUV = mul( CastTo3x3( LightingProps._CubemapYRotation ), MaterialProps._Normal );
	float3 DiffuseRad = PdxTexCubeLod( EnvironmentMap, RotatedDiffuseCubemapUV, ( PDX_NumMips - 1 - PDX_MipOffset ) ).rgb * LightingProps._CubemapIntensity; // TODO, maybe we should split diffuse and spec intensity?
	DiffuseIBLOut = DiffuseRad * MaterialProps._DiffuseColor;
	
	float3 ReflectionVector = reflect( -LightingProps._ToCameraDir, MaterialProps._Normal );
	float3 DominantReflectionVector = GetSpecularDominantDir( MaterialProps._Normal, ReflectionVector, MaterialProps._Roughness );

	float NdotR = saturate( dot( MaterialProps._Normal, DominantReflectionVector ) );
	float3 SpecularReflection = F_Schlick( MaterialProps._SpecularColor, vec3( 1.0f ), NdotR );
	float SpecularFade = GetReductionInMicrofacets( MaterialProps._Roughness );

	float MipLevel = BurleyToMipSimple( MaterialProps._PerceptualRoughness );
	float3 RotatedSpecularCubemapUV = mul( CastTo3x3( LightingProps._CubemapYRotation ), DominantReflectionVector );
	float3 SpecularRad = PdxTexCubeLod( EnvironmentMap, RotatedSpecularCubemapUV, MipLevel ).rgb * LightingProps._CubemapIntensity; // TODO, maybe we should split diffuse and spec intensity?
	#ifdef IOR
		float3 RefractionVector = refract( -LightingProps._ToCameraDir, MaterialProps._Normal, 1.0f / IOR );
		float3 DominantRefractionVector = GetSpecularDominantDir( MaterialProps._Normal, RefractionVector, MaterialProps._Roughness );
		float3 RefractionRotatedSpecularCubemapUV = mul( CastTo3x3( LightingProps._CubemapYRotation ), DominantRefractionVector );
		float3 RefractionSpecularRad = PdxTexCubeLod( EnvironmentMap, RefractionRotatedSpecularCubemapUV, MipLevel ).rgb * LightingProps._CubemapIntensity;
		float Refraction_strength = 0.15f;
			#if defined( REFRACTION_STRENGTH )
				Refraction_strength = REFRACTION_STRENGTH;
			#endif
		RefractionSpecularRad = RefractionSpecularRad * (1 - MaterialProps._Roughness) * Refraction_strength;
		SpecularIBLOut = lerp ( RefractionSpecularRad, SpecularRad, SpecularReflection ) * SpecularFade;
	#else
		SpecularIBLOut = SpecularRad * SpecularFade * SpecularReflection;
	#endif
}

float4x4 Float4x4Identity()
{
	return float4x4( 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );
}

SMaterialProperties GetMaterialProperties( float3 SampledDiffuse, float3 Normal, float SampledRoughness, float SampledSpec, float SampledMetalness )
{
	SMaterialProperties MaterialProps;
	
	MaterialProps._PerceptualRoughness = SampledRoughness;
	MaterialProps._Roughness = RoughnessFromPerceptualRoughness( MaterialProps._PerceptualRoughness );

	float SpecRemapped = RemapSpec( SampledSpec );
	MaterialProps._Metalness = SampledMetalness;

	MaterialProps._DiffuseColor = MetalnessToDiffuse( MaterialProps._Metalness, SampledDiffuse );
	MaterialProps._SpecularColor = MetalnessToSpec( MaterialProps._Metalness, SampledDiffuse, SpecRemapped );
	
	MaterialProps._Normal = Normal;
	
	return MaterialProps;
}

// Generate the texture co-ordinates for a PCF kernel
void CalculateCoordinates( float2 ShadowCoord, inout float2 TexCoords[5] )
{
	// Generate the texture co-ordinates for the specified depth-map size
	TexCoords[0] = ShadowCoord + float2( -KernelScale, 0.0f );
	TexCoords[1] = ShadowCoord + float2( 0.0f, KernelScale );
	TexCoords[2] = ShadowCoord + float2( KernelScale, 0.0f );
	TexCoords[3] = ShadowCoord + float2( 0.0f, -KernelScale );
	TexCoords[4] = ShadowCoord;
}

float CalculateShadow( float4 ShadowProj, PdxTextureSampler2D ShadowMap )
{
	ShadowProj.xyz = ShadowProj.xyz / ShadowProj.w;
	
	float2 TexCoords[5];
	CalculateCoordinates( ShadowProj.xy, TexCoords );
	
	// Sample each of them checking whether the pixel under test is shadowed or not
	float fShadowTerm = 0.0f;
	for( int i = 0; i < 5; i++ )
	{				
		float A = PdxTex2DLod0( ShadowMap, TexCoords[i] ).r;
		float B = ShadowProj.z - Bias;
		
		// Texel is shadowed
		fShadowTerm += ( A < 0.99f && A < B ) ? 0.0 : 1.0;
	}
	
	// Get the average
	fShadowTerm = fShadowTerm / 5.0f;
	return lerp( 1.0, fShadowTerm, ShadowFadeFactor );
}

float2 RotateDisc( float2 Disc, float2 Rotate )
{
	return float2( Disc.x * Rotate.x - Disc.y * Rotate.y, Disc.x * Rotate.y + Disc.y * Rotate.x );
}

float CalculateShadow( float4 ShadowProj, PdxTextureSampler2DCmp ShadowMap )
{
	ShadowProj.xyz = ShadowProj.xyz / ShadowProj.w;
	
	float RandomAngle = CalcRandom( round( ShadowScreenSpaceScale * ShadowProj.xy ) ) * 3.14159 * 2.0;
	float2 Rotate = float2( cos( RandomAngle ), sin( RandomAngle ) );

	// Sample each of them checking whether the pixel under test is shadowed or not
	float ShadowTerm = 0.0;
	for( int i = 0; i < NumSamples; i++ )
	{
		float4 Samples = DiscSamples[i] * KernelScale;
		ShadowTerm += PdxTex2DCmpLod0( ShadowMap, ShadowProj.xy + RotateDisc( Samples.xy, Rotate ), ShadowProj.z - Bias );
		ShadowTerm += PdxTex2DCmpLod0( ShadowMap, ShadowProj.xy + RotateDisc( Samples.zw, Rotate ), ShadowProj.z - Bias );
	}
	
	// Get the average
	ShadowTerm *= 0.5; // We have 2 samples per "sample"
	ShadowTerm = ShadowTerm / float(NumSamples);
	
	float3 FadeFactor = saturate( float3( 1.0 - abs( 0.5 - ShadowProj.xy ) * 2.0, 1.0 - ShadowProj.z ) * 32.0 ); // 32 is just a random strength on the fade
	ShadowTerm = lerp( 1.0, ShadowTerm, min( min( FadeFactor.x, FadeFactor.y ), FadeFactor.z ) );
	
	return lerp( 1.0, ShadowTerm, ShadowFadeFactor );
}

//-------------------------------
// Common lighting functions ----
//-------------------------------
SLightingProperties GetSunLightingProperties( float3 WorldSpacePos, float ShadowTerm )
{
	SLightingProperties LightingProps;
	LightingProps._ToCameraDir = normalize( CameraPosition - WorldSpacePos );
	LightingProps._ToLightDir = ToSunDir;
	LightingProps._LightIntensity = SunDiffuse * SunIntensity;
	LightingProps._ShadowTerm = ShadowTerm;
	LightingProps._CubemapIntensity = CubemapIntensity;
	LightingProps._CubemapYRotation = CubemapYRotation;
	
	return LightingProps;
}

SLightingProperties GetSunLightingProperties( float3 WorldSpacePos, PdxTextureSampler2DCmp ShadowMap )
{
	float4 ShadowProj = mul( ShadowMapTextureMatrix, float4( WorldSpacePos, 1.0 ) );
	float ShadowTerm = CalculateShadow( ShadowProj, ShadowMap );
	
	return GetSunLightingProperties( WorldSpacePos, ShadowTerm );
}

float3 CalculateSunLighting( SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap )
{
	float3 DiffuseLight;
	float3 SpecularLight;
	CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, SpecularLight );
	
	float3 DiffuseIBL;
	float3 SpecularIBL;
	CalculateLightingFromIBL( MaterialProps, LightingProps, EnvironmentMap, DiffuseIBL, SpecularIBL );
	
	return DiffuseLight + SpecularLight + DiffuseIBL + SpecularIBL;
}


//-------------------------------
// Debugging --------------------
//-------------------------------
//#define PDX_DEBUG_NORMAL
//#define PDX_DEBUG_DIFFUSE
//#define PDX_DEBUG_SPEC
//#define PDX_DEBUG_SPEC_RANGES
//#define PDX_DEBUG_ROUGHNESS
//#define PDX_DEBUG_METALNESS
//#define PDX_DEBUG_SHADOW
//#define PDX_DEBUG_SUN_LIGHT_SIMPLE_DIFFUSE // AKA Daniel mode
//#define PDX_DEBUG_SUN_LIGHT_ONLY_SPECULAR
//#define PDX_DEBUG_SUN_LIGHT
//#define PDX_DEBUG_SUN_LIGHT_WITH_SHADOW
//#define PDX_DEBUG_IBL_SIMPLE_DIFFUSE
//#define PDX_DEBUG_IBL_DIFFUSE
//#define PDX_DEBUG_IBL_SPECULAR
//#define PDX_DEBUG_IBL

void DebugReturn( inout float3 Out, SMaterialProperties MaterialProps, SLightingProperties LightingProps )
{
#ifdef PDX_DEBUG_NORMAL
	Out = saturate( MaterialProps._Normal );
#endif

#ifdef PDX_DEBUG_DIFFUSE
	Out = MaterialProps._DiffuseColor;
#endif

#ifdef PDX_DEBUG_SPEC
	Out = MaterialProps._SpecularColor;
#endif

#ifdef PDX_DEBUG_ROUGHNESS
	Out = vec3( MaterialProps._PerceptualRoughness );
#endif

#ifdef PDX_DEBUG_METALNESS
	Out = vec3( MaterialProps._Metalness );
#endif

#ifdef PDX_DEBUG_SPEC_RANGES
	// Shows extremely low specular values in red
	// Shows common material values in green (2-6%)
	// Shows gemstone material values in yellow (8-17%)
	// Shows metalness in blue
	// Shows everything else in gray scale	
	// Values based on page 14-15 in http://renderwonk.com/publications/s2010-shading-course/hoffman/s2010_physically_based_shading_hoffman_a_notes.pdf
	float Spec = MaterialProps._SpecularColor.r;
	
	float e = 0.002f;
	float ErrorThreshold = 0.01f;
	float DielectricLow = 0.02f;
	float DielectricHigh = 0.06f;
	float GemstoneLow = 0.08f;
	float GemstoneHigh = 0.17f;
	
	float Error = smoothstep( ErrorThreshold, 0.0, Spec );
	float CommonMask = smoothstep( DielectricLow-e, DielectricLow, Spec ) * smoothstep( DielectricHigh+e, DielectricHigh, Spec);
	float GemstoneMask = smoothstep( GemstoneLow-e, GemstoneLow, Spec ) * smoothstep( GemstoneHigh+e, GemstoneHigh, Spec);
	float ScaledSpec = ( Spec / RemapSpec(1.0f) );
	float3 DebugSpecColor = float3( GemstoneMask, CommonMask + GemstoneMask, 0.0 ) * ScaledSpec;
	Out = lerp( vec3(ScaledSpec), DebugSpecColor, CommonMask + GemstoneMask );
	Out = lerp( Out, float3(1.0,0.0,0.0), Error );
	Out = lerp( Out, float3(0.0,0.0,1.0), MaterialProps._Metalness );
#endif

#ifdef PDX_DEBUG_SHADOW
	Out = vec3( LightingProps._ShadowTerm );
#endif

#ifdef PDX_DEBUG_SUN_LIGHT_SIMPLE_DIFFUSE
	SMaterialProperties MaterialPropsCopy = MaterialProps;
	MaterialPropsCopy._DiffuseColor = vec3( 1.0 );
	MaterialPropsCopy._SpecularColor = vec3( 0.0 );
	
	float3 SpecularLight;
	CalculateLightingFromLight( MaterialPropsCopy, LightingProps, Out, SpecularLight );
#endif

#ifdef PDX_DEBUG_SUN_LIGHT_ONLY_SPECULAR			
	float3 DiffuseLight;			
	CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, Out );
#endif

#if defined( PDX_DEBUG_SUN_LIGHT ) || defined( PDX_DEBUG_SUN_LIGHT_WITH_SHADOW )
	float3 DiffuseLight;
	float3 SpecularLight;

	#ifdef PDX_DEBUG_SUN_LIGHT_WITH_SHADOW
		CalculateLightingFromLight( MaterialProps, LightingProps, DiffuseLight, SpecularLight );
	#else
		SLightingProperties LightingPropsNoShadow = LightingProps;
		LightingPropsNoShadow._ShadowTerm = 1.0;
		CalculateLightingFromLight( MaterialProps, LightingPropsNoShadow, DiffuseLight, SpecularLight );
	#endif
	
	Out = DiffuseLight + SpecularLight;
#endif
}

void DebugReturn( inout float3 Out, SMaterialProperties MaterialProps, SLightingProperties LightingProps, PdxTextureSamplerCube EnvironmentMap )
{
	DebugReturn( Out, MaterialProps, LightingProps );

#if defined( PDX_DEBUG_IBL ) || defined( PDX_DEBUG_IBL_DIFFUSE ) || defined( PDX_DEBUG_IBL_SPECULAR ) || defined( PDX_DEBUG_IBL_SIMPLE_DIFFUSE )
	float3 DiffuseIBL;
	float3 SpecularIBL;
	
	SMaterialProperties MaterialPropsCopy = MaterialProps;
	#ifdef PDX_DEBUG_IBL_SIMPLE_DIFFUSE
		MaterialPropsCopy._DiffuseColor = vec3( 1.0 );
	#endif
	
	CalculateLightingFromIBL( MaterialPropsCopy, LightingProps, EnvironmentMap, DiffuseIBL, SpecularIBL );
	
	#if defined( PDX_DEBUG_IBL_DIFFUSE ) || defined( PDX_DEBUG_IBL_SIMPLE_DIFFUSE )
		Out = DiffuseIBL;
	#endif
	#ifdef PDX_DEBUG_IBL_SPECULAR
		Out = SpecularIBL;
	#endif
	#ifdef PDX_DEBUG_IBL
		Out = DiffuseIBL + SpecularIBL;
	#endif
#endif
}



// === Main Code === 

			float4 main( VS_OUTPUT_PDX_BORDER Input, bool PDX_IsFrontFace : SV_IsFrontFace ) : PDX_COLOR
			{
				float4 Diffuse = PdxTex2D( BorderTexture, Input.UV );

				// _UserId is 1 if struggle is highlighted and 0 if not
				float Highlight = float( _UserId );

				float lowColorMult = 0.3f;
				float colorMult = lowColorMult + ( ( 1.0f - lowColorMult ) * Highlight );

				Diffuse.rgb = saturate( Diffuse.rgb * colorMult );

				Diffuse.rgb = ApplyFogOfWar( Diffuse.rgb, Input.WorldSpacePos, FogOfWarAlpha );
				Diffuse.rgb = ApplyDistanceFog( Diffuse.rgb, Input.WorldSpacePos );
				Diffuse.a *= _Alpha;

				// Apply shadows, only if we're fully in flat-map mode
 				if ( HasFlatMapLightingEnabled == 1 && FlatMapLerp > 0.0 )
				{
					float ShadowTerm = CalculateShadow( Input.ShadowProj, ShadowMap );
					SMaterialProperties MaterialProps = GetMaterialProperties( Diffuse.rgb, float3( 0.0, 1.0, 0.0 ), 1.0, 0.0, 0.0 );
					SLightingProperties LightingProps = GetSunLightingProperties( Input.WorldSpacePos, ShadowTerm );
					Diffuse.rgb = CalculateSunLighting( MaterialProps, LightingProps, EnvironmentMap );
				}

				return Diffuse;
			}
		